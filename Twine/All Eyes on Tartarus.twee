:: StoryTitle
All Eyes on Tartarus


:: StoryData
{
  "ifid": "603cb76a-579d-4d57-bff2-50fc09301310",
  "format": "Harlowe",
  "format-version": "3.3.9",
  "start": "Intro 1",
  "zoom": 1
}


:: Intro 1 {"position":"600,200","size":"100,100"}
All Eyes on Tartarus
(set: $playerSeenRadar to false)
<!-- Allow audio button  (unmute all audio) -->
<button id="playAudioButton">Allow Audio</button>
<script>
  // So far we only need to umute:
  // id="submarine-song"
  document.getElementById("playAudioButton").addEventListener("click", function() {
    audioMuted = false;
  }); 
</script>

[[Continue->Intro 2]]


:: Intro 2 {"position":"800,200","size":"100,100"}
The Silent Service
<!-- Take Her Down! (The Submarine Song) -->
<script>
  // If audio is already defined, we should stop it before starting a new one
  if (typeof audio !== 'undefined') {
    audio.pause();
    // And probably remove it from the memory
    delete audio;
  }
  audioSource = "../assets/take-her-down-submariners.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  // audio.muted = audioMuted;
  // If audioMuted is not defined, this will break the script
  // So we need to check and prevent this from happening
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>
[[Continue->Intro 3]]


:: Intro 3 {"position":"1000,200","size":"100,100"}
Construimus, Batuimus
<!-- The Seabees Song -->
<script>
  // Stops the previous audio
  if (typeof audio !== 'undefined') {
    audio.pause();
    delete audio;
  }
  audioSource = "../assets/song-of-the-seabees.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>

(if: $playerSeenRadar is false)[Player hasn't seen Radar]
(if: $playerSeenRadar is true)[Player has seen Radar]

[[Continue->Intro 4]]


:: Intro 4 {"position":"1200,200","size":"100,100"}
Anchors Aweigh
<!-- Anchors Aweigh -->
<script>
  // Stops the previous audio
  if (typeof audio !== 'undefined') {
    audio.pause();
    delete audio;
  }
  audioSource = "../assets/anchors-aweigh.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>

<script>
$playerSeenRadar = true;
</script>

<!-- The sensor game -->
Thermal Scan - Use A/D to rotate
LS: Light Second = 299,792,458 Meters

<!-- Not a game yet, just a circle with a line drawn from the center to the edge 
which continuously rotates around the center, like a radar, and which leaves a fading ghost
of the line behind it. -->
<canvas id="radar" width="800" height="800"></canvas>
<script>
  (function() {
    const canvas = document.getElementById("radar");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 2 - 10;
    
    // Customizable parameters
    const radarSpeed = 0.5; // degrees per frame
    const fadeRate = 0.1;   // fade opacity
    let contactBearing = Math.PI/2; // Keeps track of the contact blip bearing
    const contactSize = 5; // size of contact blip
    let contactRadius = radius * 0.15; // Keeps track of the distance from the center of the contact blip
    
    // Real contact position (moves independently of the blip)
    let realContactBearing = contactBearing;
    let realContactRadius = contactRadius;
    
    // Contact movement parameters
    const contactMovementSpeed = 0.02;
    const contactDirectionChangeFrequency = 0.005;
    let contactMovementDirection = Math.random() * Math.PI * 2;
    
    // Thermal scan parameters
    const thermalScanWidth = Math.PI/6; // 30 degrees in radians
    const thermalScanRadius = radius * 0.25; // 0.25ls circle
    const thermalScanSpeed = 0.5; // degrees per frame
    let thermalScanCenter = 0; // Center of thermal scan area
    let thermalScanReversed = false; // Direction of thermal scan rotation
    
    // Radar line angle
    let angle = 0;
    // Thermal scan angle
    let thermalScanAngle = 0;
    let contactVisible = false;
    let contactOpacity = 0;
  
    // Fill the canvas with black initially
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, width, height);
    
    // Key event listeners for thermal scan control
    document.addEventListener('keydown', function(event) {
      if (event.key === 'a' || event.key === 'A') {
        // Rotate thermal scan left
        thermalScanCenter -= 0.1;
        if (thermalScanCenter < 0) thermalScanCenter += Math.PI * 2;
      } else if (event.key === 'd' || event.key === 'D') {
        // Rotate thermal scan right
        thermalScanCenter += 0.1;
        if (thermalScanCenter >= Math.PI * 2) thermalScanCenter -= Math.PI * 2;
      }
    });
    
    function drawBackground() {
      // Draw fading overlay
      ctx.fillStyle = `rgba(0, 0, 0, ${fadeRate})`;
      ctx.fillRect(0, 0, width, height);
      
      // Draw radar circle
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.strokeStyle = "#00AA00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw grid lines
      drawGrid();
    }
    
    function drawGrid() {
      // Draw crosshairs
      ctx.beginPath();
      ctx.moveTo(centerX - radius, centerY);
      ctx.lineTo(centerX + radius, centerY);
      ctx.moveTo(centerX, centerY - radius);
      ctx.lineTo(centerX, centerY + radius);
      ctx.strokeStyle = "#004400";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw concentric circles with range readouts
      const rangeLabels = ["0.25ls", "0.5ls", "0.75ls", "1ls"];
      
      for (let i = 1; i <= 4; i++) {
        const circleRadius = radius * i/4;
        // Draw the circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = "#004400";
        ctx.stroke();
        
        // Draw the range readout at the top of each circle
        ctx.fillStyle = "#00FF00";
        ctx.font = "12px monospace";
        ctx.textAlign = "center";
        ctx.fillText(rangeLabels[i-1], centerX, centerY - circleRadius);
      }
    }
    
    function drawRadarLine() {
      // Calculate the endpoint of the rotating line
      const endX = centerX + radius * Math.cos(angle);
      const endY = centerY + radius * Math.sin(angle);
  
      // Draw the rotating line
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw radar sweep (the glow effect)
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0, 
        centerX, centerY, radius
      );
      gradient.addColorStop(0, "rgba(0, 255, 0, 0.2)");
      gradient.addColorStop(1, "rgba(0, 255, 0, 0)");
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, angle - 0.2, angle, false);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
    
    function drawThermalScan() {
      // Draw the thermal scan zone
      const startAngle = thermalScanCenter - thermalScanWidth/2;
      const endAngle = thermalScanCenter + thermalScanWidth/2;
      
      // Draw the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, thermalScanRadius, startAngle, endAngle);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = "rgba(255, 0, 0, 0.2)";
      ctx.fill();
      
      // Draw the thermal scan boundary lines
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(startAngle), 
                 centerY + thermalScanRadius * Math.sin(startAngle));
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(endAngle), 
                 centerY + thermalScanRadius * Math.sin(endAngle));
      ctx.strokeStyle = "#FF0000";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw a line sweeping across the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(thermalScanAngle + thermalScanCenter), 
                 centerY + thermalScanRadius * Math.sin(thermalScanAngle + thermalScanCenter));
      ctx.strokeStyle = "#FF0000";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    function updateContactPosition() {
      // Randomly change direction occasionally
      if (Math.random() < contactDirectionChangeFrequency) {
        contactMovementDirection += (Math.random() - 0.5) * Math.PI / 2; // Change by up to Â±45 degrees
      }
      
      // Convert polar movement to cartesian
      let dx = Math.cos(contactMovementDirection) * contactMovementSpeed;
      let dy = Math.sin(contactMovementDirection) * contactMovementSpeed;
      
      // Convert contact position from polar to cartesian
      let contactX = Math.cos(realContactBearing) * realContactRadius;
      let contactY = Math.sin(realContactBearing) * realContactRadius;
      
      // Update position
      contactX += dx;
      contactY += dy;
      
      // Convert back to polar coordinates
      realContactRadius = Math.sqrt(contactX * contactX + contactY * contactY);
      realContactBearing = Math.atan2(contactY, contactX);
      
      // Keep contact within radar bounds
      if (realContactRadius > radius * 0.95) {
        // If near edge, bounce back
        contactMovementDirection = Math.atan2(-contactY, -contactX);
        realContactRadius = radius * 0.95;
      } else if (realContactRadius < radius * 0.1) {
        // If near center, move outward
        contactMovementDirection = Math.atan2(contactY, contactX);
        realContactRadius = radius * 0.1;
      }
    }
    
    function checkContactDetection() {
      // Check if radar is sweeping over the contact
      const angleDiff = Math.abs(normalizeAngle(angle - realContactBearing));
      
      if (angleDiff < 0.1) {
        contactVisible = true;
        contactOpacity = 1.0;
        // Update the displayed contact position to the real position
        contactBearing = realContactBearing;
        contactRadius = realContactRadius;
      }
      
      // Check if thermal scan is over the contact
      const thermalScanAbsoluteAngle = thermalScanAngle + thermalScanCenter;
      const thermalDiff = Math.abs(normalizeAngle(thermalScanAbsoluteAngle - realContactBearing));
      
      if (thermalDiff < 0.1 && realContactRadius < thermalScanRadius) {
        contactVisible = true;
        contactOpacity = 1.0;
        // Update the displayed contact position to the real position
        contactBearing = realContactBearing;
        contactRadius = realContactRadius;
      }
    }
    
    function drawContact() {
      if (contactVisible) {
        // Draw the contact at the last detected position
        const contactX = centerX + contactRadius * Math.cos(contactBearing);
        const contactY = centerY + contactRadius * Math.sin(contactBearing);
        
        ctx.beginPath();
        ctx.arc(contactX, contactY, contactSize, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 0, 0, ${contactOpacity})`;
        ctx.fill();
        
        // Fade out the contact
        contactOpacity -= 0.01;
        if (contactOpacity <= 0) {
          contactVisible = false;
        }
      }
    }
    
    function normalizeAngle(a) {
      // Normalize angle to be between -pi and pi
      return a - Math.PI * 2 * Math.floor((a + Math.PI) / (Math.PI * 2));
    }
    
    function animate() {
      drawBackground();
      
      // Update the real contact position
      updateContactPosition();
      
      // Check if contact is detected by radar or thermal scan
      checkContactDetection();
      
      drawContact();
      drawRadarLine();
      drawThermalScan();
      
      // Update the angle (rotate by specified degrees per frame)
      angle += Math.PI * radarSpeed / 180;
      if (angle >= Math.PI * 2) angle = 0;

      // Update the thermal scan angle
      if (thermalScanReversed) {
        thermalScanAngle -= Math.PI * thermalScanSpeed / 180;
        if (thermalScanAngle <= -thermalScanWidth/2) {
          thermalScanAngle = -thermalScanWidth/2;
          thermalScanReversed = false;
        }
      } else {
        thermalScanAngle += Math.PI * thermalScanSpeed / 180;
        if (thermalScanAngle >= thermalScanWidth/2) {
          thermalScanAngle = thermalScanWidth/2;
          thermalScanReversed = true;
        }
      }
      
      requestAnimationFrame(animate);
    }
    
    animate();
  })();
</script>
[[Back->Intro 3]]


:: StoryStylesheet [stylesheet]
img {
  display: block;
  margin-left: auto;
  margin-right: auto;
  width: 800px;
}