:: StoryTitle
All Eyes on Tartarus


:: StoryData
{
  "ifid": "603cb76a-579d-4d57-bff2-50fc09301310",
  "format": "Harlowe",
  "format-version": "3.3.9",
  "start": "Intro 1",
  "zoom": 1
}


:: Intro 1 {"position":"600,200","size":"100,100"}
All Eyes on Tartarus
To mute audio, right click the tab in the browser and select "Mute Tab".
(set: $playerWon to false)
(set: $playerWonO1 to false)
(set: $playerWonO2 to false)
(set: $playerWonO3 to false)
(set: $playerWonO4 to false)
(set: $playerWonO5 to false)
(set: $tutorialOperationAllowed to false)
(set: $operation1Allowed to false)
(set: $operation2Allowed to false)
(set: $operation3Allowed to false)
(set: $operation4Allowed to false)
(set: $operation5Allowed to false)
(set: $operationDebugAllowed to false)
<!-- Allow audio button  (unmute all audio) -->
<button id="playAudioButton">Allow Audio</button>
<script>
  // So far we only need to umute:
  // id="submarine-song"
  document.getElementById("playAudioButton").addEventListener("click", function() {
    audioMuted = false;
  }); 
</script>

[[Continue->Intro 2]]


:: Intro 2 {"position":"800,200","size":"100,100"}
The Silent Service
<!-- Take Her Down! (The Submarine Song) -->
<script>
  // If audio is already defined, we should stop it before starting a new one
  if (typeof audio !== 'undefined') {
    audio.pause();
    // And probably remove it from the memory
    delete audio;
  }
  audioSource = "../assets/take-her-down-submariners.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  // audio.muted = audioMuted;
  // If audioMuted is not defined, this will break the script
  // So we need to check and prevent this from happening
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>
[[Continue->Intro 3]]


:: Intro 3 {"position":"1000,200","size":"100,100"}
Construimus, Batuimus
<!-- The Seabees Song -->
<script>
  // Stops the previous audio
  if (typeof audio !== 'undefined') {
    audio.pause();
    delete audio;
  }
  audioSource = "../assets/song-of-the-seabees.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>
<!-- Dialogue with alternating character portraits -->
<div class="dialogue-container">
  <!-- Character 1 speaks -->
  <div class="dialogue left-dialogue">
    <img src="../assets/characters/Admiral.png" class="portrait" alt="Character 1">
    <p class="dialogue-text">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam euismod velit nec libero rutrum, non venenatis dolor fringilla. Phasellus id metus at lectus cursus tincidunt.</p>
  </div>
  
  <!-- Character 2 speaks -->
  <div class="dialogue right-dialogue">
    <img src="../assets/characters/Captain.png" class="portrait" alt="Character 2">
    <p class="dialogue-text">Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis.</p>
  </div>
  
  <!-- Character 1 speaks again -->
  <div class="dialogue left-dialogue">
    <img src="../assets/characters/Engineer.png" class="portrait" alt="Character 1">
    <p class="dialogue-text">Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt.</p>
  </div>
  
  <!-- Character 2 speaks again -->
  <div class="dialogue right-dialogue">
    <img src="../assets/characters/Pirate.png" class="portrait" alt="Character 2">
    <p class="dialogue-text">At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium voluptatum deleniti atque corrupti quos dolores et quas molestias excepturi.</p>
  </div>
</div>
(set: $operation1Allowed to false)
(set: $operation2Allowed to false)
(set: $operation3Allowed to false)
(set: $operation4Allowed to false)
(set: $operation5Allowed to false)
(set: $tutorialOperationAllowed to false)
(set: $operationDebugAllowed to false)

[[Tutorial->Tutorial Operation]]
[[Continue->Operation 1]]
[[Debug Operation->Debug Operation]]

:: Tutorial Operation {"position":"1000,400","size":"100,100"}
Tutorial.

Controls:
F11 for fullscreen
Thermal Scan - Use A/D to rotate
Contact Report - Left click to fire at, X to Dismiss, Q to fire a spread at
Pause - P to toggle pause
Message history - H to pause and view message history

<!-- Removal of padding allows for much more game room on small monitors -->
<style>
tw-story {
  padding: 0% 0%;
  padding-top: 0%;
  padding-right: 0%;
  padding-bottom: 0%;
  padding-left: 0%;
}

@media (min-width: 576px) {
  tw-story {
    padding: 0% 0%;
    padding-top: 0%;
    padding-right: 0%;
    padding-bottom: 0%;
    padding-left: 0%;
  }
}
</style>

<canvas id="tutorialOperation" width="1350" height="750"></canvas>
<script>
    // Mark the tutorial operation as being usable
    $tutorialOperationAllowed = true;
    // Stops the previous audio
    if (typeof audio !== 'undefined') {
      audio.pause();
      // And probably remove it from the memory
      delete audio;
    }
  (function() {
    const canvas = document.getElementById("tutorialOperation");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 3;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 2 - 10;

    // Array of elint beep audios. Rather than create and play a new beep each time there is a detection,
    // we will instead reuse numBeeps number of beeps. This is to prevent the audio from overlapping and
    // creating a cacophony of beeps that can overload the number of audio channels available in the browser.
    const numBeeps = 20;
    const elintBeeps = Array.from({ length: numBeeps }, () => new Audio("../assets/ELINTBeep.mp3"));
    
    // Track the start time
    const startTime = Date.now();
    let lastFrameTime = performance.now();
    // Track the unpaused elapsed time
    let unpausedElapsedTimeMillis = 0;
    // Time multiplier
    // 1 = normal speed
    // 2 = double speed
    // 0.5 = half speed
    const deltaTimeMultiplier = 2.4;
    // Detection chance time multiplier
    // Intended to address the fact that PC performance can affect detection chances
    const detectionTimeMultiplier = 1;

    // Game state variables
    let gameOver = false;
    let gamePaused = true;
    let gameOverMessage = "";
    let gameOverColor = "";

    // If the game is paused, go ahead and draw the pause screen
    if (gamePaused) {
      requestAnimationFrame(drawPauseMenu);
    }

    // Customizable parameters - now in units per second instead of per frame
    const radarSpeed = 30; // degrees per second
    const fadeRate = 6;   // fade opacity per second
    const ELINTHalfAngle = Math.PI/36; // 5 degrees in radians
    
    // Radar line angle
    let angle = 0;
    // Thermal scan angle
    let thermalScanAngle = 0;
    
    // Thermal scan parameters
    const thermalScanWidth = Math.PI/6; // 30 degrees in radians
    const thermalScanRadius = radius * 0.25; // 0.25ls circle
    const thermalScanSpeed = 30; // degrees per second
    let thermalScanCenter = 0; // Center of thermal scan area
    let thermalScanReversed = false; // Direction of thermal scan rotation

    // Missile thermal scan parameters
    const missileScanWidth = Math.PI/6; // 30 degrees in radians
    const missileScanRadius = radius * 0.05; // 0.05ls circle
    const missileScanSpeed = 60; // degrees per second

    // Random missile launch parameters
    const baseMissileLaunchChance = 0;
    let missileLaunchChance = baseMissileLaunchChance;
    let missileLaunchIncrease = 0;
    // Missile attack type parameters
    const chanceOfSpreadAttack = 0.0;
    const spreadAttackMissilePerRadiusAmount = 0.05; // Add 1 more missile for every radius amount of distance to target
    let allowedToFireAtSpot = false; // If true, the player can fire at any point on the screen, not just contacts. If false, they can't.
    let allowedToFire = false; // If true, the player can cause a missile to be launched. If false, all controls related to firing are disabled. 
    // Tartarus missile parameters
    const tartarusMissileFuelTime = 120; // Lifetime of Tartarus missiles in seconds. Default 120
    const tartarusMissileArmingTime = 1.0; // Time it takes for Tartarus missiles to arm in seconds. Default 1.0
    const tartarusMissileSpeed = 12; // Speed of Tartarus missiles in ls/s. Default 12

    // Contact report parameters
    let contactReports = [];
    const reportLifetime = 10; // lifetime in seconds

    // IFF Parameters
    const iffBoxDisplayDistance = 100; // How far away the mouse can be before the IFF box stops displaying
    const acceptedTypes = ["FRIENDLY", "HOSTILE", "NEUTRAL", "GHOST", "PLAYER"]; // Accepted contact types

    // Tutorial mission variables
    let tutorialStage = 0;
    let disableRadar = true;
    let disableThermal = true;
    let tutorialContactId = null;
    let tutorialMissileInterval = null;
    let infiniteMissiles = false;
    const tutorialActions = {
      reportedFirstRadarContact: false,
      reportedRealRadarContact: false,  
      reportedStealthContact: false,
      reportedMissile: false,
      shotDownMissile: false,
      destroyedFinalTarget: false
    };

    // Dialogue message parameters
    const dialogueMessages = []; // Array to store dialogue messages with text, color, and time they should disappear
    const defaultDialogueTime = 12; // Default time for dialogue messages to disappear
    // Dialogue flags
    let isFirstContact = true;
    let isFirstMissile = true;
    let shotDownFirstMissile = false;
    let firedFirstSpread = false;
    let firedSpreadAtMissile = false;
    let firedSpreadAtInvalidTarget = false;
    // Dialogue message colors for certain characters
    const engineerColor = "#00FF00";
    const captainColor = "#34eb7a";
    const helmsmanColor = "#9ceb34";
    const friendlyColor = "#FF00FF"
    const aiColor = "#c0ffbd"
    const unidentifiedColor = "#FFFFFF"
    const pirateColor = "#FF0000"
    // Dialogue portrait paths
    const captainPortraitFilePath = "../assets/characters/CaptainPortrait.png";

    // Function to create explosion effect
    function createExplosion(x, y) {
      // Play explosion sound (Unused for now)
      // const explosionSound = new Audio("../assets/MissileHit.mp3");
      // explosionSound.play();

      // Visual explosion effect (flash)
      ctx.beginPath();
      ctx.arc(x, y, 30, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255, 200, 50, 0.8)";
      ctx.fill();
    }

    // Function to check if all contacts of a specific type are gone
    function areAllContactsGone(type) {
      return !contacts.some(contact => contact.contactType === type && !contact.destroyed);
    }

    // Contact Report class
    class ContactReport {
      constructor(x, y, timestamp, contactType, contact) {
        this.x = x;
        this.y = y;
        this.timestamp = timestamp;
        this.contactType = contactType;
        this.contact = contact;
        this.timeCreated = Date.now();
        this.age = 0;
        this.maxAge = reportLifetime;
      }
      
      update(deltaTime) {
        // Increment age, but only if the contact is no longer visible or no longer exists
        if (!this.contact || !this.contact.visible || this.contact.destroyed || typeof this.contact === 'undefined') {
          this.age += deltaTime;
        }
        return this.age < this.maxAge;
      }
      
      draw() {
        // Calculate opacity based on age
        const opacity = 1 - (this.age / this.maxAge);
        
        // Determine position (ensure it's on screen)
        const boxWidth = 180;
        const boxHeight = 75; // Increased height to fit new line
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        // Draw connection line
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(boxX + (boxX > this.x ? 0 : boxWidth), boxY + boxHeight/2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw box
        ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.7})`;
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Draw text
        ctx.font = "10px monospace";
        ctx.fillStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.textAlign = "left";
        ctx.fillText(`DETECTED: ${this.timestamp}`, boxX + 5, boxY + 15);
        ctx.fillText(`POTENTIAL ${this.contactType} CONTACT`, boxX + 5, boxY + 30);
        ctx.fillText("CLICK TO REPORT CONTACT", boxX + 5, boxY + 45);
        ctx.fillText("X TO DISMISS, Q TO FIRE SPREAD", boxX + 5, boxY + 60);
      }
      
      contains(mouseX, mouseY) {
        // Determine box position
        const boxWidth = 180;
        const boxHeight = 75; // TODO: Make boxWidth and boxHeight not exist both here and in draw() separately in order to make it easier to change
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        return mouseX >= boxX && mouseX <= boxX + boxWidth && 
               mouseY >= boxY && mouseY <= boxY + boxHeight;
      }
    }

    // Contact class definition
    class Contact {
      constructor(bearing, distance, size, movementSpeed, directionChangeFrequency, movementDirection, 
                  visible, opacity, emittingRadiation, emissionDetectionChance, 
                  radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
                  iffBroadcasting, iffString, contactColor, contactType, numMissilesLoaded) {
        // Affects displayed position
        this.bearing = bearing;
        this.distance = distance;
        this.size = size;
        
        // Affects real position for sim (moves independently of the displayed blip)
        this.realBearing = bearing;
        this.realDistance = distance;
        
        // Movement parameters for sim (now per second rather than per frame)
        this.movementSpeed = movementSpeed;
        this.directionChangeFrequency = directionChangeFrequency;
        this.movementDirection = movementDirection;
        this.directionChangeCounter = 0;
        
        // Visibility properties for contact blip
        this.visible = visible;
        this.opacity = opacity;
        this.fadeSpeed = 0.6; // fade per second

        // ELINT detection properties
        this.emittingRadiation = emittingRadiation;
        this.emissionDetectionChance = emissionDetectionChance;
        this.radiationDetected = false;
        this.radiationDetectionDuration = 0;
        
        // Radar detection properties
        this.radarDetectable = radarDetectable;
        this.radarDetectionChance = radarDetectionChance;
        this.lastDetectedTime = null;

        // Thermal detection properties
        this.thermalDetectable = thermalDetectable;
        this.thermalDetectionChance = thermalDetectionChance;

        // IFF (Identification Friend or Foe) properties
        this.iffBroadcasting = iffBroadcasting;
        this.iffString = iffString;
        this.contactColor = contactColor;

        // How many missiles are aboard the ship
        this.numMissiles = numMissilesLoaded;

        // Currently, there are five types of contacts: "FRIENDLY", "HOSTILE", "NEUTRAL", "GHOST", and "PLAYER"
        // Anything else is treated as "GHOST"
        if (acceptedTypes.includes(contactType)) {
          this.contactType = contactType;
        } else {
          this.contactType = "GHOST";
        }
        // Ghosts must not be thermally detectable
        if (this.contactType === "GHOST") {
          this.thermalDetectable = false;
        }
      }
      
      updatePosition(deltaTime) {
        // Randomly change direction occasionally, now based on elapsed time
        this.directionChangeCounter += deltaTime;
        if (this.directionChangeCounter > (1 / this.directionChangeFrequency)) {
          this.movementDirection += (Math.random() - 0.5) * Math.PI / 2; // Change by up to +/-45 degrees
          this.directionChangeCounter = 0;
        }
        
        // Convert polar movement to cartesian
        let dx = Math.cos(this.movementDirection) * this.movementSpeed * deltaTime;
        let dy = Math.sin(this.movementDirection) * this.movementSpeed * deltaTime;
        
        // Convert contact position from polar to cartesian
        let contactX = Math.cos(this.realBearing) * this.realDistance;
        let contactY = Math.sin(this.realBearing) * this.realDistance;
        
        // Update position
        contactX += dx;
        contactY += dy;
        
        // Convert back to polar coordinates
        this.realDistance = Math.sqrt(contactX * contactX + contactY * contactY);
        this.realBearing = Math.atan2(contactY, contactX);
        
        // Keep contact within radar bounds
        if (this.realDistance > radius * 0.95) {
          // If near edge, bounce back, unless a missile, in which case it should self-destruct
          if (this.isMissile) {
            // Create explosion effect
            createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                           centerY + this.realDistance * Math.sin(this.realBearing));
            
            // Remove from contacts array
            const index = contacts.indexOf(this);
            if (index > -1) {
              contacts.splice(index, 1);
            }
            return;
          }
          this.movementDirection = Math.atan2(-contactY, -contactX);
          this.realDistance = radius * 0.95;
        } else if (this.realDistance < 0) {
          // If somehow at a negative distance, reset to 0
          this.realDistance = 0;
        }
        
        // Check for radiation detection
        this.checkRadiationDetection(deltaTime);
        
        // Decrease radiation detection duration
        if (this.radiationDetected) {
          this.radiationDetectionDuration -= deltaTime;
          if (this.radiationDetectionDuration <= 0) {
            this.radiationDetected = false;
          }
        }
      }
      
      checkRadiationDetection(deltaTime) {
        // Adjust chance based on time
        const timeAdjustedChance = this.emissionDetectionChance * deltaTime * detectionTimeMultiplier;
        
        if (this.emittingRadiation && Math.random() < timeAdjustedChance) {
          // Play a beep
          // Iterate through beeps to find one that is not currently playing
          for (let i = 0; i < numBeeps; i++) {
            if (elintBeeps[i].paused) {
              elintBeeps[i].play();
              break;
            }
          }

          this.radiationDetected = true;
          this.radiationDetectionDuration = 0.25; // Show for 0.25 second
        }
      }
      
      checkDetection(radarAngle, thermalScanAbsoluteAngle, thermalScanRadius, deltaTime) {
        // Check if radar is sweeping over the contact
        const angleDiff = Math.abs(normalizeAngle(radarAngle - this.realBearing));
        let wasNewDetection = false;
        
        // Adjust chances based on time
        // If something has a 100% chance of being detected, it should be detected
        const timeAdjustedRadarChance = this.radarDetectionChance >= 1 ? 1 : this.radarDetectionChance * deltaTime * detectionTimeMultiplier;
        //const timeAdjustedThermalChance = this.thermalDetectionChance * deltaTime * detectionTimeMultiplier;
        const timeAdjustedThermalChance = this.thermalDetectionChance > 0 ? 1 : 0; // If something is thermal detectable, it should be detected
        
        if (angleDiff < 0.1 && this.radarDetectable && Math.random() < timeAdjustedRadarChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            // Play a ping
            const audio = new Audio("../assets/RadarPing.mp3");
            audio.play();
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const minutes = Math.floor(unpausedElapsedTimeMillis / 60000);
            const seconds = Math.floor((unpausedElapsedTimeMillis % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "RADAR", this));
          }
        }
        
        // Check if thermal scan is over the contact
        const thermalDiff = Math.abs(normalizeAngle(thermalScanAbsoluteAngle - this.realBearing));
        
        if (thermalDiff < 0.1 && this.realDistance < thermalScanRadius && 
            this.thermalDetectable && Math.random() < timeAdjustedThermalChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const minutes = Math.floor(unpausedElapsedTimeMillis / 60000);
            const seconds = Math.floor((unpausedElapsedTimeMillis % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "THERMAL", this));
          }
        }
      }

      // Launch a missile along a given bearing
      launchMissileAlongAngle(targetBearing, missileFuelTime, missileArmingTime, missileMovementSpeed) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          // General idea: Create a unit circle around this contact, then create a contact at the 
          // corresponding point on the circle with the matching bearing.

          // Figure out the polar coordinates of a point on the unit circle with angle targetBearing
          const targetX = Math.cos(targetBearing);
          const targetY = Math.sin(targetBearing);

          // Center the unit circle around the launcher's position
          const missileX = Math.cos(this.realBearing) * this.realDistance;
          const missileY = Math.sin(this.realBearing) * this.realDistance;

          // Figure out the actual position in the game world that the missile is being launched towards
          const trueTargetX = missileX + targetX;
          const trueTargetY = missileY + targetY;

          // Convert back to polar coordinates
          const targetContactBearing = Math.atan2(trueTargetY, trueTargetX);
          const targetContactDistance = Math.sqrt(trueTargetX * trueTargetX + trueTargetY * trueTargetY);

          // Create a new contact that just gives a bearing and unit distance
          // to tell the missile what direction to aim in
          // If this is not done, then missiles launched will not know
          // which direction to go in. They will only know where to spawn.
          let targetContact = new Contact(targetContactBearing, targetContactDistance);

          // Set the missile's contact type to match whoever launched it, unless the contact is a player
          // Set it to friendly in that latter case
          let contactType = this.contactType;
          if (this.contactType === "PLAYER") {
            contactType = "FRIENDLY";
          }
          const missile = new MissileContact(this.realBearing, this.realDistance, targetContact, missileFuelTime, contactType, missileArmingTime, missileMovementSpeed);
          contacts.push(missile);

          // Reduce the number of missiles available if applicable
          if (this.numMissiles !== undefined && this.numMissiles !== null) {
            this.numMissiles--;
          }
        } 
      }

      // Launch a missile at the given position (Requires target contact just to tell the missile who it's initially targeting)
      launchMissileAtPoint(targetX, targetY, missileFuelTime, missileArmingTime, missileMovementSpeed) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          
          // Figure out the angle of the line which points from this contact to the target
          // Convert contact position from polar to Cartesian
          const contactX = Math.cos(this.realBearing) * this.realDistance;
          const contactY = Math.sin(this.realBearing) * this.realDistance;

          // Calculate angle from contact to target
          const targetAngle = Math.atan2(targetY - contactY, targetX - contactX);

          // Delegate to launchMissileAlongAngle with the target angle
          this.launchMissileAlongAngle(targetAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
        }
      }

      // Launch a missile at the given contact
      launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed, isSpreadAttack) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          // Basic idea: We have four parametric equations, two for the target's position as a function
          // of time, and two for the missile's position as a function of time. 
          // The missile position in x is given by
          //
          // missileX(t) = t * missileVelocityX + missileX(0)    <-- missileX(0) is the initial x position of the missile, so in this case, the launcher's x position
          //
          // The missile position in y is given by
          //
          // missileY(t) = t * missileVelocityY + missileY(0)  <-- missileY(0) is the initial y position of the missile, so in this case, the launcher's y position
          //
          // The target position in x is given by
          //
          // targetX(t) = t * targetVelocityX + targetX(0)  <-- targetX(0) is the initial x position of the target contact, so in this case, its current x position
          //
          // The target position in y is given by
          //
          // targetY(t) = t * targetVelocityY + targetY(0)  <-- targetY(0) is the initial y position of the target contact, so in this case, its current y position
          //
          // We want all four quantities to equal, so we arrive at a system of two equations:
          //
          // missileX(t) = targetX(t) && missileY(t) = targetY(t)
          //
          // We actually have two unknowns. Time is of course one of them, but the other is the angle at which we must launch the missile to collide with the target.
          // It is this quantity we are interested in. We know that launch angle is actually a part of the missile's velocity vector, so we can write
          //
          // missileVelocityX = missileSpeed * cos(missileLaunchAngle) && missileVelocityY = missileSpeed * sin(missileLaunchAngle)
          //
          // We then substitute these into the system of equations, and solve for time and missileLaunchAngle. 
          // It is somewhat challenging to solve this, but by using a symbolic algebra system like the one used by Wolfram Mathematica, we get that there
          // are actually two solutions for both time and angle. We will look at both solutions and chooose which, if any, is the correct one to use.
          // For instance, if angle or time are undefined or infinite, we know that something is wrong with that solution, likely because none is possible.
          // This could happen in a case where we're shooting at something going away faster than we can catch up to it, for instance.
          // Moreover, if time is negative, then our window of opportunity has already passed, and we should not launch the missile using the given solution.
          // Those interested in the derivation of this equation for themselves should be familiar with solutions of equations of the form 
          //
          // sin(x) + b cos(x) = c for real valued constants b and c

          // Time, angle equations 1.
          // These symbols correspond to these quantities:
          // evx - Enemy velocity x
          // evy - Enemy velocity y
          // mxi - Missile initial x position
          // myi - Missile initial y position
          // exi - Enemy initial x position
          // eyi - Enemy initial y position
          // mspeed - Missile speed
          // t - Time
          // a - Angle

          // In Mathematica code, solution pair 1 is given by
          // t=1/(evx^2+evy^2-mspeed^2) (-evx  exi-evy  eyi+evx  mxi+evy  myi-1/2  \[Sqrt](4  (evx (exi-mxi)+evy (eyi-myi))^2-4  (evx^2+evy^2-mspeed^2)  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))
          // a=ArcTan[(-evy  (exi-mxi)  (eyi-myi)+evx  (eyi-myi)^2+(exi-mxi)  \[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)),(evy  (exi-mxi+(eyi-myi)  (-evx  exi+evx  mxi+\[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))]
          
          // In Mathematica code, solution pair 2 is given by
          // t=1/(evx^2+evy^2-mspeed^2) (-evx  exi-evy  eyi+evx  mxi+evy  myi+1/2  \[Sqrt](4  (evx (exi-mxi)+evy (eyi-myi))^2-4  (evx^2+evy^2-mspeed^2)  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))
          // a=ArcTan[(-evy  (exi-mxi)  (eyi-myi)+evx  (eyi-myi)^2+(-exi+mxi)  \[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)),(evy  (exi-mxi)^2-(eyi-myi)  (evx  exi-evx  mxi+\[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))]

          // Convert both contacts' polar coordinates to Cartesian
          // For the missile launcher (this contact)
          const mxi = Math.cos(this.realBearing) * this.realDistance; // Missile initial x
          const myi = Math.sin(this.realBearing) * this.realDistance; // Missile initial y
          
          // For the target
          const exi = Math.cos(targetContact.realBearing) * targetContact.realDistance; // Enemy initial x
          const eyi = Math.sin(targetContact.realBearing) * targetContact.realDistance; // Enemy initial y
          
          // Calculate enemy velocity components
          const evx = Math.cos(targetContact.movementDirection) * targetContact.movementSpeed; // Enemy velocity x
          const evy = Math.sin(targetContact.movementDirection) * targetContact.movementSpeed; // Enemy velocity y
          
          // Missile speed
          const mspeed = missileMovementSpeed;
          
          // Calculate values needed for the formulas
          const dx = exi - mxi;
          const dy = eyi - myi;
          const distSquared = dx*dx + dy*dy;

          // We first check to see if we're firing at a ghost
          if (targetContact.contactType === "GHOST") {
            // If we're firing at a ghost, launch directly at ghost's last sighted position
            // Looks odd otherwise (Why is my missile going to this random position this game is buggy!!!)

            // Handle firing a spread as well
            if (isSpreadAttack) {
              // Check if the player ship is the launcher
              // and if firedFirstSpread is false
              // If so, write dialogue 
              if(this.contactType === "PLAYER" && !firedFirstSpread) {
                firedFirstSpread = true;
              }

              // Calculate distance in radius units
              const distance = Math.sqrt(distSquared);
               
              // Calculate number of missiles based on distance
              // Add 1 missile for every spreadAttackMissilePerRadiusAmount * radius
              let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
               
              // Set minimum and maximum number of missiles
              numMissiles = Math.max(2, numMissiles);
               
              // Calculate increased arming time (0.5 seconds per missile)
              const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);

              // Figure out angle between this contact and the target contact
              const selectedAngle = Math.atan2(dy, dx);
               
              // Launch a spread of missiles
              const spreadAngle = Math.PI / 6; // 30 degrees
              for (let i = 0; i < numMissiles; i++) {
                const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              }
               
              // Launch one more missile directly at the target
              this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              return;
            }

            this.launchMissileAtPoint(targetContact.distance * Math.cos(targetContact.bearing), targetContact.distance * Math.sin(targetContact.bearing), missileFuelTime, missileArmingTime, missileMovementSpeed);
            return;
          }
          
          // Check if player tried to fire spread at missile (moved up to check in all cases)
          if (this.contactType === "PLAYER" && targetContact.isMissile && isSpreadAttack) {
            if (!firedSpreadAtMissile) {
              addDialogue("Captain: Gunnery control, belay that order! That's a missile, don't waste a spread! Sensors, you should have known better!", captainColor, defaultDialogueTime, captainPortraitFilePath);
            }
            firedSpreadAtMissile = true;
            // Continue with normal single missile firing
            isSpreadAttack = false;
          }
          
          // Calculate the determinant inside the square root
          const determinant = 4 * Math.pow(evx*dx + evy*dy, 2) - 
                              4 * (evx*evx + evy*evy - mspeed*mspeed) * distSquared;
          
          // Only proceed if the determinant is positive (solutions exist)
          if (determinant >= 0) {
            // Calculate solutions for time
            const t1 = 1/(evx*evx + evy*evy - mspeed*mspeed) * 
                     (-evx*exi - evy*eyi + evx*mxi + evy*myi - 0.5 * Math.sqrt(determinant));
            
            const t2 = 1/(evx*evx + evy*evy - mspeed*mspeed) * 
                     (-evx*exi - evy*eyi + evx*mxi + evy*myi + 0.5 * Math.sqrt(determinant));
            
            // Calculate the square root term for angle calculations
            const sqrtTerm = Math.sqrt(-evy*evy*dx*dx + 
                                       2*evx*evy*dx*dy - 
                                       evx*evx*dy*dy + 
                                       mspeed*mspeed*distSquared);
            
            // Calculate angles for both solutions
            const a1x = (-evy*dx*dy + evx*dy*dy + dx*sqrtTerm) / (mspeed*distSquared);
            const a1y = (evy*dx*dx + dy*(-evx*exi + evx*mxi + sqrtTerm)) / (mspeed*distSquared);
            const a1 = Math.atan2(a1y, a1x);
            
            const a2x = (-evy*dx*dy + evx*dy*dy - dx*sqrtTerm) / (mspeed*distSquared);
            const a2y = (evy*dx*dx - dy*(evx*exi - evx*mxi + sqrtTerm)) / (mspeed*distSquared);
            const a2 = Math.atan2(a2y, a2x);
            
            // Choose the best solution (positive time, earliest intercept)
            let selectedTime = null;
            let selectedAngle = null;
            
            if (t1 > 0 && (selectedTime === null || t1 < selectedTime)) {
              selectedTime = t1;
              selectedAngle = a1;
            }
            
            if (t2 > 0 && (selectedTime === null || t2 < selectedTime)) {
              selectedTime = t2;
              selectedAngle = a2;
            }

            // If selected time is greater than missile fuel time, reset selected time to null
            if (selectedTime > missileFuelTime) {
              selectedTime = null;
            } 

            // If we found a valid solution, launch the missile
            if (selectedTime !== null) {
              // this.launchMissileAlongAngle(selectedAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
              // If isSpreadAttack, instead fire a spread of missiles at the target and its immediate surroundings
              // Only do this if firing at a non-missile contact
              if (isSpreadAttack && !targetContact.isMissile) {
                // Check if the player ship is the launcher
                // and if firedFirstSpread is false
                // If so, write dialogue 
                if(this.contactType === "PLAYER" && !firedFirstSpread) {
                  firedFirstSpread = true;
                }

                // Calculate distance in radius units
                const distance = Math.sqrt(distSquared);
                
                // Calculate number of missiles based on distance
                // Add 1 missile for every spreadAttackMissilePerRadiusAmount * radius
                let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                
                // Set minimum and maximum number of missiles
                numMissiles = Math.max(2, numMissiles);
                
                // Calculate increased arming time (0.5 seconds per missile)
                const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                
                // Launch a spread of missiles
                const spreadAngle = Math.PI / 6; // 30 degrees
                for (let i = 0; i < numMissiles; i++) {
                  const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                  this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                }
                
                // Launch one more missile directly at the target
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              } else {
                
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
              }
            } else {
              // No valid solution found, launch directly at current position as fallback
              
              // NPC ships will never fire a spread at invalid targets
              if (isSpreadAttack && this.contactType !== "PLAYER") {
                // Just fire a single missile to conserve ammo
                this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
              } else {
                // For player, allow them to mess up and fire a spread if that's what they requested
                if (this.contactType === "PLAYER" && isSpreadAttack) {
                  // Calculate spread as in normal spread code
                  const distance = Math.sqrt(distSquared);
                  let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                  numMissiles = Math.max(2, numMissiles);
                  const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                  
                  // Direct angle toward target's current position
                  const selectedAngle = Math.atan2(dy, dx);
                  
                  // Launch spread
                  const spreadAngle = Math.PI / 6; // 30 degrees
                  for (let i = 0; i < numMissiles; i++) {
                    const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                    this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                  }
                  
                  // Launch direct missile too
                  this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                } else {
                  // Just fire a single missile for non-spread or non-player
                  this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
                }
              }
            }
          } else {
            // No intercept solution exists, launch directly at current position
            
            // NPC ships will never fire a spread at invalid targets
            if (isSpreadAttack && this.contactType !== "PLAYER") {
              // Just fire a single missile to conserve ammo
              this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
            } else {
              // For player, allow them to mess up and fire a spread if that's what they requested
              if (this.contactType === "PLAYER" && isSpreadAttack) {
                // Calculate spread as in normal spread code
                const distance = Math.sqrt(distSquared);
                let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                numMissiles = Math.max(2, numMissiles);
                const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                
                // Direct angle toward target's current position
                const selectedAngle = Math.atan2(dy, dx);
                
                // Launch spread
                const spreadAngle = Math.PI / 6; // 30 degrees
                for (let i = 0; i < numMissiles; i++) {
                  const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                  this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                }
                
                // Launch direct missile too
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              } else {
                // Just fire a single missile for non-spread or non-player
                this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
              }
            }
          }
        }
      }
      
      draw(deltaTime) {
        // If IFF is broadcasting, the contact should always be visible and updating its contact position
        if (this.iffBroadcasting) {
          this.visible = true;
          this.opacity = 1.0;
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
        }

        if (this.visible) {
          // Draw the contact at the last detected position
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          ctx.beginPath();
          ctx.arc(contactX, contactY, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${this.contactColor[0]}, ${this.contactColor[1]}, ${this.contactColor[2]}, ${this.opacity})`;
          ctx.fill();
          
          // Draw IFF bubble if broadcasting and mouse is nearby
          if (this.iffBroadcasting && typeof mouseX !== 'undefined' && typeof mouseY !== 'undefined') {
            // Calculate distance from mouse to contact
            const dx = mouseX - contactX;
            const dy = mouseY - contactY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate opacity based on distance (fully visible when close, fades out as distance increases)
            const iffOpacity = Math.max(0, 1 - (distance / iffBoxDisplayDistance));
            
            // Only draw if opacity > 0
            if (iffOpacity > 0) {
              // Draw IFF bubble
              const bubblePadding = 10;
              const lines = this.iffString.split('\n');
              const lineHeight = 16;
              const bubbleWidth = lines.reduce((max, line) => Math.max(max, ctx.measureText(line).width), 0) + (bubblePadding * 2);
              var bubbleHeight = ((lines.length + 1) * lineHeight) + (bubblePadding * 2); // Add 1 for the missile count line
              
              // Add extra height for missile count if it exists
              const hasMissiles = this.numMissiles !== undefined && this.numMissiles !== null;
              if (hasMissiles) {
                bubbleHeight += lineHeight;
              }
              
              // Calculate box position - default is to the right of the contact
              let boxX = contactX + 15;
              let boxY = contactY - 10;
              
              // Adjust if the box would go off the right edge of the canvas
              if (boxX + bubbleWidth > width) {
                boxX = contactX - bubbleWidth - 15; // Move to the left of the contact
              }
              
              // Adjust if the box would go off the top or bottom of the canvas
              if (boxY < 0) {
                boxY = 0; // Align with top of canvas
              } else if (boxY + bubbleHeight > height) {
                boxY = height - bubbleHeight; // Align with bottom of canvas
              }
              
              // Draw bubble background
              ctx.fillStyle = `rgba(0, 0, 0, ${iffOpacity * 0.7})`;
              ctx.fillRect(boxX, boxY, bubbleWidth, bubbleHeight);
              ctx.strokeStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.strokeRect(boxX, boxY, bubbleWidth, bubbleHeight);
              
              // Draw IFF string
              ctx.fillStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.font = "12px monospace";
              ctx.textAlign = "left";
              lines.forEach((line, i) => {
                ctx.fillText(line, boxX + bubblePadding, boxY + 15 + (i * lineHeight));
              });
              
              // Draw IFF status
              // ctx.fillStyle = `rgba(0, 255, 0, ${iffOpacity})`;
              // Frienly contacts have a green IFF broadcast, hostile contacts have a red IFF broadcast
              // Neutral contacts have a yellow IFF broadcast. Ghosts should not have an IFF broadcast but if they do, it should be white
              if (this.contactType === "FRIENDLY" || this.contactType === "PLAYER") {
                ctx.fillStyle = `rgba(0, 255, 0, ${iffOpacity})`;
              } else if (this.contactType === "HOSTILE") {
                ctx.fillStyle = `rgba(255, 0, 0, ${iffOpacity})`;
              } else if (this.contactType === "NEUTRAL") {
                ctx.fillStyle = `rgba(255, 255, 0, ${iffOpacity})`;
              } else {
                ctx.fillStyle = `rgba(255, 255, 255, ${iffOpacity})`;
              }
              ctx.fillText("IFF: BROADCASTING", boxX + bubblePadding, boxY + 15 + (lines.length * lineHeight));
              
              // Show missile count if available
              if (hasMissiles) {
                ctx.fillText(`MISSILES: ${this.numMissiles}`, boxX + bubblePadding, boxY + 15 + ((lines.length + 1) * lineHeight));
              }
            }
          }
          
          // Fade out the contact - now based on time
          this.opacity -= this.fadeSpeed * deltaTime;
          if (this.opacity <= 0) {
            this.visible = false;
          }
        }
        
        // Draw ELINT radiation cone if detected
        if (this.radiationDetected) {
          const startAngle = this.realBearing - ELINTHalfAngle;
          const endAngle = this.realBearing + ELINTHalfAngle;
          
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, startAngle, endAngle);
          ctx.lineTo(centerX, centerY);
          ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
          ctx.fill();
          
          // Draw the ELINT cone boundary lines
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(startAngle), 
            centerY + radius * Math.sin(startAngle)
          );
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(endAngle), 
            centerY + radius * Math.sin(endAngle)
          );
          ctx.strokeStyle = "#FFFF00";
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
    }

    // Extend Contacts to add heat seeking missiles
    class MissileContact extends Contact {
      constructor(bearing, distance, targetContact, fuelTime, contactType, armingTime, movementSpeed = 10) {
        // If the contact type is not one of the accepted types, default to "HOSTILE"
        if (!acceptedTypes.includes(contactType)) {
          contactType = "HOSTILE";
        }
        // Figure out the movement direction based on the target contact and the current bearing and distance
        // We are at (bearing, distance) and the target is at (targetContact.bearing, targetContact.distance), in polar coordinates
        // We want to move towards the target, so we need to calculate the angle between the two points
        // This is done by calculating the angle between the two points in cartesian coordinates and then converting it to polar coordinates
        // Figure out our position in cartesian coordinates
        const missileX = Math.cos(bearing) * distance;
        const missileY = Math.sin(bearing) * distance;
        // Figure out the target position in cartesian coordinates
        // so long as the target contact is not null or undefined or something like that
        if (targetContact) {
          var targetXv = Math.cos(targetContact.bearing) * targetContact.distance;
          var targetYv = Math.sin(targetContact.bearing) * targetContact.distance;
        } else {
          // If the target contact is null or undefined, default to the point at the radius and bearing
          var targetXv = Math.cos(bearing) * radius;
          var targetYv = Math.sin(bearing) * radius;
        }
        const targetX = targetXv;
        const targetY = targetYv;
        // Calculate the angle to the target
        const targetAngle = Math.atan2(targetY - missileY, targetX - missileX);

        // If the contact is friendly, create it like so
        if (contactType === "FRIENDLY") {
          // Create a friendly missile
          super(
            bearing, distance, 3, // bearing, starting distance, size
            movementSpeed, 0, targetAngle, // movementSpeed (fast enough to catch just about anything else), directionChangeFrequency (none as it should go only in one direction), movementDirection (direction of the target)
            true, 1.0, true, 1, // visible, opacity, immense radiation emission "due to really powerful engine" or something like that
            true, 1.0, true, 1.0, // fully radar and thermal detectable
            true, "HEAT SEEKING MISSILE\nACTIVE GUIDANCE\nFRIENDLY FIRE", [255, 0, 255], // IFF broadcasting
            contactType // Contact type
          );
        } else {
          // Create a hostile missile
          super(
            bearing, distance, 3, // bearing, starting distance, size
            movementSpeed, 0, targetAngle, // movementSpeed (fast enough to catch just about anything else), directionChangeFrequency (none as it should go only in one direction), movementDirection 
            false, 0, true, 1, // visible, opacity, immense radiation emission "due to really powerful engine" or something like that
            true, 1.0, true, 1.0, // fully radar and thermal detectable
            false, "", [255, 0, 0], // IFF broadcasting
            contactType // Contact type
          );
        }
        
        this.isMissile = true;
        this.targetContact = targetContact;
        this.thermalScanRadius = missileScanRadius;
        this.hasTarget = false;
        
        // Add fuel time property (in seconds)
        this.fuelTime = fuelTime; // Keeps track of original fuel time
        this.fuelRemaining = fuelTime;
        
        // Missile scan properties
        this.scanWidth = missileScanWidth; // Use the same width as the main scanner
        this.scanAngle = 0; // Current scan offset angle
        this.scanReversed = false; // Direction of scan
        this.scanCenter = 0; // Scan is centered forward of the missile

        // Arming time - Missile will not trigger collision check/explosion until armed
        this.armingTime = armingTime;

        // // debug
        // this.positionHistoryString = "Time = 0: " + centerX + ", " + centerY + "\n";
        // this.positionHistory = [{x: centerX, y: centerY, time: 0}];
      }
      
      updatePosition(deltaTime) {
        // debug
        // // get previous time
        // const prevTime = this.positionHistory[this.positionHistory.length - 1].time;
        // this.positionHistoryString += "Time = " + deltaTime + prevTime + ": " + this.realDistance * Math.cos(this.realBearing) + centerX + ", " + this.realDistance * Math.sin(this.realBearing) + centerY + "\n";
        // this.positionHistory.push({x: this.realDistance * Math.cos(this.realBearing) + centerX, y: this.realDistance * Math.sin(this.realBearing) + centerY, time: deltaTime + prevTime});

        // If not armed, count down arming time
        if (this.armingTime > 0) {
          this.armingTime -= deltaTime;
        }

        // Update fuel remaining
        this.fuelRemaining -= deltaTime;
        
        // Self-destruct if out of fuel
        if (this.fuelRemaining <= 0) {
          // Create explosion effect
          createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                         centerY + this.realDistance * Math.sin(this.realBearing));
          
          // Remove from contacts array
          const index = contacts.indexOf(this);
          if (index > -1) {
            contacts.splice(index, 1);
          }
          return;
        }
        
        // Update scan angle
        if (this.scanReversed) {
          this.scanAngle -= (Math.PI * missileScanSpeed / 180) * deltaTime;
          if (this.scanAngle <= -this.scanWidth/2) {
            this.scanAngle = -this.scanWidth/2;
            this.scanReversed = false;
          }
        } else {
          this.scanAngle += (Math.PI * missileScanSpeed / 180) * deltaTime;
          if (this.scanAngle >= this.scanWidth/2) {
            this.scanAngle = this.scanWidth/2;
            this.scanReversed = true;
          }
        }
        
        // Scan for thermal contacts if no target yet and armed 
        if (!this.hasTarget && this.armingTime <= 0) {
          // Use the missile's movement direction as its orientation.
          const missileOrientation = this.movementDirection;
          const absoluteScanAngle = missileOrientation + this.scanAngle;
          
          // Look for contacts in thermal scan range
          for (let contact of contacts) {
            if (contact === this) continue; // Skip self
            
            // Determine missile and contact positions in cartesian coordinates
            const missileX = centerX + this.realDistance * Math.cos(this.realBearing);
            const missileY = centerY + this.realDistance * Math.sin(this.realBearing);
            const contactX = centerX + contact.realDistance * Math.cos(contact.realBearing);
            const contactY = centerY + contact.realDistance * Math.sin(contact.realBearing);
            
            // Calculate position difference and distance
            const dx = contactX - missileX;
            const dy = contactY - missileY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate angle to contact relative to the missile's orientation
            const angleToContact = Math.atan2(dy, dx);
            const angleDiff = normalizeAngle(angleToContact - missileOrientation);
            
            // Check if contact is within scan arc and radius
            if (distance < this.thermalScanRadius &&
                Math.abs(angleDiff - this.scanAngle) < 0.1 &&
                contact.thermalDetectable) {
              this.targetContact = contact;
              this.hasTarget = true;
              break;
            }
          }
        }
        
        // Update missile direction if it has a target
        if (this.hasTarget && this.targetContact && !this.targetContact.destroyed) {
          // Calculate direction to target
          const targetX = Math.cos(this.targetContact.realBearing) * this.targetContact.realDistance;
          const targetY = Math.sin(this.targetContact.realBearing) * this.targetContact.realDistance;
          const missileX = Math.cos(this.realBearing) * this.realDistance;
          const missileY = Math.sin(this.realBearing) * this.realDistance;
          
          // Set movement direction toward target
          this.movementDirection = Math.atan2(targetY - missileY, targetX - missileX);
        }
        
        // Call parent updatePosition
        super.updatePosition(deltaTime);
        
        // Check for collisions with contacts, but only if it has a target
        if (this.hasTarget) {
          this.checkCollisions();
        }
      }
      
      checkCollisions() {
        // Only check for collisions if armed
        if (this.armingTime > 0) return;
      
        for (let i = 0; i < contacts.length; i++) {
          const contact = contacts[i];
          if (contact === this) continue;
          
          // Calculate distance between missile and contact
          const dx = Math.cos(contact.realBearing) * contact.realDistance - Math.cos(this.realBearing) * this.realDistance;
          const dy = Math.sin(contact.realBearing) * contact.realDistance - Math.sin(this.realBearing) * this.realDistance;
          const distance = Math.sqrt(dx*dx + dy*dy);
          
          // If collision detected with a thermal detectable contact, destroy both
          if (distance < (this.size + contact.size) && contact.thermalDetectable) {
            // Mark both as destroyed
            this.destroyed = true;
            contact.destroyed = true;
            
            // Create explosion effect
            createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                           centerY + this.realDistance * Math.sin(this.realBearing));
            
            // Check tutorial progress for missile destruction
            if ((this.isMissile && this.contactType === "FRIENDLY" && contact.isMissile && contact.contactType === "HOSTILE") ||
                (this.isMissile && this.contactType === "HOSTILE" && contact.isMissile && contact.contactType === "FRIENDLY")) {
                
              if (tutorialStage === 4 && !tutorialActions.shotDownMissile) {
                tutorialActions.shotDownMissile = true;
                shotDownFirstMissile = true;
              }
            }
            
            // Check for final target destruction
            if (tutorialStage === 5 && contact.contactType === "HOSTILE" && !contact.isMissile) {
              tutorialActions.destroyedFinalTarget = true;
            }
          
            // Remove both from contacts array
            contacts.splice(contacts.indexOf(this), 1);
            contacts.splice(contacts.indexOf(contact), 1);
            return;
          }
        }
      }
      
      draw(deltaTime) {
        // Draw the thermal scan cone if visible and friendly
        // Friendly contacts are "sending missile telemetry" to the player
        // Doesn't make sense for hostile or neutral contacts to do this
        if (this.visible && this.contactType === "FRIENDLY") {
          this.drawScanCone();
        }
        
        // Call parent draw method
        super.draw(deltaTime);
        
        // Draw fuel indicator if visible and friendly (see earlier comment about telemetry)
        if (this.visible && this.contactType === "FRIENDLY") {
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          // Draw fuel bar
          const barWidth = 20;
          const barHeight = 4;
          const fuelPercentage = this.fuelRemaining / this.fuelTime;
          
          // Draw fuel background
          ctx.fillStyle = "rgba(100, 100, 100, 0.7)";
          ctx.fillRect(contactX - barWidth/2, contactY + 8, barWidth, barHeight);
          
          // Draw remaining fuel - color changes as fuel depletes
          let fuelColor;
          if (fuelPercentage > 0.6) {
            fuelColor = "rgba(0, 255, 0, 0.7)"; // Green
          } else if (fuelPercentage > 0.3) {
            fuelColor = "rgba(255, 255, 0, 0.7)"; // Yellow
          } else {
            fuelColor = "rgba(255, 0, 0, 0.7)"; // Red
          }
          
          ctx.fillStyle = fuelColor;
          ctx.fillRect(contactX - barWidth/2, contactY + 8, barWidth * fuelPercentage, barHeight);
          
          // Update IFF string with fuel information
          const fuelSeconds = Math.round(this.fuelRemaining);
          this.iffString = `HEAT SEEKING MISSILE\nACTIVE GUIDANCE\nFUEL: ${fuelSeconds}s REMAINING`;
        }
      }
      
      drawScanCone() {
        // Calculate position on screen
        const missileX = centerX + this.realDistance * Math.cos(this.realBearing);
        const missileY = centerY + this.realDistance * Math.sin(this.realBearing);
        
        // Calculate orientation of missile (direction of movement)
        const missileOrientation = this.movementDirection;
        
        // Calculate start and end angles for the scan cone
        const absoluteScanAngle = missileOrientation + this.scanAngle;
        const startAngle = missileOrientation + this.scanCenter - this.scanWidth/2;
        const endAngle = missileOrientation + this.scanCenter + this.scanWidth/2;
        
        // Draw the thermal scan area
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.arc(missileX, missileY, this.thermalScanRadius, startAngle, endAngle);
        ctx.lineTo(missileX, missileY);
        ctx.fillStyle = "rgba(0, 0, 255, 0.2)"; // Thermal blue for missile scan
        ctx.fill();
        
        // Draw the thermal scan boundary lines
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(startAngle), 
          missileY + this.thermalScanRadius * Math.sin(startAngle)
        );
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(endAngle), 
          missileY + this.thermalScanRadius * Math.sin(endAngle)
        );
        ctx.strokeStyle = "#0000FF"; // Blue outline
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw the active scan line
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(absoluteScanAngle), 
          missileY + this.thermalScanRadius * Math.sin(absoluteScanAngle)
        );
        ctx.strokeStyle = "#0000FF"; // Blue
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    function drawBackground(deltaTime) {
      // Draw fading overlay - fade rate now per second
      ctx.fillStyle = `rgba(0, 0, 0, ${fadeRate * deltaTime})`;
      ctx.fillRect(0, 0, width, height);
      
      // Draw radar circle
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.strokeStyle = "#00AA00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw grid lines
      drawGrid();
    }
    
    function drawGrid() {
      // Draw crosshairs
      ctx.beginPath();
      ctx.moveTo(centerX - radius, centerY);
      ctx.lineTo(centerX + radius, centerY);
      ctx.moveTo(centerX, centerY - radius);
      ctx.lineTo(centerX, centerY + radius);
      ctx.strokeStyle = "#004400";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw concentric circles with range readouts
      const rangeLabels = ["0.25ls", "0.5ls", "0.75ls", "1ls"];
      
      for (let i = 1; i <= 4; i++) {
        const circleRadius = radius * i/4;
        // Draw the circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = "#004400";
        ctx.stroke();
        
        // Draw the range readout at the top of each circle
        ctx.fillStyle = "#00FF00";
        ctx.font = "12px monospace";
        ctx.textAlign = "center";
        ctx.fillText(rangeLabels[i-1], centerX, centerY - circleRadius);
      }
    }
    
    function drawRadarLine() {
      // Calculate the endpoint of the rotating line
      const endX = centerX + radius * Math.cos(angle);
      const endY = centerY + radius * Math.sin(angle);

      // Draw the rotating line
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw radar sweep (the glow effect)
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0, 
        centerX, centerY, radius
      );
      gradient.addColorStop(0, "rgba(0, 255, 0, 0.2)");
      gradient.addColorStop(1, "rgba(0, 255, 0, 0)");
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, angle - 0.2, angle, false);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
    
    function drawThermalScan() {
      // Draw the thermal scan zone
      const startAngle = thermalScanCenter - thermalScanWidth/2;
      const endAngle = thermalScanCenter + thermalScanWidth/2;
      
      // Draw the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, thermalScanRadius, startAngle, endAngle);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = "rgba(0, 0, 255, 0.2)";
      ctx.fill();
      
      // Draw the thermal scan boundary lines
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(startAngle), 
                 centerY + thermalScanRadius * Math.sin(startAngle));
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(endAngle), 
                 centerY + thermalScanRadius * Math.sin(endAngle));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw a line sweeping across the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(thermalScanAngle + thermalScanCenter), 
                 centerY + thermalScanRadius * Math.sin(thermalScanAngle + thermalScanCenter));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // For drawing how many missiles are left in stock on the player ship
    // Draws in the top left corner of the screen
    function drawCurrentMissiles() {
      const playerContact = contacts[0]; // Assuming the player ship is the first contact

      if (playerContact && playerContact.visible && playerContact.numMissiles !== undefined) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(10, 10, 150, 50);
        
        ctx.fillStyle = "#00FF00";
        ctx.font = "20px monospace";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText(`MISSILES: ${playerContact.numMissiles}`, 20, 20);
      }

    }

    // Function to add a new dialogue message
    function addDialogue(text, color, duration = defaultDialogueTime, imageFilePath) {
      // Add the message to the array with current time + duration as expiry time
      dialogueMessages.push({
      text: text,
      color: color,
      expiryTime: Date.now() + (duration * 1000), // Multiply by 1000 to convert to milliseconds
      image: imageFilePath
      });
    }

    // Function to draw dialogue messages in the top right corner
    function drawDialogue() {
      const currentTime = Date.now();
      
      // If no messages or all messages expired, don't draw anything
      if (dialogueMessages.length === 0 || dialogueMessages[dialogueMessages.length - 1].expiryTime < currentTime) {
        return;
      }
      
      const maxWidth = 375;
      const padding = 15;
      const lineHeight = 20;
      let currentY = 10; // Start at the top
      
      // Image dimensions
      const imageWidth = 80;
      const imageHeight = 120;
      
      // Draw messages from newest to oldest
      for (let i = dialogueMessages.length - 1; i >= 0; i--) {
        const message = dialogueMessages[i];
        
        // Skip expired messages
        if (message.expiryTime < currentTime) {
          continue;
        }
        
        // Split text into lines for wrapping
        const words = message.text.split(' ');
        let lines = [];
        let currentLine = words.length > 0 ? words[0] : '';
        
        ctx.font = "16px Arial";
        
        // Create wrapped lines
        for (let j = 1; j < words.length; j++) {
          const testLine = currentLine + ' ' + words[j];
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth) {
            lines.push(currentLine);
            currentLine = words[j];
          } else {
            currentLine = testLine;
          }
        }
        lines.push(currentLine);
        
        // Calculate box dimensions based on whether there's an image
        // Has image is true if the image property is defined.
        const hasImage = message.image !== undefined && message.image !== null && message.image !== "" ;
        const boxWidth = maxWidth + (padding * 2) + (hasImage ? imageWidth + padding : 0);
        const boxHeight = Math.max((lines.length * lineHeight) + (padding * 2), hasImage ? imageHeight + (padding * 2) : 0);
        
        // Check if we're going off-screen and need to stop drawing
        if (currentY + boxHeight > height) {
          break;
        }
        
        const boxX = width - boxWidth - 10;
        const boxY = currentY;
        
        // Draw the background box
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Draw the image if specified
        if (hasImage) {
          // If image hasn't been loaded yet, create and cache it
          if (!message.imageObject) {
            message.imageObject = new Image();
            message.imageObject.src = message.image;
          }
          
          // Position image inside the box with some padding
          const imgX = boxX + padding;
          const imgY = boxY + (boxHeight - imageHeight) / 2; // Center vertically
          
          // Only draw if the image is loaded
          if (message.imageObject.complete && message.imageObject.naturalWidth > 0) {
            ctx.drawImage(message.imageObject, imgX, imgY, imageWidth, imageHeight);
          }
        }
        
        // Draw the text - right aligned if no image, left aligned if there is an image
        ctx.fillStyle = message.color;
        ctx.textAlign = hasImage ? "left" : "right";
        ctx.textBaseline = "top";
        
        // Calculate text position
        const textX = hasImage 
          ? boxX + imageWidth + (padding * 2) // If image, position text after image
          : boxX + boxWidth - padding; // If no image, position from right edge
        
        const textY = boxY + (hasImage 
          ? (boxHeight - (lines.length * lineHeight)) / 2 // Center text vertically if there's an image
          : padding); // Default padding if no image
        
        lines.forEach((line, index) => {
          ctx.fillText(line, textX, textY + (index * lineHeight));
        });
        
        // Update Y position for next message
        currentY += boxHeight + 5; // 5px gap between boxes
      }
    }

    // Variables for message history
    let isViewingMessageHistory = false;
    let messageHistoryScrollPosition = 0;
    
    // Function to draw message history window
    function drawMessageHistory() {
      // Clear the screen with a dark background
      ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
      ctx.fillRect(0, 0, width, height);
      
      // Calculate window dimensions
      const margin = 50;
      const windowWidth = width - (margin * 2);
      const windowHeight = height - (margin * 2);
      
      // Draw window background
      ctx.fillStyle = "rgba(20, 20, 30, 0.8)";
      ctx.fillRect(margin, margin, windowWidth, windowHeight);
      ctx.strokeStyle = "rgba(0, 255, 255, 0.7)";
      ctx.lineWidth = 2;
      ctx.strokeRect(margin, margin, windowWidth, windowHeight);
      
      // Draw title
      ctx.font = "bold 24px Arial";
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText("MESSAGE HISTORY", centerX, margin + 20);
      
      // Draw navigation instructions
      ctx.font = "16px Arial";
      ctx.fillStyle = "#AAAAAA";
      ctx.fillText("Use UP/DOWN arrows to scroll, press H to return", centerX, margin + 50);
      
      // Draw divider line
      ctx.beginPath();
      ctx.moveTo(margin + 20, margin + 80);
      ctx.lineTo(margin + windowWidth - 20, margin + 80);
      ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Set up scrollable area
      const contentAreaTop = margin + 100;
      const contentAreaHeight = windowHeight - 120;
      const contentAreaBottom = contentAreaTop + contentAreaHeight;
      
      // Clip to content area
      ctx.save();
      ctx.beginPath();
      ctx.rect(margin + 20, contentAreaTop, windowWidth - 40, contentAreaHeight);
      ctx.clip();
      
      // Display messages
      const lineHeight = 24;
      const visibleMessages = [...dialogueMessages].reverse(); // Show newest messages first
      let y = contentAreaTop - messageHistoryScrollPosition;
      
      ctx.textAlign = "left";
      ctx.font = "16px Arial";
      
      visibleMessages.forEach(message => {
        // Format timestamp
        const timestamp = new Date(message.expiryTime - (defaultDialogueTime * 1000));
        const timeString = timestamp.toTimeString().split(' ')[0];
        
        // Draw timestamp
        ctx.fillStyle = "#888888";
        ctx.fillText(timeString, margin + 40, y);
        
        // Calculate text dimensions and position
        const textMaxWidth = windowWidth - 250;
        
        // Split text into lines for wrapping
        const words = message.text.split(' ');
        let lines = [];
        let currentLine = words.length > 0 ? words[0] : '';
        
        // Create wrapped lines
        for (let i = 1; i < words.length; i++) {
          const testLine = currentLine + ' ' + words[i];
          const metrics = ctx.measureText(testLine);
          if (metrics.width > textMaxWidth) {
            lines.push(currentLine);
            currentLine = words[i];
          } else {
            currentLine = testLine;
          }
        }
        lines.push(currentLine);
        
        // Draw message text
        ctx.fillStyle = message.color;
        lines.forEach((line, index) => {
          ctx.fillText(line, margin + 150, y + (index * lineHeight));
        });
        
        // Move Y position for next message
        y += (lines.length * lineHeight) + 15;
      });
      
      // Restore clipping
      ctx.restore();
      
      // Draw scroll indicators if needed
      if (messageHistoryScrollPosition > 0) {
        // Draw up arrow
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        ctx.moveTo(width - margin - 30, contentAreaTop + 20);
        ctx.lineTo(width - margin - 15, contentAreaTop + 5);
        ctx.lineTo(width - margin - 45, contentAreaTop + 5);
        ctx.closePath();
        ctx.fill();
      }
      
      // Check if we need to show down arrow (if more content exists below)
      const totalContentHeight = visibleMessages.reduce((total, msg) => {
        const lines = Math.ceil(ctx.measureText(msg.text).width / (windowWidth - 150));
        return total + (lines * lineHeight) + 15;
      }, 0);
      
      if (messageHistoryScrollPosition < totalContentHeight - contentAreaHeight && totalContentHeight > contentAreaHeight) {
        // Draw down arrow
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        ctx.moveTo(width - margin - 30, contentAreaBottom - 20);
        ctx.lineTo(width - margin - 15, contentAreaBottom - 5);
        ctx.lineTo(width - margin - 45, contentAreaBottom - 5);
        ctx.closePath();
        ctx.fill();
      }
    }

    // Draws the game over message in the center of the screen
    function drawGameOver() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, width, height);
      
      ctx.font = "bold 48px Arial";
      ctx.fillStyle = gameOverColor;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(gameOverMessage, centerX, centerY);
    }

    // Draws the pause menu in the center of the screen
    // Says "PAUSED" in big centered letters, then below it "Press P to unpause"
    function drawPauseMenu() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, width, height);
      
      ctx.font = "bold 48px Arial";
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("PAUSED", centerX, centerY - 20);
      ctx.font = "24px Arial";
      ctx.fillText("Press P to unpause", centerX, centerY + 20);
      ctx.fillText("Press H for message history", centerX, centerY + 60);
    }
    
    function normalizeAngle(a) {
      // Normalize angle to be between -pi and pi
      return a - Math.PI * 2 * Math.floor((a + Math.PI) / (Math.PI * 2));
    }
      
    // Function to create custom timeouts that respect pause state
    function createTimeout(callback, delay) {
      window.customTimeouts.push({
        callback: callback,
        delay: delay,
        elapsed: 0
      });
    }

    // Function to create custom intervals that respect pause state
    function createInterval(callback, delay) {
      const intervalId = Date.now() + Math.random(); // Generate a unique ID
      
      if (!window.customIntervals) {
        window.customIntervals = [];
      }
      
      window.customIntervals.push({
        callback: callback,
        delay: delay,
        elapsed: 0,
        id: intervalId
      });
      
      return intervalId; // Return ID so it can be cleared later
    }

    // Function to clear a custom interval
    function uncreateInterval(intervalId) {
      if (!window.customIntervals) return;
      
      const index = window.customIntervals.findIndex(interval => interval.id === intervalId);
      if (index !== -1) {
        window.customIntervals.splice(index, 1);
      }
    }
    
    function animate(currentTime) {

      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $tutorialOperationAllowed === "undefined" || $tutorialOperationAllowed === null || !$tutorialOperationAllowed) {
        // Cancel the animation frame if the operation is not allowed to run
        return;
      }
    
      // Game over check
      if (gameOver) {
        // If viewing message history, draw that instead of game over menu
        if (isViewingMessageHistory) {
          drawMessageHistory();
        } else {
          // Draw game over message
          drawGameOver();
        }

        // Keep animating, but only up to here
        requestAnimationFrame(animate)
        return;
      }
      
      // Check if game should end now
      // Check if all player ships are gone
      if (areAllContactsGone("PLAYER")) {
        gameOver = true;
        gameOverMessage = "DEFEAT!";
        gameOverColor = "red";
        // Play defeat sound
        const audio = new Audio("../assets/defeat.mp3");
        audio.play();
      }
      
      // Calculate time since last frame
      const deltaTime = ((currentTime - lastFrameTime) / 1000) * deltaTimeMultiplier; // Convert to seconds, then scale by deltaTimeMultiplier
      // Helps with keeping track of unpaused time
      let trueDeltaTimeMillis = currentTime - lastFrameTime;
      lastFrameTime = currentTime;

      // Pause check is placed here to ensure deltaTime will not jump when unpausing
      if (gamePaused) {
        // If viewing message history, draw that instead of pause menu
        if (isViewingMessageHistory) {
          drawMessageHistory();
        } else {
          // Pause menu is drawn in the event listener
        }

        // Keep animating, but only up to here
        requestAnimationFrame(animate)
        return;
      }

      // Keep track of how much time has been spent outside of pause
      unpausedElapsedTimeMillis += trueDeltaTimeMillis;
      
      // Custom timeout handling system
      if (!window.customTimeouts) {
        window.customTimeouts = [];
      }
      
      // Process any active timeouts
      for (let i = window.customTimeouts.length - 1; i >= 0; i--) {
        const timeout = window.customTimeouts[i];
        timeout.elapsed += trueDeltaTimeMillis;
        
        if (timeout.elapsed >= timeout.delay) {
          // Execute the callback and remove from array
          timeout.callback();
          window.customTimeouts.splice(i, 1);
        }
      }

    // Custom interval handling system
    if (!window.customIntervals) {
      window.customIntervals = [];
    }

    // Process any active intervals
    for (let i = window.customIntervals.length - 1; i >= 0; i--) {
      // Check if the interval still exists (may have been removed by another callback)
      if (i < window.customIntervals.length) {
        const interval = window.customIntervals[i];

        // Make sure interval is defined before trying to use it
        // Shouldn't be necessary, yet if this check is not here, the tutorial mission breaks after the missiles collide
        if (interval) {
          // Only increment elapsed time when game is not paused
          interval.elapsed += trueDeltaTimeMillis;

          if (interval.elapsed >= interval.delay) {
            try {
              // Execute the callback but don't remove from array
              interval.callback();
              // Reset elapsed time for next interval
              interval.elapsed = 0;
            } catch (error) {
              console.error("Error in interval callback:", error);
              // Remove problematic interval
              window.customIntervals.splice(i, 1);
            }
          }
        } else {
          // Remove undefined interval if it somehow exists
          window.customIntervals.splice(i, 1);
        }
      }
    }

    // Tutorial mission logic
    if (tutorialStage === 0) {
      // Initial instructions
      tutorialStage = 1;
      addDialogue("SIM_AI: This simulator will familiarize you with your role as the Sensor Engineer aboard Central Republic warships.", aiColor);
      
      createTimeout(() => {
        addDialogue("SIM_AI: To begin, we will first introduce you to the active Radar. Radar provides a means for you to identify targets at ranges up to one light-second away. For reference, that's 300,000 kilometers.", aiColor);
        
        createTimeout(() => {
          addDialogue("SIM_AI: The radar will now be powered on.", aiColor);
          
          createTimeout(() => {
            // Enable radar
            disableRadar = false;
            
            // Spawn a radar-detectable contact
            tutorialContactId = Date.now();
            contacts.push(new Contact(
              Math.PI/4, radius * 0.5, 5,
              0, 0, 0,
              false, 0, false, 0,
              true, 1, false, 0,
              false, "", [255, 0, 0],
              "NEUTRAL", 0
            ));
            
            createTimeout(() => {
              addDialogue("SIM_AI: Observe the contact report that is now appearing. When objects are detected by radar, this generates a contact report.", aiColor);
              
              createTimeout(() => {
                addDialogue("SIM_AI: You may notice that the report has various controls. Clicking on a report will report it to the captain.", aiColor);
                
                createTimeout(() => {
                  addDialogue("SIM_AI: Alternatively, you can either press X or wait out the report to dismiss it.", aiColor);
                  
                  createTimeout(() => {
                    addDialogue("SIM_AI: When in a combat scenario, you may press Q to recommend that a lot of missiles be fired at the contact.", aiColor);
                    
                    createTimeout(() => {
                      addDialogue("SIM_AI: For now, you are not in a combat scenario, so clicking on a report will only report it to the captain. To advance the tutorial, click the contact report as soon as you can.", aiColor);
                      
                      // Set up an interval to check if the player has reported the first contact
                      let checkReported = createInterval(() => {
                        if (tutorialActions.reportedFirstRadarContact) {
                          uncreateInterval(checkReported);
                          tutorialStage = 2;
                          
                          // Remove the original contact
                          contacts = contacts.filter(c => c.contactType === "PLAYER");
                          // And all contact reports
                          contactReports = [];
                          
                          addDialogue("SIM_AI: The next thing that must be learned about a radar is that it can be faulty. Sensor ghosts can sometimes appear on the radar.", aiColor);
                          
                          createTimeout(() => {
                            // Add several radar ghosts
                            for (let i = 0; i < 12; i++) {
                              contacts.push(new Contact(
                                Math.random() * Math.PI * 2, Math.random() * radius, 5,
                                120, 2, Math.random() * Math.PI * 2,
                                false, 0, false, 0,
                                true, 0.7, false, 0,
                                false, "", [255, 0, 0],
                                "GHOST", 0
                              ));
                            }
                            
                            // Add one real contact
                            const realContact = new Contact(
                              Math.PI * 1.25, radius * 0.75, 5,
                              0, 0, 0,
                              false, 0, false, 0,
                              true, 1, true, 1,
                              false, "", [255, 0, 0],
                              "NEUTRAL", 0
                            );
                            contacts.push(realContact);
                            
                            addDialogue("SIM_AI: Now lots of ghosts and one real contact has been added. You must report it to advance the scenario. Hint: Sensor ghosts aren't consistently located in one spot, but real contacts are.", aiColor);
                            
                            // Check when player reports the real contact using the flag
                            let checkRealReported = createInterval(() => {
                              if (tutorialActions.reportedRealRadarContact) {
                                uncreateInterval(checkRealReported);
                                tutorialStage = 3;
                                
                                // Remove all non-player contacts
                                contacts = contacts.filter(c => c.contactType === "PLAYER");
                                // And all contact reports
                                contactReports = [];
                                
                                addDialogue("SIM_AI: Good job. If you wish to review any of the previous messages, you can do so by pressing H.", aiColor);
                                
                                createTimeout(() => {
                                  addDialogue("SIM_AI: The next tool in your sensor kit is a passive electromagnetic radiation detector. This will detect objects emitting radiation.", aiColor);
                                  
                                  createTimeout(() => {
                                    addDialogue("SIM_AI: These will only highlight the direction the emission was detected in, and will not tell you the distance.", aiColor);
                                    
                                    createTimeout(() => {
                                      // Add an ELINT detectable contact
                                      contacts.push(new Contact(
                                        Math.PI/2, radius * 0.5, 5,
                                        0, 0, 0,
                                        false, 0, true, 0.8,
                                        false, 0, false, 0,
                                        false, "", [255, 0, 0],
                                        "NEUTRAL", 0
                                      ));
                                      
                                      addDialogue("SIM_AI: A contact emitting radiation has now been added. Observe how the radiation detector picks up on this.", aiColor);
                                      
                                      createTimeout(() => {
                                        addDialogue("SIM_AI: But as you might have guessed, this detector is prone to picking up random noise. Space is full of things that emit radiation.", aiColor);
                                        
                                        createTimeout(() => {
                                          addDialogue("SIM_AI: Environments like this.", aiColor);
                                          
                                          // Remove previous contact and add ELINT ghosts
                                          contacts = contacts.filter(c => c.contactType === "PLAYER");
                                          // And all contact reports
                                          contactReports = [];
                                          
                                          // Add many ELINT ghosts
                                          for (let i = 0; i < 24; i++) {
                                            contacts.push(new Contact(
                                              Math.random() * Math.PI * 2, Math.random() * radius, 5,
                                              120, 2, Math.random() * Math.PI * 2,
                                              false, 0, true, 0.05,
                                              false, 0, false, 0,
                                              false, "", [255, 0, 0],
                                              "GHOST", 0
                                            ));
                                          }
                                          
                                          createTimeout(() => {
                                            addDialogue("SIM_AI: The final tool in the sensor kit is the thermal scanner. It can be rotated with the A/D keys.", aiColor);
                                            
                                            createTimeout(() => {
                                              addDialogue("SIM_AI: Thermal scanners are virtually foolproof - there aren't false detections, and nothing can hide from it.", aiColor);
                                              
                                              createTimeout(() => {
                                                // Add a stealth contact with high ELINT
                                                contacts.push(new Contact(
                                                  Math.PI * 1.75, radius * 0.15, 5,
                                                  0, 0, 0,
                                                  false, 0, true, 0.9,
                                                  false, 0, true, 1,
                                                  false, "", [255, 0, 0],
                                                  "NEUTRAL", 0
                                                ));
                                                
                                                addDialogue("SIM_AI: A contact with full radar stealth has been added. It is emitting radiation. See if you can pick it up.", aiColor);
                                                
                                                createTimeout(() => {
                                                  addDialogue("SIM_AI: Now the thermal scanner will be powered on. Rotate the scanner to detect the contact, then report it.", aiColor);
                                                  
                                                  // Enable thermal scanner
                                                  disableThermal = false;
                                                  
                                                  // Check when player reports the stealth contact using the flag
                                                  let checkStealthReported = createInterval(() => {
                                                    if (tutorialActions.reportedStealthContact) {
                                                      uncreateInterval(checkStealthReported);
                                                      tutorialStage = 4;
                                                      
                                                      // Remove all non-player contacts
                                                      contacts = contacts.filter(c => c.contactType === "PLAYER");
                                                      // And all contact reports
                                                      contactReports = [];
                                                      
                                                      addDialogue("SIM_AI: Good job. For the final part of this tutorial, you must learn to fire weapons.", aiColor);
                                                      
                                                      createTimeout(() => {
                                                        addDialogue("SIM_AI: Currently, you are not networked into the fire control computer. Any request for fire must be routed through the captain. In some situations you may start off with permission to fire. But in others, you will not. To receive permission to fire, you must indicate some clear and present danger to the ship.", aiColor);
                                                        
                                                        createTimeout(() => {
                                                          // Set up missile attack interval
                                                          tutorialMissileInterval = createInterval(() => {
                                                            // Only spawn if the missile has not been shot yet
                                                            if (!tutorialActions.shotDownMissile) {
                                                              // Spawn a missile targeted at the player
                                                              const missileContact = new MissileContact(
                                                                Math.random() * Math.PI * 2, radius * 0.92,
                                                                contacts[0], 30, "HOSTILE", 0.5, 10
                                                              );
                                                              contacts.push(missileContact);
                                                            }
                                                          }, 8000);
                                                          
                                                          addDialogue("SIM_AI: Like the missile that's going to be spawned in to hit you. Don't worry, it doesn't have enough fuel to reach all the way to the ship.", aiColor);
                                                          
                                                          createTimeout(() => {
                                                            addDialogue("SIM_AI: To advance the scenario, report the missile.", aiColor);
                                                            
                                                            // Check when player reports a missile using the flag
                                                            let checkMissileReported = createInterval(() => {
                                                              if (tutorialActions.reportedMissile) {
                                                                uncreateInterval(checkMissileReported);
                                                                
                                                                addDialogue("Engineer: Incoming!", engineerColor);
                                                                
                                                                createTimeout(() => {
                                                                  addDialogue("Captain: I'm networking you into the fire control computer.", captainColor, defaultDialogueTime, captainPortraitFilePath);
                                                                  
                                                                  // Enable firing
                                                                  allowedToFire = true;
                                                                  
                                                                  addDialogue("SIM_AI: Now you have the ability to fire at the missile. Click the contact report again.", aiColor);
                                                                  
                                                                  // Set up check for missile destroyed using the flag
                                                                  let checkMissileDestroyed = createInterval(() => {
                                                                    if (tutorialActions.shotDownMissile) {
                                                                      uncreateInterval(checkMissileDestroyed);
                                                                      uncreateInterval(tutorialMissileInterval);
                                                                      tutorialStage = 5;
                                                                      
                                                                      // Remove all non-player contacts
                                                                      contacts = contacts.filter(c => c.contactType === "PLAYER");
                                                                      // And all contact reports
                                                                      contactReports = [];
                                                                      
                                                                      addDialogue("SIM_AI: Notice that the missile counter was decremented. It is important to conserve your missiles. Another note about missiles: They have an arming time, during which they cannot lock on to targets or blow up. ", aiColor);
                                                                      
                                                                      createTimeout(() => {
                                                                        addDialogue("SIM_AI: But for the sake of this simulation, the counter will be reset to full.", aiColor);
                                                                        
                                                                        // Enable infinite missiles
                                                                        infiniteMissiles = true;
                                                                        
                                                                        createTimeout(() => {
                                                                          addDialogue("SIM_AI: It may sometimes be necessary to fire at a point that you suspect a contact is located at.", aiColor);
                                                                          
                                                                          createTimeout(() => {
                                                                            addDialogue("SIM_AI: To do so, you must click on a spot in the radar screen.", aiColor);
                                                                            
                                                                            // Enable point firing
                                                                            allowedToFireAtSpot = true;
                                                                            
                                                                            createTimeout(() => {
                                                                              // Add a stealth contact for final target
                                                                              const finalContact = new Contact(
                                                                                Math.random() * Math.PI * 2, radius * 0.3, 5,
                                                                                0.12, 0.1, Math.random() * Math.PI * 2,
                                                                                false, 0, true, 0.9,
                                                                                false, 0, true, 1,
                                                                                false, "", [255, 0, 0],
                                                                                "HOSTILE", 0
                                                                              );
                                                                              contacts.push(finalContact);
                                                                              
                                                                              addDialogue("SIM_AI: A contact with full radar stealth has been added. Using the radiation detections as a hint, fire in that direction to win.", aiColor);
                                                                              
                                                                              // Check if the final target is destroyed using the flag
                                                                              let checkMissionComplete = createInterval(() => {
                                                                                if (tutorialActions.destroyedFinalTarget || areAllContactsGone("HOSTILE")) {
                                                                                  uncreateInterval(checkMissionComplete);
                                                                                  
                                                                                  // Trigger mission victory
                                                                                  gameOver = true;
                                                                                  $playerWonO2 = true;
                                                                                  gameOverMessage = "TUTORIAL COMPLETE!";
                                                                                  gameOverColor = "green";
                                                                                  
                                                                                  const audio = new Audio("../assets/victory.mp3");
                                                                                  audio.play();
                                                                                }
                                                                              }, 1000);
                                                                            }, 6000);
                                                                          }, 6000);
                                                                        }, 6000);
                                                                      }, 6000);
                                                                    }
                                                                  }, 1000);
                                                                }, 6000);
                                                              }
                                                            }, 1000);
                                                          }, 6000);
                                                        }, 10000);
                                                      }, 6000);
                                                    }
                                                  }, 1000);
                                                }, 10000);
                                              }, 10000);
                                            }, 10000);
                                          }, 10000);
                                        }, 10000);
                                      }, 12000);
                                    }, 10000);
                                  }, 10000);
                                }, 10000);
                              }
                            }, 2000);
                          }, 10000);
                        }
                      }, 2000);
                    }, 10000);
                  }, 10000);
                }, 10000);
              }, 10000);
            }, 10000);
          }, 9000);
        }, 10000);
      }, 6000);
    }

    // Handle disabling radar/thermal drawing if needed
    if (disableRadar) {
      // Skip radar line drawing
    } else {
      drawRadarLine();
    }

    if (disableThermal) {
      // Skip thermal scan drawing
    } else {
      drawThermalScan();
    }

    // Handle infinite missiles if enabled
    if (infiniteMissiles && contacts.length > 0 && contacts[0]) {
      contacts[0].numMissiles = 100;
    }  

      //
      // Plan for this mission
      //

      // tutorial mission:

      // -- No sensors / scan lines should be drawn to screen at this point. The code responsible for drawing the radar and thermal scan should be disabled. Elint can still be drawn --

      // This simulator will familiarize you with your role as the Sensor Engineer aboard Central Republic warships.

      // To begin, we will first introduce you to the active Radar. Radar provides a means for you to identify targets at ranges up to one light-second away. For reference, that's 300,000 kilometers.

      // The radar will now be powered on.

      // -- The code for drawing the radar now becomes active --

      // -- A contact is spawned in which is detectable by the radar, but not by ELINT. It is located 0.5 radii from the center --

      // Observe the contact report that is now appearing. When objects are detected by radar, this generates a contact report.

      // You may notice that the report has various controls. Clicking on a report will report it to the captain, who can then make an informed decision about what to do.

      // Alternatively, you can either press X or wait out the report to dismiss it.

      // When in a combat scenario, you may press Q to recommend that a lot of missiles be fired at the contact, spread out over a large area to increase the chances of hitting it.

      // Also when in a combat scenario, if you have been networked into the fire control computer, you may click on the report to fire a missile at it. Sometimes, the radar can pick up enough information to determine a contact's velocity. This will make the missile fired at a contact report try to fire at when it is going, so that the missile can intercept moving contacts. If the contact is moving too fast for an intercept, the missile will default to shooting at it's last known position.

      // For now, you are not in a combat scenario, so clicking on a report will only report it to the captain, and pressing Q will do nothing. To advance the tutorial, click the contact report as soon as you can.

      // The next thing that must be learned about a radar is that it can be faulty. Sensor ghosts can sometimes appear on the radar, and these can be nearly indistinguishable from real contacts.

      // A number of sensor ghosts will now be spawned in, and the previous contact will be removed.

      // -- The contact previously added is removed --

      // -- Twelve radar ghosts are now spawned in, followed by one real contact located at 0.75 radii from the center --

      // Now one real contact has been added. You must report it to advance the scenario. Hint: Sensor ghosts aren't consistently located in one spot, but real contacts are.

      // -- A check is now activated inside the event listener that checks to see when the player clicks the one real contact --

      // -- After clicking, all contacts other than the player ship are removed --

      // Good job. If you wish to review any of the previous messages, you can do so at any time by pressing H. You can return by pressing P twice. Scrolling in the message history menu can be done with the up and down arrow keys.

      // The next tool in your sensor kit is a passive electromagnetic radiation detector. This will detect objects emitting radiation, whether it be radio waves from another ship's radar, or the immense energy put out by a missile engine running at full burn.

      // These will only highlight the direction the emission was detected in, and will not tell you the distance to that emission, unlike radar.

      // -- A contact that has a high ELINT detection chance is now added 0.5 radii from the center --

      // A contact emitting radiation has now been added. Observe how the radiation detector picks up on this.

      // But as you might have guessed, this detector is prone to picking up random noise. Space is full lots of things that emit radiation, and the detector can pick up on these as well. In particularly hostile environments, the detector may be constantly going off.

      // Environments like this.

      // -- Twenty four ELINT ghosts are now added. The previous object is removed --

      // But even so, particularly emissive objects can still be differentiated from mere ghosts.

      // Some objects may be able to hide from Radar, but not from the radiation detector, and that leads into the final tool in the sensor kit: The thermal scanner.

      // The thermal scanner scans a particular sub-region of the radar screen. It can be rotated with the A/D keys.

      // Thermal scanners are virtually foolproof - that is to say there aren't false detections on it, and nothing can hide from it. It's only limitation is it's short range and limited cone of detection.

      // A contact with full radar stealth has been added, although it is emitting quite a bit of radiation. See if you can pick it up through all the radiation noise.

      // -- A single real contact is added at 0.15 radii from the center. It has an extremely high ELINT detection chance --

      // Now the thermal scanner will be powered on. To advance the scenario, rotate the scanner to detect the contact, then report the associated thermal contact report. It is within thermal detection range.

      // -- The code for drawing the thermal scanner and rotating it with a and d becomes active --

      // -- Another check is now activated inside the event listener that checks to see when the player clicks the one real contact --

      // -- After clicking, all contacts other than the player ship are removed --

      // Good job. For the final part of this tutorial, you must learn to fire weapons.

      // Currently, you are not networked into the fire control computer. Any request for fire must be routed through the captain. In some situations you may start off with permission to fire. But in others, you will not. To receive permission to fire, you must indicate some clear and present danger to the ship.

      // -- Using the custom createInterval function, a missile should be spawned in at 0.92 radii and sent directly towards the player ship at an interval, with insufficient fuel time to reach the player ship --

      // Like the missile just spawned in to hit you. Don't worry, it doesn't actually have enough fuel to reach all the way to the ship. To advance the scenario, report the missile. It will respawn until reported.

      // -- On reporting the missile, the following dialogue should play --

      // Engineer: Incoming!
      // Captain: I'm networking you into the fire control computer.

      // -- The player should now be allowed to fire at a contact report, but not at a point --

      // Now you have the ability to fire at the missile. Click the contact report again to have the ship launch a missile of its own to shoot down the incoming missile. Do so to advance.

      // -- There will now be a check to see if the hostile missile ever collides with a friendly missile. If so, the interval responsible for spawning the missile is deleted and it stops being spawned in. Any contacts other than the player ship are removed at this point --

      // Notice that the missile counter in the top left was decremented. It is important to conserve your missiles in combat scenarios so you have enough to shoot down any salvo fired by the enemy.

      // But for the sake of this simulation, the counter will be reset to full.

      // -- Code responsible for resetting the player ship's missile count to 100 every frame now becomes active --

      // It may sometimes be necessary to fire at a point that you suspect a contact is located at.

      // To do so, you must click on a spot in the radar screen. This will launch a missile directly at the clicked location.

      // Don't worry about the missiles not being able to see the contact. As you may have noticed, they have a built in thermal scanner, albeit one with much less range.

      // So long as the missile's target is within it's thermal scan cone, the missile will home in on it.

      // But this is a double edged sword, as the missile doesn't care who's friendly. It will home in on ANY heat source.

      // A contact with full radar stealth has been added outside of thermal detection range. But don't worry, it is emitting radiation. Using the bearing given by the constant radiation detections as a hint, fire in the general direction of the contact to blow it up. Do so to win the scenario.

      // -- The player is now allowed to fire at a point. When this contact is destroyed, trigger the mission victory --

      
      // Cap deltaTime to prevent huge jumps if tab was inactive
      const cappedDeltaTime = Math.min(deltaTime, 0.5);
      
      drawBackground(cappedDeltaTime);
      
      // Calculate thermal scan absolute angle
      const thermalScanAbsoluteAngle = thermalScanAngle + thermalScanCenter;

      // Sort contacts into friendly and hostile arrays
      // Do not include missiles in these arrays
      const friendlyContacts = contacts.filter(contact => contact.contactType === "FRIENDLY" || contact.contactType === "PLAYER" && !contact.isMissile);
      const hostileContacts = contacts.filter(contact => contact.contactType === "HOSTILE" && !contact.isMissile);
      
      // Update and draw contacts
      for (let contact of contacts) {
        contact.updatePosition(cappedDeltaTime);
        contact.checkDetection(angle, thermalScanAbsoluteAngle, thermalScanRadius, cappedDeltaTime);
        contact.draw(cappedDeltaTime);
      }

      // Draw the text telling the player in the top left how many missiles are left
      drawCurrentMissiles();
      // Draw the dialogue messages in the top right corner
      drawDialogue();
      
      // Update and draw contact reports
      for (let i = contactReports.length - 1; i >= 0; i--) {
        if (!contactReports[i].update(cappedDeltaTime)) {
          contactReports.splice(i, 1);
        } else {
          contactReports[i].draw();
        }
      }
      
      // Update the radar scan angle (rotate by specified degrees per second)
      angle += (Math.PI * radarSpeed / 180) * cappedDeltaTime;
      if (angle >= Math.PI * 2) angle = 0;

      // Update the thermal scan angle
      if (thermalScanReversed) {
        thermalScanAngle -= (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle <= -thermalScanWidth/2) {
          thermalScanAngle = -thermalScanWidth/2;
          thermalScanReversed = false;
        }
      } else {
        thermalScanAngle += (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle >= thermalScanWidth/2) {
          thermalScanAngle = thermalScanWidth/2;
          thermalScanReversed = true;
        }
      }
      
      requestAnimationFrame(animate);
    }

    // Track mouse position
    let mouseX, mouseY;
    canvas.addEventListener('mousemove', function(event) {
      const rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    });

    // Add click event listener for contact reports
    canvas.addEventListener('click', function(event) {
      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $tutorialOperationAllowed === "undefined" || $tutorialOperationAllowed === null || !$tutorialOperationAllowed) {
        return;
      }
    
      // If paused, do nothing
      if (gamePaused) return;
    
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
    
      // Check if click is on a contact report
      let wasOnContactReport = false;
      for (let i = 0; i < contactReports.length; i++) {
        if (contactReports[i].contains(mouseX, mouseY)) {
          wasOnContactReport = true;

          // Check tutorial stage-specific actions
          if (tutorialStage === 1 && contactReports[i].contact.contactType === "NEUTRAL" && !tutorialActions.reportedFirstRadarContact) {
            tutorialActions.reportedFirstRadarContact = true;
          }
          else if (tutorialStage === 2 && contactReports[i].contact.contactType === "NEUTRAL" && !tutorialActions.reportedRealRadarContact) {
            tutorialActions.reportedRealRadarContact = true;
          }
          else if (tutorialStage === 3 && contactReports[i].contact.contactType === "NEUTRAL" && !tutorialActions.reportedStealthContact) {
            tutorialActions.reportedStealthContact = true;
          }
          else if (tutorialStage === 4 && contactReports[i].contact.isMissile && !tutorialActions.reportedMissile) {
            tutorialActions.reportedMissile = true;
          }
        
          // Missile firing logic - only if allowed
          if (allowedToFire) {
            contacts[0].launchMissileAtContact(contactReports[i].contact, 30, 0.9, 10, false);
          }
        
          // Remove the report after clicking
          contactReports.splice(i, 1);
          break;
        }
      }

      // If not on a contact report, check if click is on radar screen for missile firing
      if (!wasOnContactReport && allowedToFireAtSpot && allowedToFire) {
        const dx = mouseX - centerX;
        const dy = mouseY - centerY;
        contacts[0].launchMissileAtPoint(dx, dy, 30, 0.9, 10);
      }
    });

    // Key event listeners for thermal scan control
    document.addEventListener('keydown', function(event) {
      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $tutorialOperationAllowed === "undefined" || $tutorialOperationAllowed === null || !$tutorialOperationAllowed) {
        // Cancel the event if the operation is not allowed to be running
        return;
      }
      if (event.key === 'a' || event.key === 'A') {
        // Rotate thermal scan left
        // If paused, do nothing
        if (!gamePaused) {
          thermalScanCenter -= 0.1;
          if (thermalScanCenter < 0) thermalScanCenter += Math.PI * 2;
        }
      } else if (event.key === 'd' || event.key === 'D') {
        // Rotate thermal scan right
        // If paused, do nothing
        if (!gamePaused) {
          thermalScanCenter += 0.1;
          if (thermalScanCenter >= Math.PI * 2) thermalScanCenter -= Math.PI * 2;
        }
      } else if (event.key === 'x' || event.key === 'X') {
        // Check if the mouse is over a contact report
        // If paused, do nothing
        if (!gamePaused) {
          for (let i = 0; i < contactReports.length; i++) {
            if (contactReports[i].contains(mouseX, mouseY)) {
              // Dismiss the contact report
              console.log(`Contact report at ${contactReports[i].timestamp} dismissed`);
              contactReports.splice(i, 1);
              break;
            }
          }
        }
      } else if (event.key === 'q' || event.key === 'q') {
        // If not allowed to fire, do nothing
        if (!allowedToFire) return;

        // Check if the mouse is over a contact report
        // If paused, do nothing
        if (!gamePaused) {
          for (let i = 0; i < contactReports.length; i++) {
            if (contactReports[i].contains(mouseX, mouseY)) {
              // Fire a spread at the contact in the contact report
              
              // Fire at the contact report's associated contact
              // contacts[0] is the player ship, so we will use it to launch the missile
              // launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed, isSpreadAttack)
              contacts[0].launchMissileAtContact(contactReports[i].contact, 30, 0.9, 10, true);

              console.log(`Spread fired at Contact report at ${contactReports[i].timestamp}`);
              contactReports.splice(i, 1);
              break;
            }
          }
        }
      } else if (event.key === 'p' || event.key === 'P') {
        // Toggle pause state if not in game over state
        if (!gameOver) {
          // If viewing message history, just exit that view but remain paused
          if (isViewingMessageHistory) {
            isViewingMessageHistory = false;
            drawPauseMenu();
          } else {
            gamePaused = !gamePaused;
            if (gamePaused) {
              console.log("Game paused");
              // Draw it here to ensure it's only drawn once when paused
              drawPauseMenu();
            } else {
              console.log("Game unpaused");
            }
          }
        }
      } else if (event.key === 'h' || event.key === 'H') {
        // Toggle message history view
        if (isViewingMessageHistory) {
          // Exit message history view but stay paused
          isViewingMessageHistory = false;
          drawPauseMenu();
        } else {
          // If game is not already paused, pause it
          if (!gamePaused) {
            gamePaused = true;
          }
          // Switch to message history view
          isViewingMessageHistory = true;
          // Reset scroll position when first opening
          messageHistoryScrollPosition = 0;
        }
      } else if (event.key === 'ArrowUp') {
        // Scroll message history up
        if (isViewingMessageHistory) {
          messageHistoryScrollPosition = Math.max(0, messageHistoryScrollPosition - 40);
        }
      } else if (event.key === 'ArrowDown') {
        // Scroll message history down
        if (isViewingMessageHistory) {
          messageHistoryScrollPosition += 40;
          // Upper limit will be checked in draw function
        }
      }
    });

    // Create contacts array with initial contacts
    // Parameters: bearing, distance, size, 
    //             movementSpeed, directionChangeFrequency, movementDirection, 
    //             visible, opacity, emittingRadiation, emissionDetectionChance,
    //             radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
    //             iffBroadcasting, iffString, contactColor, contactType,
    //             numMissilesLoaded
    let contacts = [
      // The player's ship. Always visible and at the center of the radar
      // Has 100 missiles loaded
      new Contact(0, 0, 5, 
                  0, 0, 0, 
                  true, 1, true, 0, 
                  true, 0, true, 0,
                  true, "PLAYER SHIP, Heavy Cruiser\nCRS Bounty\nCairn Class", [255, 255, 255],
                  "PLAYER", 100),
    ];

    // Fill the canvas with black initially
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, width, height);
    
    // Start the animation with the timestamp
    lastFrameTime = performance.now();

    requestAnimationFrame(animate);
  })();
</script>

[[Back->Intro 3]]

:: Operation 1 {"position":"1200,200","size":"100,100"}
Operation 1: Across the Point

Tips:
Use your thermal scanner, especially when missiles are flying at you.
The captain won't fire until you identify an incoming missile.
Click the contact report box, not the contact itself to report contacts.
When weapon fire is authorized, you can click on a spot to fire at that spot.

Controls:
F11 for fullscreen
Thermal Scan - Use A/D to rotate
Contact Report - Left click to fire at, X to Dismiss, Q to fire a spread at
Pause - P to toggle pause
Message history - H to pause and view message history
<!-- Operation 1 -->
<!-- Removal of padding allows for much more game room on small monitors -->
<style>
tw-story {
  padding: 0% 0%;
  padding-top: 0%;
  padding-right: 0%;
  padding-bottom: 0%;
  padding-left: 0%;
}

@media (min-width: 576px) {
  tw-story {
    padding: 0% 0%;
    padding-top: 0%;
    padding-right: 0%;
    padding-bottom: 0%;
    padding-left: 0%;
  }
}
</style>

<canvas id="operation1" width="1350" height="750"></canvas>
<script>
    // Mark operation 1 as being usable
    $operation1Allowed = true;
    // Stops the previous audio
    if (typeof audio !== 'undefined') {
      audio.pause();
      // And probably remove it from the memory
      delete audio;
    }
  (function() {
    const canvas = document.getElementById("operation1");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 3;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 2 - 10;

    // Array of elint beep audios. Rather than create and play a new beep each time there is a detection,
    // we will instead reuse numBeeps number of beeps. This is to prevent the audio from overlapping and
    // creating a cacophony of beeps that can overload the number of audio channels available in the browser.
    const numBeeps = 20;
    const elintBeeps = Array.from({ length: numBeeps }, () => new Audio("../assets/ELINTBeep.mp3"));
    
    // Track the start time
    const startTime = Date.now();
    let lastFrameTime = performance.now();
    // Track the unpaused elapsed time
    let unpausedElapsedTimeMillis = 0;
    // Time multiplier
    // 1 = normal speed
    // 2 = double speed
    // 0.5 = half speed
    const deltaTimeMultiplier = 2.4;
    // Detection chance time multiplier
    // Intended to address the fact that PC performance can affect detection chances
    const detectionTimeMultiplier = 1;

    // Game state variables
    let gameOver = false;
    let gamePaused = true;
    let gameOverMessage = "";
    let gameOverColor = "";

    // If the game is paused, go ahead and draw the pause screen
    if (gamePaused) {
      requestAnimationFrame(drawPauseMenu);
    }

    // Customizable parameters - now in units per second instead of per frame
    const radarSpeed = 30; // degrees per second
    const fadeRate = 6;   // fade opacity per second
    const ELINTHalfAngle = Math.PI/36; // 5 degrees in radians
    
    // Radar line angle
    let angle = 0;
    // Thermal scan angle
    let thermalScanAngle = 0;
    
    // Thermal scan parameters
    const thermalScanWidth = Math.PI/6; // 30 degrees in radians
    const thermalScanRadius = radius * 0.25; // 0.25ls circle
    const thermalScanSpeed = 30; // degrees per second
    let thermalScanCenter = 0; // Center of thermal scan area
    let thermalScanReversed = false; // Direction of thermal scan rotation

    // Missile thermal scan parameters
    const missileScanWidth = Math.PI/6; // 30 degrees in radians
    const missileScanRadius = radius * 0.05; // 0.05ls circle
    const missileScanSpeed = 60; // degrees per second

    // Random missile launch parameters
    const baseMissileLaunchChance = 0;
    let missileLaunchChance = baseMissileLaunchChance;
    let missileLaunchIncrease = 0;
    // Missile attack type parameters
    const chanceOfSpreadAttack = 0.0;
    const spreadAttackMissilePerRadiusAmount = 0.05; // Add 1 more missile for every radius amount of distance to target
    let allowedToFireAtSpot = false; // If true, the player can fire at any point on the screen, not just contacts. If false, they can't.
    let allowedToFire = false; // If true, the player can cause a missile to be launched. If false, all controls related to firing are disabled. 

    // Contact report parameters
    const contactReports = [];
    const reportLifetime = 10; // lifetime in seconds

    // IFF Parameters
    const iffBoxDisplayDistance = 100; // How far away the mouse can be before the IFF box stops displaying
    const acceptedTypes = ["FRIENDLY", "HOSTILE", "NEUTRAL", "GHOST", "PLAYER"]; // Accepted contact types

    // Dialogue message parameters
    const dialogueMessages = []; // Array to store dialogue messages with text, color, and time they should disappear
    const defaultDialogueTime = 8; // Default time for dialogue messages to disappear
    // Dialogue flags
    let isFirstContact = true;
    let isFirstMissile = true;
    let shotDownFirstMissile = false;
    let firedFirstSpread = false;
    let firedSpreadAtMissile = false;
    let firedSpreadAtInvalidTarget = false;
    let response1 = false;
    let response2 = false;
    let response2a = false;
    let response3 = false;
    let response3a = false;
    let response4 = false;
    let response4a = false;
    let response5 = false;
    let response5a = false;
    let response6 = false;
    let response6a = false;
    let response7 = false;
    let response7a = false;
    let response8 = false;
    let response8a = false;
    let response9 = false;
    let response9a = false;
    let response10 = false;
    let response10a = false;
    // Dialogue message colors for certain characters
    const engineerColor = "#00FF00";
    const captainColor = "#34eb7a";
    const friendlyColor = "#FF00FF"
    const unidentifiedColor = "#FFFFFF"
    const pirateColor = "#FF0000"
    // Dialogue portrait paths
    const captainPortraitFilePath = "../assets/characters/CaptainPortrait.png";

    // Function to create explosion effect
    function createExplosion(x, y) {
      // Play explosion sound (Unused for now)
      // const explosionSound = new Audio("../assets/MissileHit.mp3");
      // explosionSound.play();

      // Visual explosion effect (flash)
      ctx.beginPath();
      ctx.arc(x, y, 30, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255, 200, 50, 0.8)";
      ctx.fill();
    }

    // Function to check if all contacts of a specific type are gone
    function areAllContactsGone(type) {
      return !contacts.some(contact => contact.contactType === type && !contact.destroyed);
    }

    // Contact Report class
    class ContactReport {
      constructor(x, y, timestamp, contactType, contact) {
        this.x = x;
        this.y = y;
        this.timestamp = timestamp;
        this.contactType = contactType;
        this.contact = contact;
        this.timeCreated = Date.now();
        this.age = 0;
        this.maxAge = reportLifetime;
      }
      
      update(deltaTime) {
        // Increment age, but only if the contact is no longer visible or no longer exists
        if (!this.contact || !this.contact.visible || this.contact.destroyed || typeof this.contact === 'undefined') {
          this.age += deltaTime;
        }
        return this.age < this.maxAge;
      }
      
      draw() {
        // Calculate opacity based on age
        const opacity = 1 - (this.age / this.maxAge);
        
        // Determine position (ensure it's on screen)
        const boxWidth = 180;
        const boxHeight = 75; // Increased height to fit new line
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        // Draw connection line
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(boxX + (boxX > this.x ? 0 : boxWidth), boxY + boxHeight/2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw box
        ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.7})`;
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Draw text
        ctx.font = "10px monospace";
        ctx.fillStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.textAlign = "left";
        ctx.fillText(`DETECTED: ${this.timestamp}`, boxX + 5, boxY + 15);
        ctx.fillText(`POTENTIAL ${this.contactType} CONTACT`, boxX + 5, boxY + 30);
        ctx.fillText("CLICK TO REPORT CONTACT", boxX + 5, boxY + 45);
        ctx.fillText("X TO DISMISS, Q TO FIRE SPREAD", boxX + 5, boxY + 60);
      }
      
      contains(mouseX, mouseY) {
        // Determine box position
        const boxWidth = 180;
        const boxHeight = 75; // TODO: Make boxWidth and boxHeight not exist both here and in draw() separately in order to make it easier to change
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        return mouseX >= boxX && mouseX <= boxX + boxWidth && 
               mouseY >= boxY && mouseY <= boxY + boxHeight;
      }
    }

    // Contact class definition
    class Contact {
      constructor(bearing, distance, size, movementSpeed, directionChangeFrequency, movementDirection, 
                  visible, opacity, emittingRadiation, emissionDetectionChance, 
                  radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
                  iffBroadcasting, iffString, contactColor, contactType, numMissilesLoaded) {
        // Affects displayed position
        this.bearing = bearing;
        this.distance = distance;
        this.size = size;
        
        // Affects real position for sim (moves independently of the displayed blip)
        this.realBearing = bearing;
        this.realDistance = distance;
        
        // Movement parameters for sim (now per second rather than per frame)
        this.movementSpeed = movementSpeed;
        this.directionChangeFrequency = directionChangeFrequency;
        this.movementDirection = movementDirection;
        this.directionChangeCounter = 0;
        
        // Visibility properties for contact blip
        this.visible = visible;
        this.opacity = opacity;
        this.fadeSpeed = 0.6; // fade per second

        // ELINT detection properties
        this.emittingRadiation = emittingRadiation;
        this.emissionDetectionChance = emissionDetectionChance;
        this.radiationDetected = false;
        this.radiationDetectionDuration = 0;
        
        // Radar detection properties
        this.radarDetectable = radarDetectable;
        this.radarDetectionChance = radarDetectionChance;
        this.lastDetectedTime = null;

        // Thermal detection properties
        this.thermalDetectable = thermalDetectable;
        this.thermalDetectionChance = thermalDetectionChance;

        // IFF (Identification Friend or Foe) properties
        this.iffBroadcasting = iffBroadcasting;
        this.iffString = iffString;
        this.contactColor = contactColor;

        // How many missiles are aboard the ship
        this.numMissiles = numMissilesLoaded;

        // Currently, there are five types of contacts: "FRIENDLY", "HOSTILE", "NEUTRAL", "GHOST", and "PLAYER"
        // Anything else is treated as "GHOST"
        if (acceptedTypes.includes(contactType)) {
          this.contactType = contactType;
        } else {
          this.contactType = "GHOST";
        }
        // Ghosts must not be thermally detectable
        if (this.contactType === "GHOST") {
          this.thermalDetectable = false;
        }
      }
      
      updatePosition(deltaTime) {
        // Randomly change direction occasionally, now based on elapsed time
        this.directionChangeCounter += deltaTime;
        if (this.directionChangeCounter > (1 / this.directionChangeFrequency)) {
          this.movementDirection += (Math.random() - 0.5) * Math.PI / 2; // Change by up to +/-45 degrees
          this.directionChangeCounter = 0;
        }
        
        // Convert polar movement to cartesian
        let dx = Math.cos(this.movementDirection) * this.movementSpeed * deltaTime;
        let dy = Math.sin(this.movementDirection) * this.movementSpeed * deltaTime;
        
        // Convert contact position from polar to cartesian
        let contactX = Math.cos(this.realBearing) * this.realDistance;
        let contactY = Math.sin(this.realBearing) * this.realDistance;
        
        // Update position
        contactX += dx;
        contactY += dy;
        
        // Convert back to polar coordinates
        this.realDistance = Math.sqrt(contactX * contactX + contactY * contactY);
        this.realBearing = Math.atan2(contactY, contactX);
        
        // Keep contact within radar bounds
        if (this.realDistance > radius * 0.95) {
          // If near edge, bounce back, unless a missile, in which case it should self-destruct
          if (this.isMissile) {
            // Create explosion effect
            createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                           centerY + this.realDistance * Math.sin(this.realBearing));
            
            // Remove from contacts array
            const index = contacts.indexOf(this);
            if (index > -1) {
              contacts.splice(index, 1);
            }
            return;
          }
          this.movementDirection = Math.atan2(-contactY, -contactX);
          this.realDistance = radius * 0.95;
        } else if (this.realDistance < 0) {
          // If somehow at a negative distance, reset to 0
          this.realDistance = 0;
        }
        
        // Check for radiation detection
        this.checkRadiationDetection(deltaTime);
        
        // Decrease radiation detection duration
        if (this.radiationDetected) {
          this.radiationDetectionDuration -= deltaTime;
          if (this.radiationDetectionDuration <= 0) {
            this.radiationDetected = false;
          }
        }
      }
      
      checkRadiationDetection(deltaTime) {
        // Adjust chance based on time
        const timeAdjustedChance = this.emissionDetectionChance * deltaTime * detectionTimeMultiplier;
        
        if (this.emittingRadiation && Math.random() < timeAdjustedChance) {
          // Play a beep
          // Iterate through beeps to find one that is not currently playing
          for (let i = 0; i < numBeeps; i++) {
            if (elintBeeps[i].paused) {
              elintBeeps[i].play();
              break;
            }
          }

          this.radiationDetected = true;
          this.radiationDetectionDuration = 0.25; // Show for 0.25 second
        }
      }
      
      checkDetection(radarAngle, thermalScanAbsoluteAngle, thermalScanRadius, deltaTime) {
        // Check if radar is sweeping over the contact
        const angleDiff = Math.abs(normalizeAngle(radarAngle - this.realBearing));
        let wasNewDetection = false;
        
        // Adjust chances based on time
        // If something has a 100% chance of being detected, it should be detected
        const timeAdjustedRadarChance = this.radarDetectionChance >= 1 ? 1 : this.radarDetectionChance * deltaTime * detectionTimeMultiplier;
        //const timeAdjustedThermalChance = this.thermalDetectionChance * deltaTime * detectionTimeMultiplier;
        const timeAdjustedThermalChance = this.thermalDetectionChance > 0 ? 1 : 0; // If something is thermal detectable, it should be detected
        
        if (angleDiff < 0.1 && this.radarDetectable && Math.random() < timeAdjustedRadarChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            // Play a ping
            const audio = new Audio("../assets/RadarPing.mp3");
            audio.play();
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const minutes = Math.floor(unpausedElapsedTimeMillis / 60000);
            const seconds = Math.floor((unpausedElapsedTimeMillis % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "RADAR", this));
          }
        }
        
        // Check if thermal scan is over the contact
        const thermalDiff = Math.abs(normalizeAngle(thermalScanAbsoluteAngle - this.realBearing));
        
        if (thermalDiff < 0.1 && this.realDistance < thermalScanRadius && 
            this.thermalDetectable && Math.random() < timeAdjustedThermalChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const minutes = Math.floor(unpausedElapsedTimeMillis / 60000);
            const seconds = Math.floor((unpausedElapsedTimeMillis % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "THERMAL", this));
          }
        }
      }

      // Launch a missile along a given bearing
      launchMissileAlongAngle(targetBearing, missileFuelTime, missileArmingTime, missileMovementSpeed) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          // General idea: Create a unit circle around this contact, then create a contact at the 
          // corresponding point on the circle with the matching bearing.

          // Figure out the polar coordinates of a point on the unit circle with angle targetBearing
          const targetX = Math.cos(targetBearing);
          const targetY = Math.sin(targetBearing);

          // Center the unit circle around the launcher's position
          const missileX = Math.cos(this.realBearing) * this.realDistance;
          const missileY = Math.sin(this.realBearing) * this.realDistance;

          // Figure out the actual position in the game world that the missile is being launched towards
          const trueTargetX = missileX + targetX;
          const trueTargetY = missileY + targetY;

          // Convert back to polar coordinates
          const targetContactBearing = Math.atan2(trueTargetY, trueTargetX);
          const targetContactDistance = Math.sqrt(trueTargetX * trueTargetX + trueTargetY * trueTargetY);

          // Create a new contact that just gives a bearing and unit distance
          // to tell the missile what direction to aim in
          // If this is not done, then missiles launched will not know
          // which direction to go in. They will only know where to spawn.
          let targetContact = new Contact(targetContactBearing, targetContactDistance);

          // Set the missile's contact type to match whoever launched it, unless the contact is a player
          // Set it to friendly in that latter case
          let contactType = this.contactType;
          if (this.contactType === "PLAYER") {
            contactType = "FRIENDLY";
          }
          const missile = new MissileContact(this.realBearing, this.realDistance, targetContact, missileFuelTime, contactType, missileArmingTime, missileMovementSpeed);
          contacts.push(missile);

          // Reduce the number of missiles available if applicable
          if (this.numMissiles !== undefined && this.numMissiles !== null) {
            this.numMissiles--;
          }
        } 
      }

      // Launch a missile at the given position (Requires target contact just to tell the missile who it's initially targeting)
      launchMissileAtPoint(targetX, targetY, missileFuelTime, missileArmingTime, missileMovementSpeed) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          
          // Figure out the angle of the line which points from this contact to the target
          // Convert contact position from polar to Cartesian
          const contactX = Math.cos(this.realBearing) * this.realDistance;
          const contactY = Math.sin(this.realBearing) * this.realDistance;

          // Calculate angle from contact to target
          const targetAngle = Math.atan2(targetY - contactY, targetX - contactX);

          // Delegate to launchMissileAlongAngle with the target angle
          this.launchMissileAlongAngle(targetAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
        }
      }

      // Launch a missile at the given contact
      launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed, isSpreadAttack) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          // Basic idea: We have four parametric equations, two for the target's position as a function
          // of time, and two for the missile's position as a function of time. 
          // The missile position in x is given by
          //
          // missileX(t) = t * missileVelocityX + missileX(0)    <-- missileX(0) is the initial x position of the missile, so in this case, the launcher's x position
          //
          // The missile position in y is given by
          //
          // missileY(t) = t * missileVelocityY + missileY(0)  <-- missileY(0) is the initial y position of the missile, so in this case, the launcher's y position
          //
          // The target position in x is given by
          //
          // targetX(t) = t * targetVelocityX + targetX(0)  <-- targetX(0) is the initial x position of the target contact, so in this case, its current x position
          //
          // The target position in y is given by
          //
          // targetY(t) = t * targetVelocityY + targetY(0)  <-- targetY(0) is the initial y position of the target contact, so in this case, its current y position
          //
          // We want all four quantities to equal, so we arrive at a system of two equations:
          //
          // missileX(t) = targetX(t) && missileY(t) = targetY(t)
          //
          // We actually have two unknowns. Time is of course one of them, but the other is the angle at which we must launch the missile to collide with the target.
          // It is this quantity we are interested in. We know that launch angle is actually a part of the missile's velocity vector, so we can write
          //
          // missileVelocityX = missileSpeed * cos(missileLaunchAngle) && missileVelocityY = missileSpeed * sin(missileLaunchAngle)
          //
          // We then substitute these into the system of equations, and solve for time and missileLaunchAngle. 
          // It is somewhat challenging to solve this, but by using a symbolic algebra system like the one used by Wolfram Mathematica, we get that there
          // are actually two solutions for both time and angle. We will look at both solutions and chooose which, if any, is the correct one to use.
          // For instance, if angle or time are undefined or infinite, we know that something is wrong with that solution, likely because none is possible.
          // This could happen in a case where we're shooting at something going away faster than we can catch up to it, for instance.
          // Moreover, if time is negative, then our window of opportunity has already passed, and we should not launch the missile using the given solution.
          // Those interested in the derivation of this equation for themselves should be familiar with solutions of equations of the form 
          //
          // sin(x) + b cos(x) = c for real valued constants b and c

          // Time, angle equations 1.
          // These symbols correspond to these quantities:
          // evx - Enemy velocity x
          // evy - Enemy velocity y
          // mxi - Missile initial x position
          // myi - Missile initial y position
          // exi - Enemy initial x position
          // eyi - Enemy initial y position
          // mspeed - Missile speed
          // t - Time
          // a - Angle

          // In Mathematica code, solution pair 1 is given by
          // t=1/(evx^2+evy^2-mspeed^2) (-evx  exi-evy  eyi+evx  mxi+evy  myi-1/2  \[Sqrt](4  (evx (exi-mxi)+evy (eyi-myi))^2-4  (evx^2+evy^2-mspeed^2)  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))
          // a=ArcTan[(-evy  (exi-mxi)  (eyi-myi)+evx  (eyi-myi)^2+(exi-mxi)  \[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)),(evy  (exi-mxi+(eyi-myi)  (-evx  exi+evx  mxi+\[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))]
          
          // In Mathematica code, solution pair 2 is given by
          // t=1/(evx^2+evy^2-mspeed^2) (-evx  exi-evy  eyi+evx  mxi+evy  myi+1/2  \[Sqrt](4  (evx (exi-mxi)+evy (eyi-myi))^2-4  (evx^2+evy^2-mspeed^2)  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))
          // a=ArcTan[(-evy  (exi-mxi)  (eyi-myi)+evx  (eyi-myi)^2+(-exi+mxi)  \[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)),(evy  (exi-mxi)^2-(eyi-myi)  (evx  exi-evx  mxi+\[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))]

          // Convert both contacts' polar coordinates to Cartesian
          // For the missile launcher (this contact)
          const mxi = Math.cos(this.realBearing) * this.realDistance; // Missile initial x
          const myi = Math.sin(this.realBearing) * this.realDistance; // Missile initial y
          
          // For the target
          const exi = Math.cos(targetContact.realBearing) * targetContact.realDistance; // Enemy initial x
          const eyi = Math.sin(targetContact.realBearing) * targetContact.realDistance; // Enemy initial y
          
          // Calculate enemy velocity components
          const evx = Math.cos(targetContact.movementDirection) * targetContact.movementSpeed; // Enemy velocity x
          const evy = Math.sin(targetContact.movementDirection) * targetContact.movementSpeed; // Enemy velocity y
          
          // Missile speed
          const mspeed = missileMovementSpeed;
          
          // Calculate values needed for the formulas
          const dx = exi - mxi;
          const dy = eyi - myi;
          const distSquared = dx*dx + dy*dy;

          // We first check to see if we're firing at a ghost
          if (targetContact.contactType === "GHOST") {
            // If we're firing at a ghost, launch directly at ghost's last sighted position
            // Looks odd otherwise (Why is my missile going to this random position this game is buggy!!!)

            // Handle firing a spread as well
            if (isSpreadAttack) {
              // Check if the player ship is the launcher
              // and if firedFirstSpread is false
              // If so, write dialogue 
              if(this.contactType === "PLAYER" && !firedFirstSpread) {
                addDialogue("Captain: Gunnery control, you heard the engineer. Fire a spread at that contact!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                firedFirstSpread = true;
              }

              // Calculate distance in radius units
              const distance = Math.sqrt(distSquared);
               
              // Calculate number of missiles based on distance
              // Add 1 missile for every spreadAttackMissilePerRadiusAmount * radius
              let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
               
              // Set minimum and maximum number of missiles
              numMissiles = Math.max(2, numMissiles);
               
              // Calculate increased arming time (0.5 seconds per missile)
              const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);

              // Figure out angle between this contact and the target contact
              const selectedAngle = Math.atan2(dy, dx);
               
              // Launch a spread of missiles
              const spreadAngle = Math.PI / 6; // 30 degrees
              for (let i = 0; i < numMissiles; i++) {
                const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              }
               
              // Launch one more missile directly at the target
              this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              return;
            }

            this.launchMissileAtPoint(targetContact.distance * Math.cos(targetContact.bearing), targetContact.distance * Math.sin(targetContact.bearing), missileFuelTime, missileArmingTime, missileMovementSpeed);
            return;
          }
          
          // Check if player tried to fire spread at missile (moved up to check in all cases)
          if (this.contactType === "PLAYER" && targetContact.isMissile && isSpreadAttack) {
            if (!firedSpreadAtMissile) {
              addDialogue("Captain: Gunnery control, belay that order! That's a missile, don't waste a spread! Sensors, you should have known better!", captainColor, defaultDialogueTime, captainPortraitFilePath);
            }
            firedSpreadAtMissile = true;
            // Continue with normal single missile firing
            isSpreadAttack = false;
          }
          
          // Calculate the determinant inside the square root
          const determinant = 4 * Math.pow(evx*dx + evy*dy, 2) - 
                              4 * (evx*evx + evy*evy - mspeed*mspeed) * distSquared;
          
          // Only proceed if the determinant is positive (solutions exist)
          if (determinant >= 0) {
            // Calculate solutions for time
            const t1 = 1/(evx*evx + evy*evy - mspeed*mspeed) * 
                     (-evx*exi - evy*eyi + evx*mxi + evy*myi - 0.5 * Math.sqrt(determinant));
            
            const t2 = 1/(evx*evx + evy*evy - mspeed*mspeed) * 
                     (-evx*exi - evy*eyi + evx*mxi + evy*myi + 0.5 * Math.sqrt(determinant));
            
            // Calculate the square root term for angle calculations
            const sqrtTerm = Math.sqrt(-evy*evy*dx*dx + 
                                       2*evx*evy*dx*dy - 
                                       evx*evx*dy*dy + 
                                       mspeed*mspeed*distSquared);
            
            // Calculate angles for both solutions
            const a1x = (-evy*dx*dy + evx*dy*dy + dx*sqrtTerm) / (mspeed*distSquared);
            const a1y = (evy*dx*dx + dy*(-evx*exi + evx*mxi + sqrtTerm)) / (mspeed*distSquared);
            const a1 = Math.atan2(a1y, a1x);
            
            const a2x = (-evy*dx*dy + evx*dy*dy - dx*sqrtTerm) / (mspeed*distSquared);
            const a2y = (evy*dx*dx - dy*(evx*exi - evx*mxi + sqrtTerm)) / (mspeed*distSquared);
            const a2 = Math.atan2(a2y, a2x);
            
            // Choose the best solution (positive time, earliest intercept)
            let selectedTime = null;
            let selectedAngle = null;
            
            if (t1 > 0 && (selectedTime === null || t1 < selectedTime)) {
              selectedTime = t1;
              selectedAngle = a1;
            }
            
            if (t2 > 0 && (selectedTime === null || t2 < selectedTime)) {
              selectedTime = t2;
              selectedAngle = a2;
            }

            // If selected time is greater than missile fuel time, reset selected time to null
            if (selectedTime > missileFuelTime) {
              selectedTime = null;
            } 

            // If we found a valid solution, launch the missile
            if (selectedTime !== null) {
              // this.launchMissileAlongAngle(selectedAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
              // If isSpreadAttack, instead fire a spread of missiles at the target and its immediate surroundings
              // Only do this if firing at a non-missile contact
              if (isSpreadAttack && !targetContact.isMissile) {
                // Check if the player ship is the launcher
                // and if firedFirstSpread is false
                // If so, write dialogue 
                if(this.contactType === "PLAYER" && !firedFirstSpread) {
                  addDialogue("Captain: Gunnery control, you heard the engineer. Fire a spread at that contact!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                  firedFirstSpread = true;
                }

                // Calculate distance in radius units
                const distance = Math.sqrt(distSquared);
                
                // Calculate number of missiles based on distance
                // Add 1 missile for every spreadAttackMissilePerRadiusAmount * radius
                let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                
                // Set minimum and maximum number of missiles
                numMissiles = Math.max(2, numMissiles);
                
                // Calculate increased arming time (0.5 seconds per missile)
                const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                
                // Launch a spread of missiles
                const spreadAngle = Math.PI / 6; // 30 degrees
                for (let i = 0; i < numMissiles; i++) {
                  const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                  this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                }
                
                // Launch one more missile directly at the target
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              } else {
                
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
              }
            } else {
              // No valid solution found, launch directly at current position as fallback
              
              // NPC ships will never fire a spread at invalid targets
              if (isSpreadAttack && this.contactType !== "PLAYER") {
                // Just fire a single missile to conserve ammo
                this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
              } else {
                // For player, allow them to mess up and fire a spread if that's what they requested
                if (this.contactType === "PLAYER" && isSpreadAttack) {
                  // Calculate spread as in normal spread code
                  const distance = Math.sqrt(distSquared);
                  let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                  numMissiles = Math.max(2, numMissiles);
                  const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                  
                  // Direct angle toward target's current position
                  const selectedAngle = Math.atan2(dy, dx);
                  
                  // Launch spread
                  const spreadAngle = Math.PI / 6; // 30 degrees
                  for (let i = 0; i < numMissiles; i++) {
                    const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                    this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                  }
                  
                  // Launch direct missile too
                  this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                } else {
                  // Just fire a single missile for non-spread or non-player
                  this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
                }
              }
            }
          } else {
            // No intercept solution exists, launch directly at current position
            
            // NPC ships will never fire a spread at invalid targets
            if (isSpreadAttack && this.contactType !== "PLAYER") {
              // Just fire a single missile to conserve ammo
              this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
            } else {
              // For player, allow them to mess up and fire a spread if that's what they requested
              if (this.contactType === "PLAYER" && isSpreadAttack) {
                // Calculate spread as in normal spread code
                const distance = Math.sqrt(distSquared);
                let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                numMissiles = Math.max(2, numMissiles);
                const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                
                // Direct angle toward target's current position
                const selectedAngle = Math.atan2(dy, dx);
                
                // Launch spread
                const spreadAngle = Math.PI / 6; // 30 degrees
                for (let i = 0; i < numMissiles; i++) {
                  const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                  this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                }
                
                // Launch direct missile too
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              } else {
                // Just fire a single missile for non-spread or non-player
                this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
              }
            }
          }
        }
      }
      
      draw(deltaTime) {
        // If IFF is broadcasting, the contact should always be visible and updating its contact position
        if (this.iffBroadcasting) {
          this.visible = true;
          this.opacity = 1.0;
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
        }

        if (this.visible) {
          // Draw the contact at the last detected position
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          ctx.beginPath();
          ctx.arc(contactX, contactY, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${this.contactColor[0]}, ${this.contactColor[1]}, ${this.contactColor[2]}, ${this.opacity})`;
          ctx.fill();
          
          // Draw IFF bubble if broadcasting and mouse is nearby
          if (this.iffBroadcasting && typeof mouseX !== 'undefined' && typeof mouseY !== 'undefined') {
            // Calculate distance from mouse to contact
            const dx = mouseX - contactX;
            const dy = mouseY - contactY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate opacity based on distance (fully visible when close, fades out as distance increases)
            const iffOpacity = Math.max(0, 1 - (distance / iffBoxDisplayDistance));
            
            // Only draw if opacity > 0
            if (iffOpacity > 0) {
              // Draw IFF bubble
              const bubblePadding = 10;
              const lines = this.iffString.split('\n');
              const lineHeight = 16;
              const bubbleWidth = lines.reduce((max, line) => Math.max(max, ctx.measureText(line).width), 0) + (bubblePadding * 2);
              var bubbleHeight = ((lines.length + 1) * lineHeight) + (bubblePadding * 2); // Add 1 for the missile count line
              
              // Add extra height for missile count if it exists
              const hasMissiles = this.numMissiles !== undefined && this.numMissiles !== null;
              if (hasMissiles) {
                bubbleHeight += lineHeight;
              }
              
              // Calculate box position - default is to the right of the contact
              let boxX = contactX + 15;
              let boxY = contactY - 10;
              
              // Adjust if the box would go off the right edge of the canvas
              if (boxX + bubbleWidth > width) {
                boxX = contactX - bubbleWidth - 15; // Move to the left of the contact
              }
              
              // Adjust if the box would go off the top or bottom of the canvas
              if (boxY < 0) {
                boxY = 0; // Align with top of canvas
              } else if (boxY + bubbleHeight > height) {
                boxY = height - bubbleHeight; // Align with bottom of canvas
              }
              
              // Draw bubble background
              ctx.fillStyle = `rgba(0, 0, 0, ${iffOpacity * 0.7})`;
              ctx.fillRect(boxX, boxY, bubbleWidth, bubbleHeight);
              ctx.strokeStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.strokeRect(boxX, boxY, bubbleWidth, bubbleHeight);
              
              // Draw IFF string
              ctx.fillStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.font = "12px monospace";
              ctx.textAlign = "left";
              lines.forEach((line, i) => {
                ctx.fillText(line, boxX + bubblePadding, boxY + 15 + (i * lineHeight));
              });
              
              // Draw IFF status
              // ctx.fillStyle = `rgba(0, 255, 0, ${iffOpacity})`;
              // Frienly contacts have a green IFF broadcast, hostile contacts have a red IFF broadcast
              // Neutral contacts have a yellow IFF broadcast. Ghosts should not have an IFF broadcast but if they do, it should be white
              if (this.contactType === "FRIENDLY" || this.contactType === "PLAYER") {
                ctx.fillStyle = `rgba(0, 255, 0, ${iffOpacity})`;
              } else if (this.contactType === "HOSTILE") {
                ctx.fillStyle = `rgba(255, 0, 0, ${iffOpacity})`;
              } else if (this.contactType === "NEUTRAL") {
                ctx.fillStyle = `rgba(255, 255, 0, ${iffOpacity})`;
              } else {
                ctx.fillStyle = `rgba(255, 255, 255, ${iffOpacity})`;
              }
              ctx.fillText("IFF: BROADCASTING", boxX + bubblePadding, boxY + 15 + (lines.length * lineHeight));
              
              // Show missile count if available
              if (hasMissiles) {
                ctx.fillText(`MISSILES: ${this.numMissiles}`, boxX + bubblePadding, boxY + 15 + ((lines.length + 1) * lineHeight));
              }
            }
          }
          
          // Fade out the contact - now based on time
          this.opacity -= this.fadeSpeed * deltaTime;
          if (this.opacity <= 0) {
            this.visible = false;
          }
        }
        
        // Draw ELINT radiation cone if detected
        if (this.radiationDetected) {
          const startAngle = this.realBearing - ELINTHalfAngle;
          const endAngle = this.realBearing + ELINTHalfAngle;
          
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, startAngle, endAngle);
          ctx.lineTo(centerX, centerY);
          ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
          ctx.fill();
          
          // Draw the ELINT cone boundary lines
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(startAngle), 
            centerY + radius * Math.sin(startAngle)
          );
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(endAngle), 
            centerY + radius * Math.sin(endAngle)
          );
          ctx.strokeStyle = "#FFFF00";
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
    }

    // Extend Contacts to add heat seeking missiles
    class MissileContact extends Contact {
      constructor(bearing, distance, targetContact, fuelTime, contactType, armingTime, movementSpeed = 10) {
        // If the contact type is not one of the accepted types, default to "HOSTILE"
        if (!acceptedTypes.includes(contactType)) {
          contactType = "HOSTILE";
        }
        // Figure out the movement direction based on the target contact and the current bearing and distance
        // We are at (bearing, distance) and the target is at (targetContact.bearing, targetContact.distance), in polar coordinates
        // We want to move towards the target, so we need to calculate the angle between the two points
        // This is done by calculating the angle between the two points in cartesian coordinates and then converting it to polar coordinates
        // Figure out our position in cartesian coordinates
        const missileX = Math.cos(bearing) * distance;
        const missileY = Math.sin(bearing) * distance;
        // Figure out the target position in cartesian coordinates
        // so long as the target contact is not null or undefined or something like that
        if (targetContact) {
          var targetXv = Math.cos(targetContact.bearing) * targetContact.distance;
          var targetYv = Math.sin(targetContact.bearing) * targetContact.distance;
        } else {
          // If the target contact is null or undefined, default to the point at the radius and bearing
          var targetXv = Math.cos(bearing) * radius;
          var targetYv = Math.sin(bearing) * radius;
        }
        const targetX = targetXv;
        const targetY = targetYv;
        // Calculate the angle to the target
        const targetAngle = Math.atan2(targetY - missileY, targetX - missileX);

        // If the contact is friendly, create it like so
        if (contactType === "FRIENDLY") {
          // Create a friendly missile
          super(
            bearing, distance, 3, // bearing, starting distance, size
            movementSpeed, 0, targetAngle, // movementSpeed (fast enough to catch just about anything else), directionChangeFrequency (none as it should go only in one direction), movementDirection (direction of the target)
            true, 1.0, true, 1, // visible, opacity, immense radiation emission "due to really powerful engine" or something like that
            true, 1.0, true, 1.0, // fully radar and thermal detectable
            true, "HEAT SEEKING MISSILE\nACTIVE GUIDANCE\nFRIENDLY FIRE", [255, 0, 255], // IFF broadcasting
            contactType // Contact type
          );
        } else {
          // Create a hostile missile
          super(
            bearing, distance, 3, // bearing, starting distance, size
            movementSpeed, 0, targetAngle, // movementSpeed (fast enough to catch just about anything else), directionChangeFrequency (none as it should go only in one direction), movementDirection 
            false, 0, true, 1, // visible, opacity, immense radiation emission "due to really powerful engine" or something like that
            true, 1.0, true, 1.0, // fully radar and thermal detectable
            false, "", [255, 0, 0], // IFF broadcasting
            contactType // Contact type
          );
        }
        
        this.isMissile = true;
        this.targetContact = targetContact;
        this.thermalScanRadius = missileScanRadius;
        this.hasTarget = false;
        
        // Add fuel time property (in seconds)
        this.fuelTime = fuelTime; // Keeps track of original fuel time
        this.fuelRemaining = fuelTime;
        
        // Missile scan properties
        this.scanWidth = missileScanWidth; // Use the same width as the main scanner
        this.scanAngle = 0; // Current scan offset angle
        this.scanReversed = false; // Direction of scan
        this.scanCenter = 0; // Scan is centered forward of the missile

        // Arming time - Missile will not trigger collision check/explosion until armed
        this.armingTime = armingTime;

        // // debug
        // this.positionHistoryString = "Time = 0: " + centerX + ", " + centerY + "\n";
        // this.positionHistory = [{x: centerX, y: centerY, time: 0}];
      }
      
      updatePosition(deltaTime) {
        // debug
        // // get previous time
        // const prevTime = this.positionHistory[this.positionHistory.length - 1].time;
        // this.positionHistoryString += "Time = " + deltaTime + prevTime + ": " + this.realDistance * Math.cos(this.realBearing) + centerX + ", " + this.realDistance * Math.sin(this.realBearing) + centerY + "\n";
        // this.positionHistory.push({x: this.realDistance * Math.cos(this.realBearing) + centerX, y: this.realDistance * Math.sin(this.realBearing) + centerY, time: deltaTime + prevTime});

        // If not armed, count down arming time
        if (this.armingTime > 0) {
          this.armingTime -= deltaTime;
        }

        // Update fuel remaining
        this.fuelRemaining -= deltaTime;
        
        // Self-destruct if out of fuel
        if (this.fuelRemaining <= 0) {
          // Create explosion effect
          createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                         centerY + this.realDistance * Math.sin(this.realBearing));
          
          // Remove from contacts array
          const index = contacts.indexOf(this);
          if (index > -1) {
            contacts.splice(index, 1);
          }
          return;
        }
        
        // Update scan angle
        if (this.scanReversed) {
          this.scanAngle -= (Math.PI * missileScanSpeed / 180) * deltaTime;
          if (this.scanAngle <= -this.scanWidth/2) {
            this.scanAngle = -this.scanWidth/2;
            this.scanReversed = false;
          }
        } else {
          this.scanAngle += (Math.PI * missileScanSpeed / 180) * deltaTime;
          if (this.scanAngle >= this.scanWidth/2) {
            this.scanAngle = this.scanWidth/2;
            this.scanReversed = true;
          }
        }
        
        // Scan for thermal contacts if no target yet and armed 
        if (!this.hasTarget && this.armingTime <= 0) {
          // Use the missile's movement direction as its orientation.
          const missileOrientation = this.movementDirection;
          const absoluteScanAngle = missileOrientation + this.scanAngle;
          
          // Look for contacts in thermal scan range
          for (let contact of contacts) {
            if (contact === this) continue; // Skip self
            
            // Determine missile and contact positions in cartesian coordinates
            const missileX = centerX + this.realDistance * Math.cos(this.realBearing);
            const missileY = centerY + this.realDistance * Math.sin(this.realBearing);
            const contactX = centerX + contact.realDistance * Math.cos(contact.realBearing);
            const contactY = centerY + contact.realDistance * Math.sin(contact.realBearing);
            
            // Calculate position difference and distance
            const dx = contactX - missileX;
            const dy = contactY - missileY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate angle to contact relative to the missile's orientation
            const angleToContact = Math.atan2(dy, dx);
            const angleDiff = normalizeAngle(angleToContact - missileOrientation);
            
            // Check if contact is within scan arc and radius
            if (distance < this.thermalScanRadius &&
                Math.abs(angleDiff - this.scanAngle) < 0.1 &&
                contact.thermalDetectable) {
              this.targetContact = contact;
              this.hasTarget = true;
              break;
            }
          }
        }
        
        // Update missile direction if it has a target
        if (this.hasTarget && this.targetContact && !this.targetContact.destroyed) {
          // Calculate direction to target
          const targetX = Math.cos(this.targetContact.realBearing) * this.targetContact.realDistance;
          const targetY = Math.sin(this.targetContact.realBearing) * this.targetContact.realDistance;
          const missileX = Math.cos(this.realBearing) * this.realDistance;
          const missileY = Math.sin(this.realBearing) * this.realDistance;
          
          // Set movement direction toward target
          this.movementDirection = Math.atan2(targetY - missileY, targetX - missileX);
        }
        
        // Call parent updatePosition
        super.updatePosition(deltaTime);
        
        // Check for collisions with contacts, but only if it has a target
        if (this.hasTarget) {
          this.checkCollisions();
        }
      }
      
      checkCollisions() {
        // Only check for collisions if armed
        if (this.armingTime > 0) return;

        for (let i = 0; i < contacts.length; i++) {
          const contact = contacts[i];
          if (contact === this) continue; // Skip self and other missiles
          
          // Calculate distance between missile and contact
          const dx = Math.cos(contact.realBearing) * contact.realDistance - Math.cos(this.realBearing) * this.realDistance;
          const dy = Math.sin(contact.realBearing) * contact.realDistance - Math.sin(this.realBearing) * this.realDistance;
          const distance = Math.sqrt(dx*dx + dy*dy);
          
          // If collision detected with a thermal detectable contact, destroy both
          if (distance < (this.size + contact.size) && contact.thermalDetectable) {
            // Mark both as destroyed
            this.destroyed = true;
            contact.destroyed = true;
            
            // Create explosion effect
            createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                           centerY + this.realDistance * Math.sin(this.realBearing));
            
            // Remove both from contacts array
            console.log("Missile collided with contact:", contact);
            console.log("Missile destroyed:", this);

            // Check if it was a friendly missile that collided with a hostile missile or a hostile missile that collided with a friendly missile
            // Also ensure this dialogue only plays once using shotDownFirstMissile
            if ((this.isMissile && this.contactType === "FRIENDLY" && contact.isMissile && contact.contactType === "HOSTILE") ||
                (this.isMissile && this.contactType === "HOSTILE" && contact.isMissile && contact.contactType === "FRIENDLY")) {
              if (!shotDownFirstMissile) {
                addDialogue("Engineer: Enemy missile destroyed!", engineerColor);
                shotDownFirstMissile = true;
              }
            }

            contacts.splice(contacts.indexOf(this), 1);
            contacts.splice(contacts.indexOf(contact), 1);
            return;
          }
        }
      }
      
      draw(deltaTime) {
        // Draw the thermal scan cone if visible and friendly
        // Friendly contacts are "sending missile telemetry" to the player
        // Doesn't make sense for hostile or neutral contacts to do this
        if (this.visible && this.contactType === "FRIENDLY") {
          this.drawScanCone();
        }
        
        // Call parent draw method
        super.draw(deltaTime);
        
        // Draw fuel indicator if visible and friendly (see earlier comment about telemetry)
        if (this.visible && this.contactType === "FRIENDLY") {
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          // Draw fuel bar
          const barWidth = 20;
          const barHeight = 4;
          const fuelPercentage = this.fuelRemaining / this.fuelTime;
          
          // Draw fuel background
          ctx.fillStyle = "rgba(100, 100, 100, 0.7)";
          ctx.fillRect(contactX - barWidth/2, contactY + 8, barWidth, barHeight);
          
          // Draw remaining fuel - color changes as fuel depletes
          let fuelColor;
          if (fuelPercentage > 0.6) {
            fuelColor = "rgba(0, 255, 0, 0.7)"; // Green
          } else if (fuelPercentage > 0.3) {
            fuelColor = "rgba(255, 255, 0, 0.7)"; // Yellow
          } else {
            fuelColor = "rgba(255, 0, 0, 0.7)"; // Red
          }
          
          ctx.fillStyle = fuelColor;
          ctx.fillRect(contactX - barWidth/2, contactY + 8, barWidth * fuelPercentage, barHeight);
          
          // Update IFF string with fuel information
          const fuelSeconds = Math.round(this.fuelRemaining);
          this.iffString = `HEAT SEEKING MISSILE\nACTIVE GUIDANCE\nFUEL: ${fuelSeconds}s REMAINING`;
        }
      }
      
      drawScanCone() {
        // Calculate position on screen
        const missileX = centerX + this.realDistance * Math.cos(this.realBearing);
        const missileY = centerY + this.realDistance * Math.sin(this.realBearing);
        
        // Calculate orientation of missile (direction of movement)
        const missileOrientation = this.movementDirection;
        
        // Calculate start and end angles for the scan cone
        const absoluteScanAngle = missileOrientation + this.scanAngle;
        const startAngle = missileOrientation + this.scanCenter - this.scanWidth/2;
        const endAngle = missileOrientation + this.scanCenter + this.scanWidth/2;
        
        // Draw the thermal scan area
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.arc(missileX, missileY, this.thermalScanRadius, startAngle, endAngle);
        ctx.lineTo(missileX, missileY);
        ctx.fillStyle = "rgba(0, 0, 255, 0.2)"; // Thermal blue for missile scan
        ctx.fill();
        
        // Draw the thermal scan boundary lines
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(startAngle), 
          missileY + this.thermalScanRadius * Math.sin(startAngle)
        );
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(endAngle), 
          missileY + this.thermalScanRadius * Math.sin(endAngle)
        );
        ctx.strokeStyle = "#0000FF"; // Blue outline
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw the active scan line
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(absoluteScanAngle), 
          missileY + this.thermalScanRadius * Math.sin(absoluteScanAngle)
        );
        ctx.strokeStyle = "#0000FF"; // Blue
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    function drawBackground(deltaTime) {
      // Draw fading overlay - fade rate now per second
      ctx.fillStyle = `rgba(0, 0, 0, ${fadeRate * deltaTime})`;
      ctx.fillRect(0, 0, width, height);
      
      // Draw radar circle
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.strokeStyle = "#00AA00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw grid lines
      drawGrid();
    }
    
    function drawGrid() {
      // Draw crosshairs
      ctx.beginPath();
      ctx.moveTo(centerX - radius, centerY);
      ctx.lineTo(centerX + radius, centerY);
      ctx.moveTo(centerX, centerY - radius);
      ctx.lineTo(centerX, centerY + radius);
      ctx.strokeStyle = "#004400";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw concentric circles with range readouts
      const rangeLabels = ["0.25ls", "0.5ls", "0.75ls", "1ls"];
      
      for (let i = 1; i <= 4; i++) {
        const circleRadius = radius * i/4;
        // Draw the circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = "#004400";
        ctx.stroke();
        
        // Draw the range readout at the top of each circle
        ctx.fillStyle = "#00FF00";
        ctx.font = "12px monospace";
        ctx.textAlign = "center";
        ctx.fillText(rangeLabels[i-1], centerX, centerY - circleRadius);
      }
    }
    
    function drawRadarLine() {
      // Calculate the endpoint of the rotating line
      const endX = centerX + radius * Math.cos(angle);
      const endY = centerY + radius * Math.sin(angle);

      // Draw the rotating line
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw radar sweep (the glow effect)
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0, 
        centerX, centerY, radius
      );
      gradient.addColorStop(0, "rgba(0, 255, 0, 0.2)");
      gradient.addColorStop(1, "rgba(0, 255, 0, 0)");
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, angle - 0.2, angle, false);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
    
    function drawThermalScan() {
      // Draw the thermal scan zone
      const startAngle = thermalScanCenter - thermalScanWidth/2;
      const endAngle = thermalScanCenter + thermalScanWidth/2;
      
      // Draw the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, thermalScanRadius, startAngle, endAngle);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = "rgba(0, 0, 255, 0.2)";
      ctx.fill();
      
      // Draw the thermal scan boundary lines
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(startAngle), 
                 centerY + thermalScanRadius * Math.sin(startAngle));
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(endAngle), 
                 centerY + thermalScanRadius * Math.sin(endAngle));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw a line sweeping across the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(thermalScanAngle + thermalScanCenter), 
                 centerY + thermalScanRadius * Math.sin(thermalScanAngle + thermalScanCenter));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // For drawing how many missiles are left in stock on the player ship
    // Draws in the top left corner of the screen
    function drawCurrentMissiles() {
      const playerContact = contacts[0]; // Assuming the player ship is the first contact

      if (playerContact && playerContact.visible && playerContact.numMissiles !== undefined) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(10, 10, 150, 50);
        
        ctx.fillStyle = "#00FF00";
        ctx.font = "20px monospace";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText(`MISSILES: ${playerContact.numMissiles}`, 20, 20);
      }

    }

    // Function to add a new dialogue message
    function addDialogue(text, color, duration = defaultDialogueTime, imageFilePath) {
      // Add the message to the array with current time + duration as expiry time
      dialogueMessages.push({
      text: text,
      color: color,
      expiryTime: Date.now() + (duration * 1000), // Multiply by 1000 to convert to milliseconds
      image: imageFilePath
      });
    }

    // Function to draw dialogue messages in the top right corner
    function drawDialogue() {
      const currentTime = Date.now();
      
      // If no messages or all messages expired, don't draw anything
      if (dialogueMessages.length === 0 || dialogueMessages[dialogueMessages.length - 1].expiryTime < currentTime) {
        return;
      }
      
      const maxWidth = 375;
      const padding = 15;
      const lineHeight = 20;
      let currentY = 10; // Start at the top
      
      // Image dimensions
      const imageWidth = 80;
      const imageHeight = 120;
      
      // Draw messages from newest to oldest
      for (let i = dialogueMessages.length - 1; i >= 0; i--) {
        const message = dialogueMessages[i];
        
        // Skip expired messages
        if (message.expiryTime < currentTime) {
          continue;
        }
        
        // Split text into lines for wrapping
        const words = message.text.split(' ');
        let lines = [];
        let currentLine = words.length > 0 ? words[0] : '';
        
        ctx.font = "16px Arial";
        
        // Create wrapped lines
        for (let j = 1; j < words.length; j++) {
          const testLine = currentLine + ' ' + words[j];
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth) {
            lines.push(currentLine);
            currentLine = words[j];
          } else {
            currentLine = testLine;
          }
        }
        lines.push(currentLine);
        
        // Calculate box dimensions based on whether there's an image
        // Has image is true if the image property is defined.
        const hasImage = message.image !== undefined && message.image !== null && message.image !== "" ;
        const boxWidth = maxWidth + (padding * 2) + (hasImage ? imageWidth + padding : 0);
        const boxHeight = Math.max((lines.length * lineHeight) + (padding * 2), hasImage ? imageHeight + (padding * 2) : 0);
        
        // Check if we're going off-screen and need to stop drawing
        if (currentY + boxHeight > height) {
          break;
        }
        
        const boxX = width - boxWidth - 10;
        const boxY = currentY;
        
        // Draw the background box
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Draw the image if specified
        if (hasImage) {
          // If image hasn't been loaded yet, create and cache it
          if (!message.imageObject) {
            message.imageObject = new Image();
            message.imageObject.src = message.image;
          }
          
          // Position image inside the box with some padding
          const imgX = boxX + padding;
          const imgY = boxY + (boxHeight - imageHeight) / 2; // Center vertically
          
          // Only draw if the image is loaded
          if (message.imageObject.complete && message.imageObject.naturalWidth > 0) {
            ctx.drawImage(message.imageObject, imgX, imgY, imageWidth, imageHeight);
          }
        }
        
        // Draw the text - right aligned if no image, left aligned if there is an image
        ctx.fillStyle = message.color;
        ctx.textAlign = hasImage ? "left" : "right";
        ctx.textBaseline = "top";
        
        // Calculate text position
        const textX = hasImage 
          ? boxX + imageWidth + (padding * 2) // If image, position text after image
          : boxX + boxWidth - padding; // If no image, position from right edge
        
        const textY = boxY + (hasImage 
          ? (boxHeight - (lines.length * lineHeight)) / 2 // Center text vertically if there's an image
          : padding); // Default padding if no image
        
        lines.forEach((line, index) => {
          ctx.fillText(line, textX, textY + (index * lineHeight));
        });
        
        // Update Y position for next message
        currentY += boxHeight + 5; // 5px gap between boxes
      }
    }

    // Variables for message history
    let isViewingMessageHistory = false;
    let messageHistoryScrollPosition = 0;
    
    // Function to draw message history window
    function drawMessageHistory() {
      // Clear the screen with a dark background
      ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
      ctx.fillRect(0, 0, width, height);
      
      // Calculate window dimensions
      const margin = 50;
      const windowWidth = width - (margin * 2);
      const windowHeight = height - (margin * 2);
      
      // Draw window background
      ctx.fillStyle = "rgba(20, 20, 30, 0.8)";
      ctx.fillRect(margin, margin, windowWidth, windowHeight);
      ctx.strokeStyle = "rgba(0, 255, 255, 0.7)";
      ctx.lineWidth = 2;
      ctx.strokeRect(margin, margin, windowWidth, windowHeight);
      
      // Draw title
      ctx.font = "bold 24px Arial";
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText("MESSAGE HISTORY", centerX, margin + 20);
      
      // Draw navigation instructions
      ctx.font = "16px Arial";
      ctx.fillStyle = "#AAAAAA";
      ctx.fillText("Use UP/DOWN arrows to scroll, press H to return", centerX, margin + 50);
      
      // Draw divider line
      ctx.beginPath();
      ctx.moveTo(margin + 20, margin + 80);
      ctx.lineTo(margin + windowWidth - 20, margin + 80);
      ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Set up scrollable area
      const contentAreaTop = margin + 100;
      const contentAreaHeight = windowHeight - 120;
      const contentAreaBottom = contentAreaTop + contentAreaHeight;
      
      // Clip to content area
      ctx.save();
      ctx.beginPath();
      ctx.rect(margin + 20, contentAreaTop, windowWidth - 40, contentAreaHeight);
      ctx.clip();
      
      // Display messages
      const lineHeight = 24;
      const visibleMessages = [...dialogueMessages].reverse(); // Show newest messages first
      let y = contentAreaTop - messageHistoryScrollPosition;
      
      ctx.textAlign = "left";
      ctx.font = "16px Arial";
      
      visibleMessages.forEach(message => {
        // Format timestamp
        const timestamp = new Date(message.expiryTime - (defaultDialogueTime * 1000));
        const timeString = timestamp.toTimeString().split(' ')[0];
        
        // Draw timestamp
        ctx.fillStyle = "#888888";
        ctx.fillText(timeString, margin + 40, y);
        
        // Calculate text dimensions and position
        const textMaxWidth = windowWidth - 250;
        
        // Split text into lines for wrapping
        const words = message.text.split(' ');
        let lines = [];
        let currentLine = words.length > 0 ? words[0] : '';
        
        // Create wrapped lines
        for (let i = 1; i < words.length; i++) {
          const testLine = currentLine + ' ' + words[i];
          const metrics = ctx.measureText(testLine);
          if (metrics.width > textMaxWidth) {
            lines.push(currentLine);
            currentLine = words[i];
          } else {
            currentLine = testLine;
          }
        }
        lines.push(currentLine);
        
        // Draw message text
        ctx.fillStyle = message.color;
        lines.forEach((line, index) => {
          ctx.fillText(line, margin + 150, y + (index * lineHeight));
        });
        
        // Move Y position for next message
        y += (lines.length * lineHeight) + 15;
      });
      
      // Restore clipping
      ctx.restore();
      
      // Draw scroll indicators if needed
      if (messageHistoryScrollPosition > 0) {
        // Draw up arrow
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        ctx.moveTo(width - margin - 30, contentAreaTop + 20);
        ctx.lineTo(width - margin - 15, contentAreaTop + 5);
        ctx.lineTo(width - margin - 45, contentAreaTop + 5);
        ctx.closePath();
        ctx.fill();
      }
      
      // Check if we need to show down arrow (if more content exists below)
      const totalContentHeight = visibleMessages.reduce((total, msg) => {
        const lines = Math.ceil(ctx.measureText(msg.text).width / (windowWidth - 150));
        return total + (lines * lineHeight) + 15;
      }, 0);
      
      if (messageHistoryScrollPosition < totalContentHeight - contentAreaHeight && totalContentHeight > contentAreaHeight) {
        // Draw down arrow
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        ctx.moveTo(width - margin - 30, contentAreaBottom - 20);
        ctx.lineTo(width - margin - 15, contentAreaBottom - 5);
        ctx.lineTo(width - margin - 45, contentAreaBottom - 5);
        ctx.closePath();
        ctx.fill();
      }
    }

    // Draws the game over message in the center of the screen
    function drawGameOver() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, width, height);
      
      ctx.font = "bold 48px Arial";
      ctx.fillStyle = gameOverColor;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(gameOverMessage, centerX, centerY);
    }

    // Draws the pause menu in the center of the screen
    // Says "PAUSED" in big centered letters, then below it "Press P to unpause"
    function drawPauseMenu() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, width, height);
      
      ctx.font = "bold 48px Arial";
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("PAUSED", centerX, centerY - 20);
      ctx.font = "24px Arial";
      ctx.fillText("Press P to unpause", centerX, centerY + 20);
      ctx.fillText("Press H for message history", centerX, centerY + 60);
    }
    
    function normalizeAngle(a) {
      // Normalize angle to be between -pi and pi
      return a - Math.PI * 2 * Math.floor((a + Math.PI) / (Math.PI * 2));
    }
      
    // Function to create custom timeouts that respect pause state
    function createTimeout(callback, delay) {
      window.customTimeouts.push({
        callback: callback,
        delay: delay,
        elapsed: 0
      });
    }
    
    function animate(currentTime) {

      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $operation1Allowed === "undefined" || $operation1Allowed === null || !$operation1Allowed) {
        // Cancel the animation frame if the operation is not allowed to run
        return;
      }
    
      // Game over check
      if (gameOver) {
        // If viewing message history, draw that instead of game over menu
        if (isViewingMessageHistory) {
          drawMessageHistory();
        } else {
          // Draw game over message
          drawGameOver();
        }

        // Keep animating, but only up to here
        requestAnimationFrame(animate)
        return;
      }
      
      // Check if game should end now
      // Check if all player ships are gone
      if (areAllContactsGone("PLAYER")) {
        gameOver = true;
        $playerWonO1 = false;
        gameOverMessage = "DEFEAT!";
        gameOverColor = "red";
        // Play defeat sound
        const audio = new Audio("../assets/defeat.mp3");
        audio.play();
      }

      // Check if all hostile contacts are gone
      if (areAllContactsGone("HOSTILE")) {
        gameOver = true;
        $playerWonO1 = true;
        gameOverMessage = "VICTORY!";
        gameOverColor = "green";
        // Play victory sound
        const audio = new Audio("../assets/victory.mp3");
        audio.play();
      }
      
      // Calculate time since last frame
      const deltaTime = ((currentTime - lastFrameTime) / 1000) * deltaTimeMultiplier; // Convert to seconds, then scale by deltaTimeMultiplier
      // Helps with keeping track of unpaused time
      let trueDeltaTimeMillis = currentTime - lastFrameTime;
      lastFrameTime = currentTime;

      // Pause check is placed here to ensure deltaTime will not jump when unpausing
      if (gamePaused) {
        // If viewing message history, draw that instead of pause menu
        if (isViewingMessageHistory) {
          drawMessageHistory();
        } else {
          // Pause menu is drawn in the event listener
        }

        // Keep animating, but only up to here
        requestAnimationFrame(animate)
        return;
      }

      // Keep track of how much time has been spent outside of pause
      unpausedElapsedTimeMillis += trueDeltaTimeMillis;
      
      // Custom timeout handling system
      if (!window.customTimeouts) {
        window.customTimeouts = [];
      }
      
      // Process any active timeouts
      for (let i = window.customTimeouts.length - 1; i >= 0; i--) {
        const timeout = window.customTimeouts[i];
        timeout.elapsed += trueDeltaTimeMillis;
        
        if (timeout.elapsed >= timeout.delay) {
          // Execute the callback and remove from array
          timeout.callback();
          window.customTimeouts.splice(i, 1);
        }
      }
      
      // Dialogue check - figure out what stage of the operation we're in and what to say next
      if (!response1 && !response10 && !isFirstContact) {
        addDialogue("Captain: Unidentified contact, please identify yourself!", captainColor, defaultDialogueTime, captainPortraitFilePath);
        response10 = true;
        createTimeout(() => {
          addDialogue("???: Please help! We are heavily damaged and need assistance.", unidentifiedColor);
          response1 = true;
        }, 5000); // 5 seconds delay for the unidentified contact's response
      }

      if (response1 && !response2 && !response2a) {
        response2a = true; // prevents this from being called again
        createTimeout(() => {
          addDialogue("Engineer: Captain, I don't like this. Their signature doesn't match any civilian vessels.", engineerColor);
          response2 = true;
        }, 3000);
      }

      if (response2 && !response3 && !response3a) {
        response3a = true; // prevents this from being called again
        createTimeout(() => {
          addDialogue("Captain: Unidentified vessel, transmit proper identification codes immediately.", captainColor, defaultDialogueTime, captainPortraitFilePath);
          createTimeout(() => {
        addDialogue("???: We are... *static*... merchant vessel... *static*... systems failing...", unidentifiedColor);
        response3 = true;
          }, 4000);
        }, 2000);
      }

      if (response3 && !response4 && !response4a) {
        response4a = true; // prevents this from being called again
        createTimeout(() => {
          addDialogue("Engineer: Blueshift! Long range optics indicate blueshift! I think they're moving toward us!", engineerColor);
          // Set the pirate ship to move toward the player
          const pirateShip = contacts[1];
          // Calculate direction toward player (which is at center, 0,0)
          pirateShip.movementDirection = Math.atan2(
        -Math.sin(pirateShip.realBearing) * pirateShip.realDistance,
        -Math.cos(pirateShip.realBearing) * pirateShip.realDistance
          );
          // Increase speed
          pirateShip.movementSpeed = 1.2;
          pirateShip.directionChangeFrequency = 0; // Stop changing direction randomly
          
          createTimeout(() => {
            addDialogue("Captain: Unidentified vessel, power down engines now!", captainColor, defaultDialogueTime, captainPortraitFilePath);
            createTimeout(() => {
              addDialogue("???: *static*... we are... *static*... merchant vessel... *static*...", unidentifiedColor);
              createTimeout(() => {
                addDialogue("Captain: Sensors, we can't shoot unless fired upon first. I need you to report the instant you pick up any incoming missiles so I can authorize return fire.", captainColor, 12, captainPortraitFilePath);
              }, 5000);
            }, 5000); // 5 seconds delay for the unidentified contact's response
            response4 = true;
          }, 3000);
        }, 5000);
      }

      // Check distance of pirate ship to player and trigger missile attack when close enough
      const pirateShip = contacts[1];
      if (response4 && !response5 && pirateShip.realDistance < radius * 0.5 && !response5a) {
        response5a = true; // prevents this from being called again
        addDialogue("Engineer: Massive EM spike! Bearing same as unidentified contact!", engineerColor);
        
        createTimeout(() => {
          addDialogue("Captain: Keep me updated!", captainColor, defaultDialogueTime, captainPortraitFilePath);

          let battleStartTimeMillis = unpausedElapsedTimeMillis;
          
          // Launch three missiles from the pirate ship
          // First missile - direct at player
          pirateShip.launchMissileAtContact(contacts[0], 20, 1.0, 12, false);
          
          // Create two special trajectory missiles at 45/-45 degrees
          // These will initially go at angles, then redirect
          const playerBearing = Math.atan2(
            -Math.sin(pirateShip.realBearing) * pirateShip.realDistance,
            -Math.cos(pirateShip.realBearing) * pirateShip.realDistance
          );
          
          // Launch missile at +45 degrees
          pirateShip.launchMissileAlongAngle(playerBearing + Math.PI/4, 20, 1.0, 12);
          
          // Launch missile at -45 degrees
          pirateShip.launchMissileAlongAngle(playerBearing - Math.PI/4, 20, 1.0, 12);
          
          // Set a timer to redirect the angled missiles after a few seconds
          createTimeout(() => {
            // Find the two angled missiles (they should be the most recent hostile missiles)
            const missiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE");
            if (missiles.length >= 2) {
              // Get the last two created missiles (angled ones)
              const missile1 = missiles[missiles.length-1];
              const missile2 = missiles[missiles.length-2];
              
              // Make them redirect toward the player
              missile1.targetContact = contacts[0];
              missile1.hasTarget = true;
              
              missile2.targetContact = contacts[0];
              missile2.hasTarget = true;
            }
            addDialogue("Pirate: It was nice knowing you, Captain.", pirateColor);
          }, 3000); // Redirect after 3 seconds
          
          response5 = true;
        }, 2000);
      }

      // Check if all missiles were destroyed to reset attack
      if (response5 && !response6 && !response6a) {
        // Count how many hostile missiles are active
        const activeMissiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE").length;
        
        if (activeMissiles === 0) {
          response6a = true; // prevents this from being called again
          // All missiles were destroyed, pirate will attack again
          createTimeout(() => {
            addDialogue("Captain: Good work shooting down those missiles!", captainColor, defaultDialogueTime, captainPortraitFilePath);
              createTimeout(() => {
              addDialogue("Engineer: Captain, they're preparing to fire again!", engineerColor);
              
              // Launch three more missiles
              // First missile - direct at player
              pirateShip.launchMissileAtContact(contacts[0], 20, 1.0, 12, false);
              
              // Create two special trajectory missiles at 45/-45 degrees again
              const playerBearing = Math.atan2(
                -Math.sin(pirateShip.realBearing) * pirateShip.realDistance,
                -Math.cos(pirateShip.realBearing) * pirateShip.realDistance
              );
              
              // Launch missile at +45 degrees
              pirateShip.launchMissileAlongAngle(playerBearing + Math.PI/4, 20, 1.0, 12);
              
              // Launch missile at -45 degrees
              pirateShip.launchMissileAlongAngle(playerBearing - Math.PI/4, 20, 1.0, 12);
              
              // Set a timer to redirect the angled missiles after a few seconds
              createTimeout(() => {
                // Find the two angled missiles
                const missiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE");
                if (missiles.length >= 2) {
                // Get the last two created missiles (angled ones)
                const missile1 = missiles[missiles.length-1];
                const missile2 = missiles[missiles.length-2];
                
                // Make them redirect toward the player
                missile1.targetContact = contacts[0];
                missile1.hasTarget = true;
                
                missile2.targetContact = contacts[0];
                missile2.hasTarget = true;
                
                addDialogue("Engineer: Same attack pattern! The side missiles are curving back!", engineerColor);
                }
              }, 3000); // Redirect after 3 seconds
              
              response6 = true;
            }, 4000);
          }, 3000);
        }
      }

      // Check if second wave of missiles was destroyed
      if (response6 && !response7 && !response7a) {
        response7a = true; // prevents this from being called again
        // Count how many hostile missiles are active
        const activeMissiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE").length;
        
        if (activeMissiles === 0) {
          createTimeout(() => {
            addDialogue("Captain: Their attack failed again. Sensors, get me a firing solution. I want those scum wiped out.", captainColor, defaultDialogueTime, captainPortraitFilePath);
            createTimeout(() => {
              addDialogue("Engineer: Working on it Captain!", engineerColor);
              response7 = true;
            }, 3000);
          }, 2000);
        }
      }

      // If pirate ship gets within the 0.1ls range, add a dialogue message warning of the imminent ram
      if (!response9a && pirateShip.realDistance < radius * 0.1) {
        response9a = true; // prevents this from being called again
        addDialogue("Captain: They're insane! They're going to ram us! Blow them up NOW!", captainColor, defaultDialogueTime, captainPortraitFilePath);
      }

      // Check for collision between pirate ship and player
      if (pirateShip && !gameOver) {
        // Calculate distance between pirate ship and player
        const playerShip = contacts[0];
        const dx = Math.cos(pirateShip.realBearing) * pirateShip.realDistance - Math.cos(playerShip.realBearing) * playerShip.realDistance;
        const dy = Math.sin(pirateShip.realBearing) * pirateShip.realDistance - Math.sin(playerShip.realBearing) * playerShip.realDistance;
        const distanceBetweenShips = Math.sqrt(dx*dx + dy*dy);
        
        // If ships are too close, trigger collision and game over
        if (distanceBetweenShips < (pirateShip.size + playerShip.size)) {
          // Create explosion effect at collision point
          const collisionX = centerX + playerShip.distance * Math.cos(playerShip.bearing);
          const collisionY = centerY + playerShip.distance * Math.sin(playerShip.bearing);
          createExplosion(collisionX, collisionY);
          
          // Set game over state
          gameOver = true;
          $playerWonO1 = false;
          gameOverMessage = "DEFEAT!";
          gameOverColor = "red";
          
          // Play collision/explosion sound
          const audio = new Audio("../assets/defeat.mp3");
          audio.play();
          
          // Add final dialogue
          addDialogue("Engineer: Visual contact! Brace for impact!", engineerColor);
        }
      }
      
      // Cap deltaTime to prevent huge jumps if tab was inactive
      const cappedDeltaTime = Math.min(deltaTime, 0.5);
      
      drawBackground(cappedDeltaTime);
      
      // Calculate thermal scan absolute angle
      const thermalScanAbsoluteAngle = thermalScanAngle + thermalScanCenter;

      // Sort contacts into friendly and hostile arrays
      // Do not include missiles in these arrays
      const friendlyContacts = contacts.filter(contact => contact.contactType === "FRIENDLY" || contact.contactType === "PLAYER" && !contact.isMissile);
      const hostileContacts = contacts.filter(contact => contact.contactType === "HOSTILE" && !contact.isMissile);
      
      // Update and draw contacts
      for (let contact of contacts) {
        contact.updatePosition(cappedDeltaTime);
        contact.checkDetection(angle, thermalScanAbsoluteAngle, thermalScanRadius, cappedDeltaTime);
        contact.draw(cappedDeltaTime);
      }
      
      // Draw the radar line and thermal scan
      drawRadarLine();
      drawThermalScan();
      // Draw the text telling the player in the top left how many missiles are left
      drawCurrentMissiles();
      // Draw the dialogue messages in the top right corner
      drawDialogue();
      
      // Update and draw contact reports
      for (let i = contactReports.length - 1; i >= 0; i--) {
        if (!contactReports[i].update(cappedDeltaTime)) {
          contactReports.splice(i, 1);
        } else {
          contactReports[i].draw();
        }
      }
      
      // Update the radar scan angle (rotate by specified degrees per second)
      angle += (Math.PI * radarSpeed / 180) * cappedDeltaTime;
      if (angle >= Math.PI * 2) angle = 0;

      // Update the thermal scan angle
      if (thermalScanReversed) {
        thermalScanAngle -= (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle <= -thermalScanWidth/2) {
          thermalScanAngle = -thermalScanWidth/2;
          thermalScanReversed = false;
        }
      } else {
        thermalScanAngle += (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle >= thermalScanWidth/2) {
          thermalScanAngle = thermalScanWidth/2;
          thermalScanReversed = true;
        }
      }
      
      requestAnimationFrame(animate);
    }

    // Track mouse position
    let mouseX, mouseY;
    canvas.addEventListener('mousemove', function(event) {
      const rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    });

    // Add click event listener for contact reports
    canvas.addEventListener('click', function(event) {
      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $operation1Allowed === "undefined" || $operation1Allowed === null || !$operation1Allowed) {
        // Cancel the event if the operation is not allowed to be running
        return;
      }
      // If paused, do nothing
      if (gamePaused) return;

      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
    
      // Check if click is on a contact report
      let wasOnContactReport = false;
      for (let i = 0; i < contactReports.length; i++) {
        // Launch a missile if the click is on a contact report and the player ship still has missiles
        // PLayer ship should be the first contact in the contacts array
        if (contactReports[i].contains(mouseX, mouseY) && contacts[0].numMissiles > 0) {
          console.log(`Radar contact at ${contactReports[i].timestamp} reported`);

          // If this is the first contact report clicked, add a dialogue message
          if (isFirstContact) {
            addDialogue(`Engineer: I've got something on scope! I can't pick up any IFF information.`, engineerColor);
            // Wait for 3 seconds, then set isFirstContact to false
            createTimeout(() => {
              isFirstContact = false;
            }, 3000);
          }

          wasOnContactReport = true;

          // If this isn't the first contact report clicked and the associated contact is a missile, add a dialogue message for that
          if (contactReports[i].contact.isMissile && !isFirstContact && isFirstMissile) {
            addDialogue(`Engineer: Fast movers! Likely missiles!`, engineerColor);
            // Wait for 3 seconds, then have the captain respond
            createTimeout(() => {
              addDialogue(`Captain: They're pirates! Fire countermissile! General Quarters!`, captainColor, 12);
              // Now mark the player ship as allowed to fire
              allowedToFire = true;
              allowedToFireAtSpot = true;
            }, 1000);
            isFirstMissile = false;
          }
      
          // If not allowed to fire, do nothing
          if (allowedToFire) {
            // Fire at the contact report's associated contact
            // contacts[0] is the player ship, so we will use it to launch the missile
            // launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed)
            contacts[0].launchMissileAtContact(contactReports[i].contact, 30, 0.9, 10, false);
          }

          // Remove the report after clicking
          contactReports.splice(i, 1);
          break;
        }
      }
      // If not on a contact report, check if click is on the radar screen
      if (!wasOnContactReport) {
        // Figure out the fire coordinates based on the mouse position
        const dx = mouseX - centerX;
        const dy = mouseY - centerY;

        if (!allowedToFireAtSpot || !allowedToFire) return; // Don't fire if not allowed
        

        // Try to fire at the given coordinates
        // contacts[0] is the player ship, so we will use it to launch the missile
        // launchMissileAtPoint(targetX, targetY, missileFuelTime, missileArmingTime, missileMovementSpeed)
        contacts[0].launchMissileAtPoint(dx, dy, 30, 0.9, 10);
      }
    });

    // Key event listeners for thermal scan control
    document.addEventListener('keydown', function(event) {
      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $operation1Allowed === "undefined" || $operation1Allowed === null || !$operation1Allowed) {
        // Cancel the event if the operation is not allowed to be running
        return;
      }
      if (event.key === 'a' || event.key === 'A') {
        // Rotate thermal scan left
        // If paused, do nothing
        if (!gamePaused) {
          thermalScanCenter -= 0.1;
          if (thermalScanCenter < 0) thermalScanCenter += Math.PI * 2;
        }
      } else if (event.key === 'd' || event.key === 'D') {
        // Rotate thermal scan right
        // If paused, do nothing
        if (!gamePaused) {
          thermalScanCenter += 0.1;
          if (thermalScanCenter >= Math.PI * 2) thermalScanCenter -= Math.PI * 2;
        }
      } else if (event.key === 'x' || event.key === 'X') {
        // Check if the mouse is over a contact report
        // If paused, do nothing
        if (!gamePaused) {
          for (let i = 0; i < contactReports.length; i++) {
            if (contactReports[i].contains(mouseX, mouseY)) {
              // Dismiss the contact report
              console.log(`Contact report at ${contactReports[i].timestamp} dismissed`);
              contactReports.splice(i, 1);
              break;
            }
          }
        }
      } else if (event.key === 'q' || event.key === 'q') {
        // If not allowed to fire, do nothing
        if (!allowedToFire) return;

        // Check if the mouse is over a contact report
        // If paused, do nothing
        if (!gamePaused) {
          for (let i = 0; i < contactReports.length; i++) {
            if (contactReports[i].contains(mouseX, mouseY)) {
              // Fire a spread at the contact in the contact report
              
              // Fire at the contact report's associated contact
              // contacts[0] is the player ship, so we will use it to launch the missile
              // launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed, isSpreadAttack)
              contacts[0].launchMissileAtContact(contactReports[i].contact, 30, 0.9, 10, true);

              console.log(`Spread fired at Contact report at ${contactReports[i].timestamp}`);
              contactReports.splice(i, 1);
              break;
            }
          }
        }
      } else if (event.key === 'p' || event.key === 'P') {
        // Toggle pause state if not in game over state
        if (!gameOver) {
          // If viewing message history, just exit that view but remain paused
          if (isViewingMessageHistory) {
            isViewingMessageHistory = false;
            drawPauseMenu();
          } else {
            gamePaused = !gamePaused;
            if (gamePaused) {
              console.log("Game paused");
              // Draw it here to ensure it's only drawn once when paused
              drawPauseMenu();
            } else {
              console.log("Game unpaused");
            }
          }
        }
      } else if (event.key === 'h' || event.key === 'H') {
        // Toggle message history view
        if (isViewingMessageHistory) {
          // Exit message history view but stay paused
          isViewingMessageHistory = false;
          drawPauseMenu();
        } else {
          // If game is not already paused, pause it
          if (!gamePaused) {
            gamePaused = true;
          }
          // Switch to message history view
          isViewingMessageHistory = true;
          // Reset scroll position when first opening
          messageHistoryScrollPosition = 0;
        }
      } else if (event.key === 'ArrowUp') {
        // Scroll message history up
        if (isViewingMessageHistory) {
          messageHistoryScrollPosition = Math.max(0, messageHistoryScrollPosition - 40);
        }
      } else if (event.key === 'ArrowDown') {
        // Scroll message history down
        if (isViewingMessageHistory) {
          messageHistoryScrollPosition += 40;
          // Upper limit will be checked in draw function
        }
      }
    });

    // Create contacts array with initial contacts
    // Parameters: bearing, distance, size, 
    //             movementSpeed, directionChangeFrequency, movementDirection, 
    //             visible, opacity, emittingRadiation, emissionDetectionChance,
    //             radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
    //             iffBroadcasting, iffString, contactColor, contactType,
    //             numMissilesLoaded
    const contacts = [
      // The player's ship. Always visible and at the center of the radar
      // Has 100 missiles loaded
      new Contact(0, 0, 5, 
                  0, 0, 0, 
                  true, 1, true, 0, 
                  true, 0, true, 0,
                  true, "PLAYER SHIP, Heavy Cruiser\nCRS Bounty\nCairn Class", [255, 255, 255],
                  "PLAYER", 100),
      // The pirate ship. Only has 6 missiles ready to fire, but it's ready to make each one count
      new Contact(Math.PI/16, radius * 0.75, 5, 
                  0, 0, 0, 
                  false, 0, true, 0.3,
                  true, 1, true, 1,
                  false, "", [255, 0, 0],
                  "HOSTILE", 6),
      // ELINT Ghosts (No thermal, no radar detection)
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
    ];

    // Fill the canvas with black initially
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, width, height);
    
    // Start the animation with the timestamp
    lastFrameTime = performance.now();

    // Add the initial dialogue message
    addDialogue("Captain: Sensors! What do we have?",  captainColor, defaultDialogueTime, captainPortraitFilePath);

    requestAnimationFrame(animate);
  })();
</script>


(set: $operation2Allowed to false)
(set: $operation3Allowed to false)
(set: $operation4Allowed to false)
(set: $operation5Allowed to false)
(set: $tutorialOperationAllowed to false)
(set: $operationDebugAllowed to false)
[[See Operation Results->Operation Result 1]]
[[Back->Intro 3]]

:: Operation Result 1 {"position":"1200,400","size":"100,100"}

[[Click to go Back->Operation 1]]
(if: $playerWonO1 is true)[[[Victory! Click to continue->Operation 2]]]
(set: $operation1Allowed to false)
(set: $operation2Allowed to false)
(set: $operation3Allowed to false)
(set: $operation4Allowed to false)
(set: $operation5Allowed to false)
(set: $tutorialOperationAllowed to false)
(set: $operationDebugAllowed to false)

:: Operation 2 {"position":"1400,200","size":"100,100"}
Operation 2: The Tartarus

Tips:
Use your thermal scanner, especially when missiles are flying at you.
Click the contact report box, not the contact itself to report contacts.
When weapon fire is authorized, you can click on a spot to fire at that spot.

Controls:
F11 for fullscreen
Thermal Scan - Use A/D to rotate
Contact Report - Left click to fire at, X to Dismiss, Q to fire a spread at
Pause - P to toggle pause
Message history - H to pause and view message history
<!-- Operation 2 -->
<!-- Removal of padding allows for much more game room on small monitors -->
<style>
tw-story {
  padding: 0% 0%;
  padding-top: 0%;
  padding-right: 0%;
  padding-bottom: 0%;
  padding-left: 0%;
}

@media (min-width: 576px) {
  tw-story {
    padding: 0% 0%;
    padding-top: 0%;
    padding-right: 0%;
    padding-bottom: 0%;
    padding-left: 0%;
  }
}
</style>

<canvas id="operation2" width="1350" height="750"></canvas>
<script>
    // Mark operation 2 as being usable
    $operation2Allowed = true;
    // Stops the previous audio
    if (typeof audio !== 'undefined') {
      audio.pause();
      // And probably remove it from the memory
      delete audio;
    }
  (function() {
    const canvas = document.getElementById("operation2");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 3;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 2 - 10;

    // Array of elint beep audios. Rather than create and play a new beep each time there is a detection,
    // we will instead reuse numBeeps number of beeps. This is to prevent the audio from overlapping and
    // creating a cacophony of beeps that can overload the number of audio channels available in the browser.
    const numBeeps = 20;
    const elintBeeps = Array.from({ length: numBeeps }, () => new Audio("../assets/ELINTBeep.mp3"));
    
    // Track the start time
    const startTime = Date.now();
    let lastFrameTime = performance.now();
    // Track the unpaused elapsed time
    let unpausedElapsedTimeMillis = 0;
    // Time multiplier
    // 1 = normal speed
    // 2 = double speed
    // 0.5 = half speed
    const deltaTimeMultiplier = 2.4;
    // Detection chance time multiplier
    // Intended to address the fact that PC performance can affect detection chances
    const detectionTimeMultiplier = 1;

    // Game state variables
    let gameOver = false;
    let gamePaused = true;
    let gameOverMessage = "";
    let gameOverColor = "";

    // If the game is paused, go ahead and draw the pause screen
    if (gamePaused) {
      requestAnimationFrame(drawPauseMenu);
    }

    // Customizable parameters - now in units per second instead of per frame
    const radarSpeed = 30; // degrees per second
    const fadeRate = 6;   // fade opacity per second
    const ELINTHalfAngle = Math.PI/36; // 5 degrees in radians
    
    // Radar line angle
    let angle = 0;
    // Thermal scan angle
    let thermalScanAngle = 0;
    
    // Thermal scan parameters
    const thermalScanWidth = Math.PI/6; // 30 degrees in radians
    const thermalScanRadius = radius * 0.25; // 0.25ls circle
    const thermalScanSpeed = 30; // degrees per second
    let thermalScanCenter = 0; // Center of thermal scan area
    let thermalScanReversed = false; // Direction of thermal scan rotation

    // Missile thermal scan parameters
    const missileScanWidth = Math.PI/6; // 30 degrees in radians
    const missileScanRadius = radius * 0.05; // 0.05ls circle
    const missileScanSpeed = 60; // degrees per second

    // Random missile launch parameters
    const baseMissileLaunchChance = 0;
    let missileLaunchChance = baseMissileLaunchChance;
    let missileLaunchIncrease = 0;
    // Missile attack type parameters
    const chanceOfSpreadAttack = 0.0;
    const spreadAttackMissilePerRadiusAmount = 0.05; // Add 1 more missile for every radius amount of distance to target
    let allowedToFireAtSpot = false; // If true, the player can fire at any point on the screen, not just contacts. If false, they can't.
    let allowedToFire = false; // If true, the player can cause a missile to be launched. If false, all controls related to firing are disabled. 
    // Tartarus missile parameters
    const tartarusMissileFuelTime = 120; // Lifetime of Tartarus missiles in seconds. Default 120
    const tartarusMissileArmingTime = 1.0; // Time it takes for Tartarus missiles to arm in seconds. Default 1.0
    const tartarusMissileSpeed = 12; // Speed of Tartarus missiles in ls/s. Default 12

    // Contact report parameters
    const contactReports = [];
    const reportLifetime = 10; // lifetime in seconds

    // IFF Parameters
    const iffBoxDisplayDistance = 100; // How far away the mouse can be before the IFF box stops displaying
    const acceptedTypes = ["FRIENDLY", "HOSTILE", "NEUTRAL", "GHOST", "PLAYER"]; // Accepted contact types

    // Dialogue message parameters
    const dialogueMessages = []; // Array to store dialogue messages with text, color, and time they should disappear
    const defaultDialogueTime = 8; // Default time for dialogue messages to disappear
    // Dialogue flags
    let isFirstContact = true;
    let isFirstMissile = true;
    let shotDownFirstMissile = false;
    let firedFirstSpread = false;
    let firedSpreadAtMissile = false;
    let firedSpreadAtInvalidTarget = false;
    let response1 = false;
    let response1a = false;
    let response2 = false;
    let response2a = false;
    let response3 = false;
    let response3a = false;
    let response4 = false;
    let response4a = false;
    let response5 = false;
    let response5a = false;
    let response6 = false;
    let response6a = false;
    let response7 = false;
    let response7a = false;
    let response8 = false;
    let response8a = false;
    let response9 = false;
    let response9a = false;
    let response10 = false;
    let response10a = false;
    // Dialogue message colors for certain characters
    const engineerColor = "#00FF00";
    const captainColor = "#34eb7a";
    const helmsmanColor = "#9ceb34";
    const friendlyColor = "#FF00FF"
    const unidentifiedColor = "#FFFFFF"
    const pirateColor = "#FF0000"
    // Dialogue portrait paths
    const captainPortraitFilePath = "../assets/characters/CaptainPortrait.png";

    // Function to create explosion effect
    function createExplosion(x, y) {
      // Play explosion sound (Unused for now)
      // const explosionSound = new Audio("../assets/MissileHit.mp3");
      // explosionSound.play();

      // Visual explosion effect (flash)
      ctx.beginPath();
      ctx.arc(x, y, 30, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255, 200, 50, 0.8)";
      ctx.fill();
    }

    // Function to check if all contacts of a specific type are gone
    function areAllContactsGone(type) {
      return !contacts.some(contact => contact.contactType === type && !contact.destroyed);
    }

    // Contact Report class
    class ContactReport {
      constructor(x, y, timestamp, contactType, contact) {
        this.x = x;
        this.y = y;
        this.timestamp = timestamp;
        this.contactType = contactType;
        this.contact = contact;
        this.timeCreated = Date.now();
        this.age = 0;
        this.maxAge = reportLifetime;
      }
      
      update(deltaTime) {
        // Increment age, but only if the contact is no longer visible or no longer exists
        if (!this.contact || !this.contact.visible || this.contact.destroyed || typeof this.contact === 'undefined') {
          this.age += deltaTime;
        }
        return this.age < this.maxAge;
      }
      
      draw() {
        // Calculate opacity based on age
        const opacity = 1 - (this.age / this.maxAge);
        
        // Determine position (ensure it's on screen)
        const boxWidth = 180;
        const boxHeight = 75; // Increased height to fit new line
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        // Draw connection line
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(boxX + (boxX > this.x ? 0 : boxWidth), boxY + boxHeight/2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw box
        ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.7})`;
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Draw text
        ctx.font = "10px monospace";
        ctx.fillStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.textAlign = "left";
        ctx.fillText(`DETECTED: ${this.timestamp}`, boxX + 5, boxY + 15);
        ctx.fillText(`POTENTIAL ${this.contactType} CONTACT`, boxX + 5, boxY + 30);
        ctx.fillText("CLICK TO REPORT CONTACT", boxX + 5, boxY + 45);
        ctx.fillText("X TO DISMISS, Q TO FIRE SPREAD", boxX + 5, boxY + 60);
      }
      
      contains(mouseX, mouseY) {
        // Determine box position
        const boxWidth = 180;
        const boxHeight = 75; // TODO: Make boxWidth and boxHeight not exist both here and in draw() separately in order to make it easier to change
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        return mouseX >= boxX && mouseX <= boxX + boxWidth && 
               mouseY >= boxY && mouseY <= boxY + boxHeight;
      }
    }

    // Contact class definition
    class Contact {
      constructor(bearing, distance, size, movementSpeed, directionChangeFrequency, movementDirection, 
                  visible, opacity, emittingRadiation, emissionDetectionChance, 
                  radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
                  iffBroadcasting, iffString, contactColor, contactType, numMissilesLoaded) {
        // Affects displayed position
        this.bearing = bearing;
        this.distance = distance;
        this.size = size;
        
        // Affects real position for sim (moves independently of the displayed blip)
        this.realBearing = bearing;
        this.realDistance = distance;
        
        // Movement parameters for sim (now per second rather than per frame)
        this.movementSpeed = movementSpeed;
        this.directionChangeFrequency = directionChangeFrequency;
        this.movementDirection = movementDirection;
        this.directionChangeCounter = 0;
        
        // Visibility properties for contact blip
        this.visible = visible;
        this.opacity = opacity;
        this.fadeSpeed = 0.6; // fade per second

        // ELINT detection properties
        this.emittingRadiation = emittingRadiation;
        this.emissionDetectionChance = emissionDetectionChance;
        this.radiationDetected = false;
        this.radiationDetectionDuration = 0;
        
        // Radar detection properties
        this.radarDetectable = radarDetectable;
        this.radarDetectionChance = radarDetectionChance;
        this.lastDetectedTime = null;

        // Thermal detection properties
        this.thermalDetectable = thermalDetectable;
        this.thermalDetectionChance = thermalDetectionChance;

        // IFF (Identification Friend or Foe) properties
        this.iffBroadcasting = iffBroadcasting;
        this.iffString = iffString;
        this.contactColor = contactColor;

        // How many missiles are aboard the ship
        this.numMissiles = numMissilesLoaded;

        // Currently, there are five types of contacts: "FRIENDLY", "HOSTILE", "NEUTRAL", "GHOST", and "PLAYER"
        // Anything else is treated as "GHOST"
        if (acceptedTypes.includes(contactType)) {
          this.contactType = contactType;
        } else {
          this.contactType = "GHOST";
        }
        // Ghosts must not be thermally detectable
        if (this.contactType === "GHOST") {
          this.thermalDetectable = false;
        }
      }
      
      updatePosition(deltaTime) {
        // Randomly change direction occasionally, now based on elapsed time
        this.directionChangeCounter += deltaTime;
        if (this.directionChangeCounter > (1 / this.directionChangeFrequency)) {
          this.movementDirection += (Math.random() - 0.5) * Math.PI / 2; // Change by up to +/-45 degrees
          this.directionChangeCounter = 0;
        }
        
        // Convert polar movement to cartesian
        let dx = Math.cos(this.movementDirection) * this.movementSpeed * deltaTime;
        let dy = Math.sin(this.movementDirection) * this.movementSpeed * deltaTime;
        
        // Convert contact position from polar to cartesian
        let contactX = Math.cos(this.realBearing) * this.realDistance;
        let contactY = Math.sin(this.realBearing) * this.realDistance;
        
        // Update position
        contactX += dx;
        contactY += dy;
        
        // Convert back to polar coordinates
        this.realDistance = Math.sqrt(contactX * contactX + contactY * contactY);
        this.realBearing = Math.atan2(contactY, contactX);
        
        // Keep contact within radar bounds
        if (this.realDistance > radius * 0.95) {
          // If near edge, bounce back, unless a missile, in which case it should self-destruct
          if (this.isMissile) {
            // Create explosion effect
            createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                           centerY + this.realDistance * Math.sin(this.realBearing));
            
            // Remove from contacts array
            const index = contacts.indexOf(this);
            if (index > -1) {
              contacts.splice(index, 1);
            }
            return;
          }
          this.movementDirection = Math.atan2(-contactY, -contactX);
          this.realDistance = radius * 0.95;
        } else if (this.realDistance < 0) {
          // If somehow at a negative distance, reset to 0
          this.realDistance = 0;
        }
        
        // Check for radiation detection
        this.checkRadiationDetection(deltaTime);
        
        // Decrease radiation detection duration
        if (this.radiationDetected) {
          this.radiationDetectionDuration -= deltaTime;
          if (this.radiationDetectionDuration <= 0) {
            this.radiationDetected = false;
          }
        }
      }
      
      checkRadiationDetection(deltaTime) {
        // Adjust chance based on time
        const timeAdjustedChance = this.emissionDetectionChance * deltaTime * detectionTimeMultiplier;
        
        if (this.emittingRadiation && Math.random() < timeAdjustedChance) {
          // Play a beep
          // Iterate through beeps to find one that is not currently playing
          for (let i = 0; i < numBeeps; i++) {
            if (elintBeeps[i].paused) {
              elintBeeps[i].play();
              break;
            }
          }

          this.radiationDetected = true;
          this.radiationDetectionDuration = 0.25; // Show for 0.25 second
        }
      }
      
      checkDetection(radarAngle, thermalScanAbsoluteAngle, thermalScanRadius, deltaTime) {
        // Check if radar is sweeping over the contact
        const angleDiff = Math.abs(normalizeAngle(radarAngle - this.realBearing));
        let wasNewDetection = false;
        
        // Adjust chances based on time
        // If something has a 100% chance of being detected, it should be detected
        const timeAdjustedRadarChance = this.radarDetectionChance >= 1 ? 1 : this.radarDetectionChance * deltaTime * detectionTimeMultiplier;
        //const timeAdjustedThermalChance = this.thermalDetectionChance * deltaTime * detectionTimeMultiplier;
        const timeAdjustedThermalChance = this.thermalDetectionChance > 0 ? 1 : 0; // If something is thermal detectable, it should be detected
        
        if (angleDiff < 0.1 && this.radarDetectable && Math.random() < timeAdjustedRadarChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            // Play a ping
            const audio = new Audio("../assets/RadarPing.mp3");
            audio.play();
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const minutes = Math.floor(unpausedElapsedTimeMillis / 60000);
            const seconds = Math.floor((unpausedElapsedTimeMillis % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "RADAR", this));
          }
        }
        
        // Check if thermal scan is over the contact
        const thermalDiff = Math.abs(normalizeAngle(thermalScanAbsoluteAngle - this.realBearing));
        
        if (thermalDiff < 0.1 && this.realDistance < thermalScanRadius && 
            this.thermalDetectable && Math.random() < timeAdjustedThermalChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const minutes = Math.floor(unpausedElapsedTimeMillis / 60000);
            const seconds = Math.floor((unpausedElapsedTimeMillis % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "THERMAL", this));
          }
        }
      }

      // Launch a missile along a given bearing
      launchMissileAlongAngle(targetBearing, missileFuelTime, missileArmingTime, missileMovementSpeed) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          // General idea: Create a unit circle around this contact, then create a contact at the 
          // corresponding point on the circle with the matching bearing.

          // Figure out the polar coordinates of a point on the unit circle with angle targetBearing
          const targetX = Math.cos(targetBearing);
          const targetY = Math.sin(targetBearing);

          // Center the unit circle around the launcher's position
          const missileX = Math.cos(this.realBearing) * this.realDistance;
          const missileY = Math.sin(this.realBearing) * this.realDistance;

          // Figure out the actual position in the game world that the missile is being launched towards
          const trueTargetX = missileX + targetX;
          const trueTargetY = missileY + targetY;

          // Convert back to polar coordinates
          const targetContactBearing = Math.atan2(trueTargetY, trueTargetX);
          const targetContactDistance = Math.sqrt(trueTargetX * trueTargetX + trueTargetY * trueTargetY);

          // Create a new contact that just gives a bearing and unit distance
          // to tell the missile what direction to aim in
          // If this is not done, then missiles launched will not know
          // which direction to go in. They will only know where to spawn.
          let targetContact = new Contact(targetContactBearing, targetContactDistance);

          // Set the missile's contact type to match whoever launched it, unless the contact is a player
          // Set it to friendly in that latter case
          let contactType = this.contactType;
          if (this.contactType === "PLAYER") {
            contactType = "FRIENDLY";
          }
          const missile = new MissileContact(this.realBearing, this.realDistance, targetContact, missileFuelTime, contactType, missileArmingTime, missileMovementSpeed);
          contacts.push(missile);

          // Reduce the number of missiles available if applicable
          if (this.numMissiles !== undefined && this.numMissiles !== null) {
            this.numMissiles--;
          }
        } 
      }

      // Launch a missile at the given position (Requires target contact just to tell the missile who it's initially targeting)
      launchMissileAtPoint(targetX, targetY, missileFuelTime, missileArmingTime, missileMovementSpeed) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          
          // Figure out the angle of the line which points from this contact to the target
          // Convert contact position from polar to Cartesian
          const contactX = Math.cos(this.realBearing) * this.realDistance;
          const contactY = Math.sin(this.realBearing) * this.realDistance;

          // Calculate angle from contact to target
          const targetAngle = Math.atan2(targetY - contactY, targetX - contactX);

          // Delegate to launchMissileAlongAngle with the target angle
          this.launchMissileAlongAngle(targetAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
        }
      }

      // Launch a missile at the given contact
      launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed, isSpreadAttack) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          // Basic idea: We have four parametric equations, two for the target's position as a function
          // of time, and two for the missile's position as a function of time. 
          // The missile position in x is given by
          //
          // missileX(t) = t * missileVelocityX + missileX(0)    <-- missileX(0) is the initial x position of the missile, so in this case, the launcher's x position
          //
          // The missile position in y is given by
          //
          // missileY(t) = t * missileVelocityY + missileY(0)  <-- missileY(0) is the initial y position of the missile, so in this case, the launcher's y position
          //
          // The target position in x is given by
          //
          // targetX(t) = t * targetVelocityX + targetX(0)  <-- targetX(0) is the initial x position of the target contact, so in this case, its current x position
          //
          // The target position in y is given by
          //
          // targetY(t) = t * targetVelocityY + targetY(0)  <-- targetY(0) is the initial y position of the target contact, so in this case, its current y position
          //
          // We want all four quantities to equal, so we arrive at a system of two equations:
          //
          // missileX(t) = targetX(t) && missileY(t) = targetY(t)
          //
          // We actually have two unknowns. Time is of course one of them, but the other is the angle at which we must launch the missile to collide with the target.
          // It is this quantity we are interested in. We know that launch angle is actually a part of the missile's velocity vector, so we can write
          //
          // missileVelocityX = missileSpeed * cos(missileLaunchAngle) && missileVelocityY = missileSpeed * sin(missileLaunchAngle)
          //
          // We then substitute these into the system of equations, and solve for time and missileLaunchAngle. 
          // It is somewhat challenging to solve this, but by using a symbolic algebra system like the one used by Wolfram Mathematica, we get that there
          // are actually two solutions for both time and angle. We will look at both solutions and chooose which, if any, is the correct one to use.
          // For instance, if angle or time are undefined or infinite, we know that something is wrong with that solution, likely because none is possible.
          // This could happen in a case where we're shooting at something going away faster than we can catch up to it, for instance.
          // Moreover, if time is negative, then our window of opportunity has already passed, and we should not launch the missile using the given solution.
          // Those interested in the derivation of this equation for themselves should be familiar with solutions of equations of the form 
          //
          // sin(x) + b cos(x) = c for real valued constants b and c

          // Time, angle equations 1.
          // These symbols correspond to these quantities:
          // evx - Enemy velocity x
          // evy - Enemy velocity y
          // mxi - Missile initial x position
          // myi - Missile initial y position
          // exi - Enemy initial x position
          // eyi - Enemy initial y position
          // mspeed - Missile speed
          // t - Time
          // a - Angle

          // In Mathematica code, solution pair 1 is given by
          // t=1/(evx^2+evy^2-mspeed^2) (-evx  exi-evy  eyi+evx  mxi+evy  myi-1/2  \[Sqrt](4  (evx (exi-mxi)+evy (eyi-myi))^2-4  (evx^2+evy^2-mspeed^2)  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))
          // a=ArcTan[(-evy  (exi-mxi)  (eyi-myi)+evx  (eyi-myi)^2+(exi-mxi)  \[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)),(evy  (exi-mxi+(eyi-myi)  (-evx  exi+evx  mxi+\[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))]
          
          // In Mathematica code, solution pair 2 is given by
          // t=1/(evx^2+evy^2-mspeed^2) (-evx  exi-evy  eyi+evx  mxi+evy  myi+1/2  \[Sqrt](4  (evx (exi-mxi)+evy (eyi-myi))^2-4  (evx^2+evy^2-mspeed^2)  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))
          // a=ArcTan[(-evy  (exi-mxi)  (eyi-myi)+evx  (eyi-myi)^2+(-exi+mxi)  \[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)),(evy  (exi-mxi)^2-(eyi-myi)  (evx  exi-evx  mxi+\[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))]

          // Convert both contacts' polar coordinates to Cartesian
          // For the missile launcher (this contact)
          const mxi = Math.cos(this.realBearing) * this.realDistance; // Missile initial x
          const myi = Math.sin(this.realBearing) * this.realDistance; // Missile initial y
          
          // For the target
          const exi = Math.cos(targetContact.realBearing) * targetContact.realDistance; // Enemy initial x
          const eyi = Math.sin(targetContact.realBearing) * targetContact.realDistance; // Enemy initial y
          
          // Calculate enemy velocity components
          const evx = Math.cos(targetContact.movementDirection) * targetContact.movementSpeed; // Enemy velocity x
          const evy = Math.sin(targetContact.movementDirection) * targetContact.movementSpeed; // Enemy velocity y
          
          // Missile speed
          const mspeed = missileMovementSpeed;
          
          // Calculate values needed for the formulas
          const dx = exi - mxi;
          const dy = eyi - myi;
          const distSquared = dx*dx + dy*dy;

          // We first check to see if we're firing at a ghost
          if (targetContact.contactType === "GHOST") {
            // If we're firing at a ghost, launch directly at ghost's last sighted position
            // Looks odd otherwise (Why is my missile going to this random position this game is buggy!!!)

            // Handle firing a spread as well
            if (isSpreadAttack) {
              // Check if the player ship is the launcher
              // and if firedFirstSpread is false
              // If so, write dialogue 
              if(this.contactType === "PLAYER" && !firedFirstSpread) {
                addDialogue("Captain: Gunnery control, fire a spread at that contact!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                firedFirstSpread = true;
              }

              // Calculate distance in radius units
              const distance = Math.sqrt(distSquared);
               
              // Calculate number of missiles based on distance
              // Add 1 missile for every spreadAttackMissilePerRadiusAmount * radius
              let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
               
              // Set minimum and maximum number of missiles
              numMissiles = Math.max(2, numMissiles);
               
              // Calculate increased arming time (0.5 seconds per missile)
              const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);

              // Figure out angle between this contact and the target contact
              const selectedAngle = Math.atan2(dy, dx);
               
              // Launch a spread of missiles
              const spreadAngle = Math.PI / 6; // 30 degrees
              for (let i = 0; i < numMissiles; i++) {
                const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              }
               
              // Launch one more missile directly at the target
              this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              return;
            }

            this.launchMissileAtPoint(targetContact.distance * Math.cos(targetContact.bearing), targetContact.distance * Math.sin(targetContact.bearing), missileFuelTime, missileArmingTime, missileMovementSpeed);
            return;
          }
          
          // Check if player tried to fire spread at missile (moved up to check in all cases)
          if (this.contactType === "PLAYER" && targetContact.isMissile && isSpreadAttack) {
            if (!firedSpreadAtMissile) {
              addDialogue("Captain: Gunnery control, belay that order! That's a missile, don't waste a spread! Sensors, you should have known better!", captainColor, defaultDialogueTime, captainPortraitFilePath);
            }
            firedSpreadAtMissile = true;
            // Continue with normal single missile firing
            isSpreadAttack = false;
          }
          
          // Calculate the determinant inside the square root
          const determinant = 4 * Math.pow(evx*dx + evy*dy, 2) - 
                              4 * (evx*evx + evy*evy - mspeed*mspeed) * distSquared;
          
          // Only proceed if the determinant is positive (solutions exist)
          if (determinant >= 0) {
            // Calculate solutions for time
            const t1 = 1/(evx*evx + evy*evy - mspeed*mspeed) * 
                     (-evx*exi - evy*eyi + evx*mxi + evy*myi - 0.5 * Math.sqrt(determinant));
            
            const t2 = 1/(evx*evx + evy*evy - mspeed*mspeed) * 
                     (-evx*exi - evy*eyi + evx*mxi + evy*myi + 0.5 * Math.sqrt(determinant));
            
            // Calculate the square root term for angle calculations
            const sqrtTerm = Math.sqrt(-evy*evy*dx*dx + 
                                       2*evx*evy*dx*dy - 
                                       evx*evx*dy*dy + 
                                       mspeed*mspeed*distSquared);
            
            // Calculate angles for both solutions
            const a1x = (-evy*dx*dy + evx*dy*dy + dx*sqrtTerm) / (mspeed*distSquared);
            const a1y = (evy*dx*dx + dy*(-evx*exi + evx*mxi + sqrtTerm)) / (mspeed*distSquared);
            const a1 = Math.atan2(a1y, a1x);
            
            const a2x = (-evy*dx*dy + evx*dy*dy - dx*sqrtTerm) / (mspeed*distSquared);
            const a2y = (evy*dx*dx - dy*(evx*exi - evx*mxi + sqrtTerm)) / (mspeed*distSquared);
            const a2 = Math.atan2(a2y, a2x);
            
            // Choose the best solution (positive time, earliest intercept)
            let selectedTime = null;
            let selectedAngle = null;
            
            if (t1 > 0 && (selectedTime === null || t1 < selectedTime)) {
              selectedTime = t1;
              selectedAngle = a1;
            }
            
            if (t2 > 0 && (selectedTime === null || t2 < selectedTime)) {
              selectedTime = t2;
              selectedAngle = a2;
            }

            // If selected time is greater than missile fuel time, reset selected time to null
            if (selectedTime > missileFuelTime) {
              selectedTime = null;
            } 

            // If we found a valid solution, launch the missile
            if (selectedTime !== null) {
              // this.launchMissileAlongAngle(selectedAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
              // If isSpreadAttack, instead fire a spread of missiles at the target and its immediate surroundings
              // Only do this if firing at a non-missile contact
              if (isSpreadAttack && !targetContact.isMissile) {
                // Check if the player ship is the launcher
                // and if firedFirstSpread is false
                // If so, write dialogue 
                if(this.contactType === "PLAYER" && !firedFirstSpread) {
                  addDialogue("Captain: Gunnery control, fire a spread at that contact!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                  firedFirstSpread = true;
                }

                // Calculate distance in radius units
                const distance = Math.sqrt(distSquared);
                
                // Calculate number of missiles based on distance
                // Add 1 missile for every spreadAttackMissilePerRadiusAmount * radius
                let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                
                // Set minimum and maximum number of missiles
                numMissiles = Math.max(2, numMissiles);
                
                // Calculate increased arming time (0.5 seconds per missile)
                const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                
                // Launch a spread of missiles
                const spreadAngle = Math.PI / 6; // 30 degrees
                for (let i = 0; i < numMissiles; i++) {
                  const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                  this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                }
                
                // Launch one more missile directly at the target
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              } else {
                
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
              }
            } else {
              // No valid solution found, launch directly at current position as fallback
              
              // NPC ships will never fire a spread at invalid targets
              if (isSpreadAttack && this.contactType !== "PLAYER") {
                // Just fire a single missile to conserve ammo
                this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
              } else {
                // For player, allow them to mess up and fire a spread if that's what they requested
                if (this.contactType === "PLAYER" && isSpreadAttack) {
                  // Calculate spread as in normal spread code
                  const distance = Math.sqrt(distSquared);
                  let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                  numMissiles = Math.max(2, numMissiles);
                  const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                  
                  // Direct angle toward target's current position
                  const selectedAngle = Math.atan2(dy, dx);
                  
                  // Launch spread
                  const spreadAngle = Math.PI / 6; // 30 degrees
                  for (let i = 0; i < numMissiles; i++) {
                    const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                    this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                  }
                  
                  // Launch direct missile too
                  this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                } else {
                  // Just fire a single missile for non-spread or non-player
                  this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
                }
              }
            }
          } else {
            // No intercept solution exists, launch directly at current position
            
            // NPC ships will never fire a spread at invalid targets
            if (isSpreadAttack && this.contactType !== "PLAYER") {
              // Just fire a single missile to conserve ammo
              this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
            } else {
              // For player, allow them to mess up and fire a spread if that's what they requested
              if (this.contactType === "PLAYER" && isSpreadAttack) {
                // Calculate spread as in normal spread code
                const distance = Math.sqrt(distSquared);
                let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                numMissiles = Math.max(2, numMissiles);
                const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                
                // Direct angle toward target's current position
                const selectedAngle = Math.atan2(dy, dx);
                
                // Launch spread
                const spreadAngle = Math.PI / 6; // 30 degrees
                for (let i = 0; i < numMissiles; i++) {
                  const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                  this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                }
                
                // Launch direct missile too
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              } else {
                // Just fire a single missile for non-spread or non-player
                this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
              }
            }
          }
        }
      }
      
      draw(deltaTime) {
        // If IFF is broadcasting, the contact should always be visible and updating its contact position
        if (this.iffBroadcasting) {
          this.visible = true;
          this.opacity = 1.0;
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
        }

        if (this.visible) {
          // Draw the contact at the last detected position
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          ctx.beginPath();
          ctx.arc(contactX, contactY, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${this.contactColor[0]}, ${this.contactColor[1]}, ${this.contactColor[2]}, ${this.opacity})`;
          ctx.fill();
          
          // Draw IFF bubble if broadcasting and mouse is nearby
          if (this.iffBroadcasting && typeof mouseX !== 'undefined' && typeof mouseY !== 'undefined') {
            // Calculate distance from mouse to contact
            const dx = mouseX - contactX;
            const dy = mouseY - contactY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate opacity based on distance (fully visible when close, fades out as distance increases)
            const iffOpacity = Math.max(0, 1 - (distance / iffBoxDisplayDistance));
            
            // Only draw if opacity > 0
            if (iffOpacity > 0) {
              // Draw IFF bubble
              const bubblePadding = 10;
              const lines = this.iffString.split('\n');
              const lineHeight = 16;
              const bubbleWidth = lines.reduce((max, line) => Math.max(max, ctx.measureText(line).width), 0) + (bubblePadding * 2);
              var bubbleHeight = ((lines.length + 1) * lineHeight) + (bubblePadding * 2); // Add 1 for the missile count line
              
              // Add extra height for missile count if it exists
              const hasMissiles = this.numMissiles !== undefined && this.numMissiles !== null;
              if (hasMissiles) {
                bubbleHeight += lineHeight;
              }
              
              // Calculate box position - default is to the right of the contact
              let boxX = contactX + 15;
              let boxY = contactY - 10;
              
              // Adjust if the box would go off the right edge of the canvas
              if (boxX + bubbleWidth > width) {
                boxX = contactX - bubbleWidth - 15; // Move to the left of the contact
              }
              
              // Adjust if the box would go off the top or bottom of the canvas
              if (boxY < 0) {
                boxY = 0; // Align with top of canvas
              } else if (boxY + bubbleHeight > height) {
                boxY = height - bubbleHeight; // Align with bottom of canvas
              }
              
              // Draw bubble background
              ctx.fillStyle = `rgba(0, 0, 0, ${iffOpacity * 0.7})`;
              ctx.fillRect(boxX, boxY, bubbleWidth, bubbleHeight);
              ctx.strokeStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.strokeRect(boxX, boxY, bubbleWidth, bubbleHeight);
              
              // Draw IFF string
              ctx.fillStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.font = "12px monospace";
              ctx.textAlign = "left";
              lines.forEach((line, i) => {
                ctx.fillText(line, boxX + bubblePadding, boxY + 15 + (i * lineHeight));
              });
              
              // Draw IFF status
              // ctx.fillStyle = `rgba(0, 255, 0, ${iffOpacity})`;
              // Frienly contacts have a green IFF broadcast, hostile contacts have a red IFF broadcast
              // Neutral contacts have a yellow IFF broadcast. Ghosts should not have an IFF broadcast but if they do, it should be white
              if (this.contactType === "FRIENDLY" || this.contactType === "PLAYER") {
                ctx.fillStyle = `rgba(0, 255, 0, ${iffOpacity})`;
              } else if (this.contactType === "HOSTILE") {
                ctx.fillStyle = `rgba(255, 0, 0, ${iffOpacity})`;
              } else if (this.contactType === "NEUTRAL") {
                ctx.fillStyle = `rgba(255, 255, 0, ${iffOpacity})`;
              } else {
                ctx.fillStyle = `rgba(255, 255, 255, ${iffOpacity})`;
              }
              ctx.fillText("IFF: BROADCASTING", boxX + bubblePadding, boxY + 15 + (lines.length * lineHeight));
              
              // Show missile count if available
              if (hasMissiles) {
                ctx.fillText(`MISSILES: ${this.numMissiles}`, boxX + bubblePadding, boxY + 15 + ((lines.length + 1) * lineHeight));
              }
            }
          }
          
          // Fade out the contact - now based on time
          this.opacity -= this.fadeSpeed * deltaTime;
          if (this.opacity <= 0) {
            this.visible = false;
          }
        }
        
        // Draw ELINT radiation cone if detected
        if (this.radiationDetected) {
          const startAngle = this.realBearing - ELINTHalfAngle;
          const endAngle = this.realBearing + ELINTHalfAngle;
          
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, startAngle, endAngle);
          ctx.lineTo(centerX, centerY);
          ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
          ctx.fill();
          
          // Draw the ELINT cone boundary lines
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(startAngle), 
            centerY + radius * Math.sin(startAngle)
          );
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(endAngle), 
            centerY + radius * Math.sin(endAngle)
          );
          ctx.strokeStyle = "#FFFF00";
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
    }

    // Extend Contacts to add heat seeking missiles
    class MissileContact extends Contact {
      constructor(bearing, distance, targetContact, fuelTime, contactType, armingTime, movementSpeed = 10) {
        // If the contact type is not one of the accepted types, default to "HOSTILE"
        if (!acceptedTypes.includes(contactType)) {
          contactType = "HOSTILE";
        }
        // Figure out the movement direction based on the target contact and the current bearing and distance
        // We are at (bearing, distance) and the target is at (targetContact.bearing, targetContact.distance), in polar coordinates
        // We want to move towards the target, so we need to calculate the angle between the two points
        // This is done by calculating the angle between the two points in cartesian coordinates and then converting it to polar coordinates
        // Figure out our position in cartesian coordinates
        const missileX = Math.cos(bearing) * distance;
        const missileY = Math.sin(bearing) * distance;
        // Figure out the target position in cartesian coordinates
        // so long as the target contact is not null or undefined or something like that
        if (targetContact) {
          var targetXv = Math.cos(targetContact.bearing) * targetContact.distance;
          var targetYv = Math.sin(targetContact.bearing) * targetContact.distance;
        } else {
          // If the target contact is null or undefined, default to the point at the radius and bearing
          var targetXv = Math.cos(bearing) * radius;
          var targetYv = Math.sin(bearing) * radius;
        }
        const targetX = targetXv;
        const targetY = targetYv;
        // Calculate the angle to the target
        const targetAngle = Math.atan2(targetY - missileY, targetX - missileX);

        // If the contact is friendly, create it like so
        if (contactType === "FRIENDLY") {
          // Create a friendly missile
          super(
            bearing, distance, 3, // bearing, starting distance, size
            movementSpeed, 0, targetAngle, // movementSpeed (fast enough to catch just about anything else), directionChangeFrequency (none as it should go only in one direction), movementDirection (direction of the target)
            true, 1.0, true, 1, // visible, opacity, immense radiation emission "due to really powerful engine" or something like that
            true, 1.0, true, 1.0, // fully radar and thermal detectable
            true, "HEAT SEEKING MISSILE\nACTIVE GUIDANCE\nFRIENDLY FIRE", [255, 0, 255], // IFF broadcasting
            contactType // Contact type
          );
        } else {
          // Create a hostile missile
          super(
            bearing, distance, 3, // bearing, starting distance, size
            movementSpeed, 0, targetAngle, // movementSpeed (fast enough to catch just about anything else), directionChangeFrequency (none as it should go only in one direction), movementDirection 
            false, 0, true, 1, // visible, opacity, immense radiation emission "due to really powerful engine" or something like that
            true, 1.0, true, 1.0, // fully radar and thermal detectable
            false, "", [255, 0, 0], // IFF broadcasting
            contactType // Contact type
          );
        }
        
        this.isMissile = true;
        this.targetContact = targetContact;
        this.thermalScanRadius = missileScanRadius;
        this.hasTarget = false;
        
        // Add fuel time property (in seconds)
        this.fuelTime = fuelTime; // Keeps track of original fuel time
        this.fuelRemaining = fuelTime;
        
        // Missile scan properties
        this.scanWidth = missileScanWidth; // Use the same width as the main scanner
        this.scanAngle = 0; // Current scan offset angle
        this.scanReversed = false; // Direction of scan
        this.scanCenter = 0; // Scan is centered forward of the missile

        // Arming time - Missile will not trigger collision check/explosion until armed
        this.armingTime = armingTime;

        // // debug
        // this.positionHistoryString = "Time = 0: " + centerX + ", " + centerY + "\n";
        // this.positionHistory = [{x: centerX, y: centerY, time: 0}];
      }
      
      updatePosition(deltaTime) {
        // debug
        // // get previous time
        // const prevTime = this.positionHistory[this.positionHistory.length - 1].time;
        // this.positionHistoryString += "Time = " + deltaTime + prevTime + ": " + this.realDistance * Math.cos(this.realBearing) + centerX + ", " + this.realDistance * Math.sin(this.realBearing) + centerY + "\n";
        // this.positionHistory.push({x: this.realDistance * Math.cos(this.realBearing) + centerX, y: this.realDistance * Math.sin(this.realBearing) + centerY, time: deltaTime + prevTime});

        // If not armed, count down arming time
        if (this.armingTime > 0) {
          this.armingTime -= deltaTime;
        }

        // Update fuel remaining
        this.fuelRemaining -= deltaTime;
        
        // Self-destruct if out of fuel
        if (this.fuelRemaining <= 0) {
          // Create explosion effect
          createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                         centerY + this.realDistance * Math.sin(this.realBearing));
          
          // Remove from contacts array
          const index = contacts.indexOf(this);
          if (index > -1) {
            contacts.splice(index, 1);
          }
          return;
        }
        
        // Update scan angle
        if (this.scanReversed) {
          this.scanAngle -= (Math.PI * missileScanSpeed / 180) * deltaTime;
          if (this.scanAngle <= -this.scanWidth/2) {
            this.scanAngle = -this.scanWidth/2;
            this.scanReversed = false;
          }
        } else {
          this.scanAngle += (Math.PI * missileScanSpeed / 180) * deltaTime;
          if (this.scanAngle >= this.scanWidth/2) {
            this.scanAngle = this.scanWidth/2;
            this.scanReversed = true;
          }
        }
        
        // Scan for thermal contacts if no target yet and armed 
        if (!this.hasTarget && this.armingTime <= 0) {
          // Use the missile's movement direction as its orientation.
          const missileOrientation = this.movementDirection;
          const absoluteScanAngle = missileOrientation + this.scanAngle;
          
          // Look for contacts in thermal scan range
          for (let contact of contacts) {
            if (contact === this) continue; // Skip self
            
            // Determine missile and contact positions in cartesian coordinates
            const missileX = centerX + this.realDistance * Math.cos(this.realBearing);
            const missileY = centerY + this.realDistance * Math.sin(this.realBearing);
            const contactX = centerX + contact.realDistance * Math.cos(contact.realBearing);
            const contactY = centerY + contact.realDistance * Math.sin(contact.realBearing);
            
            // Calculate position difference and distance
            const dx = contactX - missileX;
            const dy = contactY - missileY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate angle to contact relative to the missile's orientation
            const angleToContact = Math.atan2(dy, dx);
            const angleDiff = normalizeAngle(angleToContact - missileOrientation);
            
            // Check if contact is within scan arc and radius
            if (distance < this.thermalScanRadius &&
                Math.abs(angleDiff - this.scanAngle) < 0.1 &&
                contact.thermalDetectable) {
              this.targetContact = contact;
              this.hasTarget = true;
              break;
            }
          }
        }
        
        // Update missile direction if it has a target
        if (this.hasTarget && this.targetContact && !this.targetContact.destroyed) {
          // Calculate direction to target
          const targetX = Math.cos(this.targetContact.realBearing) * this.targetContact.realDistance;
          const targetY = Math.sin(this.targetContact.realBearing) * this.targetContact.realDistance;
          const missileX = Math.cos(this.realBearing) * this.realDistance;
          const missileY = Math.sin(this.realBearing) * this.realDistance;
          
          // Set movement direction toward target
          this.movementDirection = Math.atan2(targetY - missileY, targetX - missileX);
        }
        
        // Call parent updatePosition
        super.updatePosition(deltaTime);
        
        // Check for collisions with contacts, but only if it has a target
        if (this.hasTarget) {
          this.checkCollisions();
        }
      }
      
      checkCollisions() {
        // Only check for collisions if armed
        if (this.armingTime > 0) return;

        for (let i = 0; i < contacts.length; i++) {
          const contact = contacts[i];
          if (contact === this) continue; // Skip self and other missiles
          
          // Calculate distance between missile and contact
          const dx = Math.cos(contact.realBearing) * contact.realDistance - Math.cos(this.realBearing) * this.realDistance;
          const dy = Math.sin(contact.realBearing) * contact.realDistance - Math.sin(this.realBearing) * this.realDistance;
          const distance = Math.sqrt(dx*dx + dy*dy);
          
          // If collision detected with a thermal detectable contact, destroy both
          if (distance < (this.size + contact.size) && contact.thermalDetectable) {
            // Mark both as destroyed
            this.destroyed = true;
            contact.destroyed = true;
            
            // Create explosion effect
            createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                           centerY + this.realDistance * Math.sin(this.realBearing));
            
            // Remove both from contacts array
            console.log("Missile collided with contact:", contact);
            console.log("Missile destroyed:", this);

            // Check if it was a friendly missile that collided with a hostile missile or a hostile missile that collided with a friendly missile
            // Also ensure this dialogue only plays once using shotDownFirstMissile
            if ((this.isMissile && this.contactType === "FRIENDLY" && contact.isMissile && contact.contactType === "HOSTILE") ||
                (this.isMissile && this.contactType === "HOSTILE" && contact.isMissile && contact.contactType === "FRIENDLY")) {
              if (!shotDownFirstMissile) {
                addDialogue("Engineer: Enemy missile destroyed!", engineerColor);
                shotDownFirstMissile = true;
              }
            }

            contacts.splice(contacts.indexOf(this), 1);
            contacts.splice(contacts.indexOf(contact), 1);
            return;
          }
        }
      }
      
      draw(deltaTime) {
        // Draw the thermal scan cone if visible and friendly
        // Friendly contacts are "sending missile telemetry" to the player
        // Doesn't make sense for hostile or neutral contacts to do this
        if (this.visible && this.contactType === "FRIENDLY") {
          this.drawScanCone();
        }
        
        // Call parent draw method
        super.draw(deltaTime);
        
        // Draw fuel indicator if visible and friendly (see earlier comment about telemetry)
        if (this.visible && this.contactType === "FRIENDLY") {
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          // Draw fuel bar
          const barWidth = 20;
          const barHeight = 4;
          const fuelPercentage = this.fuelRemaining / this.fuelTime;
          
          // Draw fuel background
          ctx.fillStyle = "rgba(100, 100, 100, 0.7)";
          ctx.fillRect(contactX - barWidth/2, contactY + 8, barWidth, barHeight);
          
          // Draw remaining fuel - color changes as fuel depletes
          let fuelColor;
          if (fuelPercentage > 0.6) {
            fuelColor = "rgba(0, 255, 0, 0.7)"; // Green
          } else if (fuelPercentage > 0.3) {
            fuelColor = "rgba(255, 255, 0, 0.7)"; // Yellow
          } else {
            fuelColor = "rgba(255, 0, 0, 0.7)"; // Red
          }
          
          ctx.fillStyle = fuelColor;
          ctx.fillRect(contactX - barWidth/2, contactY + 8, barWidth * fuelPercentage, barHeight);
          
          // Update IFF string with fuel information
          const fuelSeconds = Math.round(this.fuelRemaining);
          this.iffString = `HEAT SEEKING MISSILE\nACTIVE GUIDANCE\nFUEL: ${fuelSeconds}s REMAINING`;
        }
      }
      
      drawScanCone() {
        // Calculate position on screen
        const missileX = centerX + this.realDistance * Math.cos(this.realBearing);
        const missileY = centerY + this.realDistance * Math.sin(this.realBearing);
        
        // Calculate orientation of missile (direction of movement)
        const missileOrientation = this.movementDirection;
        
        // Calculate start and end angles for the scan cone
        const absoluteScanAngle = missileOrientation + this.scanAngle;
        const startAngle = missileOrientation + this.scanCenter - this.scanWidth/2;
        const endAngle = missileOrientation + this.scanCenter + this.scanWidth/2;
        
        // Draw the thermal scan area
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.arc(missileX, missileY, this.thermalScanRadius, startAngle, endAngle);
        ctx.lineTo(missileX, missileY);
        ctx.fillStyle = "rgba(0, 0, 255, 0.2)"; // Thermal blue for missile scan
        ctx.fill();
        
        // Draw the thermal scan boundary lines
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(startAngle), 
          missileY + this.thermalScanRadius * Math.sin(startAngle)
        );
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(endAngle), 
          missileY + this.thermalScanRadius * Math.sin(endAngle)
        );
        ctx.strokeStyle = "#0000FF"; // Blue outline
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw the active scan line
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(absoluteScanAngle), 
          missileY + this.thermalScanRadius * Math.sin(absoluteScanAngle)
        );
        ctx.strokeStyle = "#0000FF"; // Blue
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    function drawBackground(deltaTime) {
      // Draw fading overlay - fade rate now per second
      ctx.fillStyle = `rgba(0, 0, 0, ${fadeRate * deltaTime})`;
      ctx.fillRect(0, 0, width, height);
      
      // Draw radar circle
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.strokeStyle = "#00AA00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw grid lines
      drawGrid();
    }
    
    function drawGrid() {
      // Draw crosshairs
      ctx.beginPath();
      ctx.moveTo(centerX - radius, centerY);
      ctx.lineTo(centerX + radius, centerY);
      ctx.moveTo(centerX, centerY - radius);
      ctx.lineTo(centerX, centerY + radius);
      ctx.strokeStyle = "#004400";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw concentric circles with range readouts
      const rangeLabels = ["0.25ls", "0.5ls", "0.75ls", "1ls"];
      
      for (let i = 1; i <= 4; i++) {
        const circleRadius = radius * i/4;
        // Draw the circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = "#004400";
        ctx.stroke();
        
        // Draw the range readout at the top of each circle
        ctx.fillStyle = "#00FF00";
        ctx.font = "12px monospace";
        ctx.textAlign = "center";
        ctx.fillText(rangeLabels[i-1], centerX, centerY - circleRadius);
      }
    }
    
    function drawRadarLine() {
      // Calculate the endpoint of the rotating line
      const endX = centerX + radius * Math.cos(angle);
      const endY = centerY + radius * Math.sin(angle);

      // Draw the rotating line
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw radar sweep (the glow effect)
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0, 
        centerX, centerY, radius
      );
      gradient.addColorStop(0, "rgba(0, 255, 0, 0.2)");
      gradient.addColorStop(1, "rgba(0, 255, 0, 0)");
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, angle - 0.2, angle, false);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
    
    function drawThermalScan() {
      // Draw the thermal scan zone
      const startAngle = thermalScanCenter - thermalScanWidth/2;
      const endAngle = thermalScanCenter + thermalScanWidth/2;
      
      // Draw the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, thermalScanRadius, startAngle, endAngle);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = "rgba(0, 0, 255, 0.2)";
      ctx.fill();
      
      // Draw the thermal scan boundary lines
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(startAngle), 
                 centerY + thermalScanRadius * Math.sin(startAngle));
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(endAngle), 
                 centerY + thermalScanRadius * Math.sin(endAngle));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw a line sweeping across the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(thermalScanAngle + thermalScanCenter), 
                 centerY + thermalScanRadius * Math.sin(thermalScanAngle + thermalScanCenter));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // For drawing how many missiles are left in stock on the player ship
    // Draws in the top left corner of the screen
    function drawCurrentMissiles() {
      const playerContact = contacts[0]; // Assuming the player ship is the first contact

      if (playerContact && playerContact.visible && playerContact.numMissiles !== undefined) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(10, 10, 150, 50);
        
        ctx.fillStyle = "#00FF00";
        ctx.font = "20px monospace";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText(`MISSILES: ${playerContact.numMissiles}`, 20, 20);
      }

    }

    // Function to add a new dialogue message
    function addDialogue(text, color, duration = defaultDialogueTime, imageFilePath) {
      // Add the message to the array with current time + duration as expiry time
      dialogueMessages.push({
      text: text,
      color: color,
      expiryTime: Date.now() + (duration * 1000), // Multiply by 1000 to convert to milliseconds
      image: imageFilePath
      });
    }

    // Function to draw dialogue messages in the top right corner
    function drawDialogue() {
      const currentTime = Date.now();
      
      // If no messages or all messages expired, don't draw anything
      if (dialogueMessages.length === 0 || dialogueMessages[dialogueMessages.length - 1].expiryTime < currentTime) {
        return;
      }
      
      const maxWidth = 375;
      const padding = 15;
      const lineHeight = 20;
      let currentY = 10; // Start at the top
      
      // Image dimensions
      const imageWidth = 80;
      const imageHeight = 120;
      
      // Draw messages from newest to oldest
      for (let i = dialogueMessages.length - 1; i >= 0; i--) {
        const message = dialogueMessages[i];
        
        // Skip expired messages
        if (message.expiryTime < currentTime) {
          continue;
        }
        
        // Split text into lines for wrapping
        const words = message.text.split(' ');
        let lines = [];
        let currentLine = words.length > 0 ? words[0] : '';
        
        ctx.font = "16px Arial";
        
        // Create wrapped lines
        for (let j = 1; j < words.length; j++) {
          const testLine = currentLine + ' ' + words[j];
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth) {
            lines.push(currentLine);
            currentLine = words[j];
          } else {
            currentLine = testLine;
          }
        }
        lines.push(currentLine);
        
        // Calculate box dimensions based on whether there's an image
        // Has image is true if the image property is defined.
        const hasImage = message.image !== undefined && message.image !== null && message.image !== "" ;
        const boxWidth = maxWidth + (padding * 2) + (hasImage ? imageWidth + padding : 0);
        const boxHeight = Math.max((lines.length * lineHeight) + (padding * 2), hasImage ? imageHeight + (padding * 2) : 0);
        
        // Check if we're going off-screen and need to stop drawing
        if (currentY + boxHeight > height) {
          break;
        }
        
        const boxX = width - boxWidth - 10;
        const boxY = currentY;
        
        // Draw the background box
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Draw the image if specified
        if (hasImage) {
          // If image hasn't been loaded yet, create and cache it
          if (!message.imageObject) {
            message.imageObject = new Image();
            message.imageObject.src = message.image;
          }
          
          // Position image inside the box with some padding
          const imgX = boxX + padding;
          const imgY = boxY + (boxHeight - imageHeight) / 2; // Center vertically
          
          // Only draw if the image is loaded
          if (message.imageObject.complete && message.imageObject.naturalWidth > 0) {
            ctx.drawImage(message.imageObject, imgX, imgY, imageWidth, imageHeight);
          }
        }
        
        // Draw the text - right aligned if no image, left aligned if there is an image
        ctx.fillStyle = message.color;
        ctx.textAlign = hasImage ? "left" : "right";
        ctx.textBaseline = "top";
        
        // Calculate text position
        const textX = hasImage 
          ? boxX + imageWidth + (padding * 2) // If image, position text after image
          : boxX + boxWidth - padding; // If no image, position from right edge
        
        const textY = boxY + (hasImage 
          ? (boxHeight - (lines.length * lineHeight)) / 2 // Center text vertically if there's an image
          : padding); // Default padding if no image
        
        lines.forEach((line, index) => {
          ctx.fillText(line, textX, textY + (index * lineHeight));
        });
        
        // Update Y position for next message
        currentY += boxHeight + 5; // 5px gap between boxes
      }
    }

    // Variables for message history
    let isViewingMessageHistory = false;
    let messageHistoryScrollPosition = 0;
    
    // Function to draw message history window
    function drawMessageHistory() {
      // Clear the screen with a dark background
      ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
      ctx.fillRect(0, 0, width, height);
      
      // Calculate window dimensions
      const margin = 50;
      const windowWidth = width - (margin * 2);
      const windowHeight = height - (margin * 2);
      
      // Draw window background
      ctx.fillStyle = "rgba(20, 20, 30, 0.8)";
      ctx.fillRect(margin, margin, windowWidth, windowHeight);
      ctx.strokeStyle = "rgba(0, 255, 255, 0.7)";
      ctx.lineWidth = 2;
      ctx.strokeRect(margin, margin, windowWidth, windowHeight);
      
      // Draw title
      ctx.font = "bold 24px Arial";
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText("MESSAGE HISTORY", centerX, margin + 20);
      
      // Draw navigation instructions
      ctx.font = "16px Arial";
      ctx.fillStyle = "#AAAAAA";
      ctx.fillText("Use UP/DOWN arrows to scroll, press H to return", centerX, margin + 50);
      
      // Draw divider line
      ctx.beginPath();
      ctx.moveTo(margin + 20, margin + 80);
      ctx.lineTo(margin + windowWidth - 20, margin + 80);
      ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Set up scrollable area
      const contentAreaTop = margin + 100;
      const contentAreaHeight = windowHeight - 120;
      const contentAreaBottom = contentAreaTop + contentAreaHeight;
      
      // Clip to content area
      ctx.save();
      ctx.beginPath();
      ctx.rect(margin + 20, contentAreaTop, windowWidth - 40, contentAreaHeight);
      ctx.clip();
      
      // Display messages
      const lineHeight = 24;
      const visibleMessages = [...dialogueMessages].reverse(); // Show newest messages first
      let y = contentAreaTop - messageHistoryScrollPosition;
      
      ctx.textAlign = "left";
      ctx.font = "16px Arial";
      
      visibleMessages.forEach(message => {
        // Format timestamp
        const timestamp = new Date(message.expiryTime - (defaultDialogueTime * 1000));
        const timeString = timestamp.toTimeString().split(' ')[0];
        
        // Draw timestamp
        ctx.fillStyle = "#888888";
        ctx.fillText(timeString, margin + 40, y);
        
        // Calculate text dimensions and position
        const textMaxWidth = windowWidth - 250;
        
        // Split text into lines for wrapping
        const words = message.text.split(' ');
        let lines = [];
        let currentLine = words.length > 0 ? words[0] : '';
        
        // Create wrapped lines
        for (let i = 1; i < words.length; i++) {
          const testLine = currentLine + ' ' + words[i];
          const metrics = ctx.measureText(testLine);
          if (metrics.width > textMaxWidth) {
            lines.push(currentLine);
            currentLine = words[i];
          } else {
            currentLine = testLine;
          }
        }
        lines.push(currentLine);
        
        // Draw message text
        ctx.fillStyle = message.color;
        lines.forEach((line, index) => {
          ctx.fillText(line, margin + 150, y + (index * lineHeight));
        });
        
        // Move Y position for next message
        y += (lines.length * lineHeight) + 15;
      });
      
      // Restore clipping
      ctx.restore();
      
      // Draw scroll indicators if needed
      if (messageHistoryScrollPosition > 0) {
        // Draw up arrow
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        ctx.moveTo(width - margin - 30, contentAreaTop + 20);
        ctx.lineTo(width - margin - 15, contentAreaTop + 5);
        ctx.lineTo(width - margin - 45, contentAreaTop + 5);
        ctx.closePath();
        ctx.fill();
      }
      
      // Check if we need to show down arrow (if more content exists below)
      const totalContentHeight = visibleMessages.reduce((total, msg) => {
        const lines = Math.ceil(ctx.measureText(msg.text).width / (windowWidth - 150));
        return total + (lines * lineHeight) + 15;
      }, 0);
      
      if (messageHistoryScrollPosition < totalContentHeight - contentAreaHeight && totalContentHeight > contentAreaHeight) {
        // Draw down arrow
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        ctx.moveTo(width - margin - 30, contentAreaBottom - 20);
        ctx.lineTo(width - margin - 15, contentAreaBottom - 5);
        ctx.lineTo(width - margin - 45, contentAreaBottom - 5);
        ctx.closePath();
        ctx.fill();
      }
    }

    // Draws the game over message in the center of the screen
    function drawGameOver() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, width, height);
      
      ctx.font = "bold 48px Arial";
      ctx.fillStyle = gameOverColor;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(gameOverMessage, centerX, centerY);
    }

    // Draws the pause menu in the center of the screen
    // Says "PAUSED" in big centered letters, then below it "Press P to unpause"
    function drawPauseMenu() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, width, height);
      
      ctx.font = "bold 48px Arial";
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("PAUSED", centerX, centerY - 20);
      ctx.font = "24px Arial";
      ctx.fillText("Press P to unpause", centerX, centerY + 20);
      ctx.fillText("Press H for message history", centerX, centerY + 60);
    }
    
    function normalizeAngle(a) {
      // Normalize angle to be between -pi and pi
      return a - Math.PI * 2 * Math.floor((a + Math.PI) / (Math.PI * 2));
    }
      
    // Function to create custom timeouts that respect pause state
    function createTimeout(callback, delay) {
      window.customTimeouts.push({
        callback: callback,
        delay: delay,
        elapsed: 0
      });
    }

    // Function to create custom intervals that respect pause state
    function createInterval(callback, delay) {
      const intervalId = Date.now() + Math.random(); // Generate a unique ID
      
      if (!window.customIntervals) {
        window.customIntervals = [];
      }
      
      window.customIntervals.push({
        callback: callback,
        delay: delay,
        elapsed: 0,
        id: intervalId
      });
      
      return intervalId; // Return ID so it can be cleared later
    }

    // Function to clear a custom interval
    function uncreateInterval(intervalId) {
      if (!window.customIntervals) return;
      
      const index = window.customIntervals.findIndex(interval => interval.id === intervalId);
      if (index !== -1) {
        window.customIntervals.splice(index, 1);
      }
    }

    
    function animate(currentTime) {

      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $operation2Allowed === "undefined" || $operation2Allowed === null || !$operation2Allowed) {
        // Cancel the animation frame if the operation is not allowed to run
        return;
      }
    
      // Game over check
      if (gameOver) {
        // If viewing message history, draw that instead of game over menu
        if (isViewingMessageHistory) {
          drawMessageHistory();
        } else {
          // Draw game over message
          drawGameOver();
        }

        // Keep animating, but only up to here
        requestAnimationFrame(animate)
        return;
      }
      
      // Check if game should end now
      // Check if all player ships are gone
      if (areAllContactsGone("PLAYER")) {
        gameOver = true;
        $playerWonO2 = false;
        gameOverMessage = "DEFEAT!";
        gameOverColor = "red";
        // Play defeat sound
        const audio = new Audio("../assets/defeat.mp3");
        audio.play();
      }

      // Check if all hostile contacts are gone
      if (areAllContactsGone("HOSTILE")) {
        gameOver = true;
        $playerWonO2 = true;
        gameOverMessage = "VICTORY!";
        gameOverColor = "green";
        // Play victory sound
        const audio = new Audio("../assets/victory.mp3");
        audio.play();
      }
      
      // Calculate time since last frame
      const deltaTime = ((currentTime - lastFrameTime) / 1000) * deltaTimeMultiplier; // Convert to seconds, then scale by deltaTimeMultiplier
      // Helps with keeping track of unpaused time
      let trueDeltaTimeMillis = currentTime - lastFrameTime;
      lastFrameTime = currentTime;

      // Pause check is placed here to ensure deltaTime will not jump when unpausing
      if (gamePaused) {
        // If viewing message history, draw that instead of pause menu
        if (isViewingMessageHistory) {
          drawMessageHistory();
        } else {
          // Pause menu is drawn in the event listener
        }

        // Keep animating, but only up to here
        requestAnimationFrame(animate)
        return;
      }

      // Keep track of how much time has been spent outside of pause
      unpausedElapsedTimeMillis += trueDeltaTimeMillis;
      
      // Custom timeout handling system
      if (!window.customTimeouts) {
        window.customTimeouts = [];
      }
      
      // Process any active timeouts
      for (let i = window.customTimeouts.length - 1; i >= 0; i--) {
        const timeout = window.customTimeouts[i];
        timeout.elapsed += trueDeltaTimeMillis;
        
        if (timeout.elapsed >= timeout.delay) {
          // Execute the callback and remove from array
          timeout.callback();
          window.customTimeouts.splice(i, 1);
        }
      }

      // Custom interval handling system
      if (!window.customIntervals) {
        window.customIntervals = [];
      }
    
      // Process any active intervals
      for (let i = window.customIntervals.length - 1; i >= 0; i--) {
        // Check if the interval still exists (may have been removed by another callback)
        if (i < window.customIntervals.length) {
          const interval = window.customIntervals[i];

          // Make sure interval is defined before trying to use it
          // Shouldn't be necessary, yet if this check is not here, the tutorial mission breaks after the missiles collide
          if (interval) {
            // Only increment elapsed time when game is not paused
            interval.elapsed += trueDeltaTimeMillis;

            if (interval.elapsed >= interval.delay) {
              try {
                // Execute the callback but don't remove from array
                interval.callback();
                // Reset elapsed time for next interval
                interval.elapsed = 0;
              } catch (error) {
                console.error("Error in interval callback:", error);
                // Remove problematic interval
                window.customIntervals.splice(i, 1);
              }
            }
          } else {
            // Remove undefined interval if it somehow exists
            window.customIntervals.splice(i, 1);
          }
        }
      }


      // Initial dialogue
      if (!response1 && !response1a) {
        response1a = true;
        addDialogue("Engineer: Radar's been acting up. I think I'm seeing ghosts, although we have a faint but consistent contact somewhere between 110 and 80 degrees.", engineerColor);
        
        createTimeout(() => {
          response1 = true;
        }, 5000);
      }

      if (response1 && !response2 && !response2a) {
        response2a = true;
        createTimeout(() => {
          addDialogue("Captain: I don't like the sound of that last contact. Keep me informed if anything changes. That distress call could have attracted unwanted attention.", captainColor, defaultDialogueTime, captainPortraitFilePath);
          response2 = true;
        }, 4000);
      }

      if (response2 && !response3 && !response3a) {
        response3a = true;
        createTimeout(() => {
          addDialogue("Engineer: We have an incoming broadcast, bearing 90 degrees!", engineerColor);
          response3 = true;
        }, 5000);
      }

      if (response3 && !response4 && !response4a) {
        response4a = true;
        createTimeout(() => {
          addDialogue("Captain: Put it through.", captainColor, 4, captainPortraitFilePath);
          
          createTimeout(() => {
            addDialogue("???: Hello prey. You would do well to cut engines and power down your weapons.", unidentifiedColor);
            response4 = true;
          }, 6000);
        }, 3000);
      }

      if (response4 && !response5 && !response5a) {
        response5a = true;
        createTimeout(() => {
          addDialogue("Captain: I will do no such thing. Who do you think you are, ordering around a Central Republic warship?", captainColor, defaultDialogueTime, captainPortraitFilePath);
          
          createTimeout(() => {
            addDialogue("Corsair: The man commanding the pirates and the battlecruiser chasing you. Onboard, I have over one thousand extended range missiles loaded and ready to fire.", pirateColor);
            
            createTimeout(() => {
              addDialogue("Corsair: Now I will repeat my dema-", pirateColor, 3);
              
              createTimeout(() => {
                addDialogue("Captain: Over my dead body. I don't care what you have. Nobody pushes the Republic around! Least of all a rag tag band of vermin!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                
                createTimeout(() => {
                  addDialogue("Corsair: I plan on it being over your dead body. But, if you surrender now, the rest of your crew will get to live! If you flee, I will just have to kill all of you. And to the crew of the ship I see before me, I offer boundless riches to the individual brave enough to bring me the head of the pig I am speaking with.", pirateColor, 12);
                  
                  createTimeout(() => {
                    addDialogue("Captain: Your cynicism appalls me! I have five hundred officers and ratings willing to die for the republic! Your lies fall on deaf ears, scum!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                    
                    createTimeout(() => {
                      addDialogue("Captain: Shut off that transmission. Helm, start warming up the engines. Get us away from that battlecruiser. General quarters, all hands man your battlestations!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                      
                      createTimeout(() => {
                        addDialogue("Captain: Sensors, I'm networking you into the fire control computer. Help gunnery control shoot down any incoming missiles.", captainColor, defaultDialogueTime, captainPortraitFilePath);
                        
                        createTimeout(() => {
                          addDialogue("Engineer: Affirmative captain.", engineerColor);
                          
                          // Enable firing capabilities for player
                          allowedToFire = true;
                          allowedToFireAtSpot = true;
                          
                          // Prepare for first attack
                          response5 = true;
                        }, 3000);
                      }, 8000);
                    }, 8000);
                  }, 12000);
                }, 8000);
              }, 2500);
            }, 8000);
          }, 8000);
        }, 8000);
      }

      // First missile attack - Four missiles fired in sequence
      if (response5 && !response6 && !response6a) {
        response6a = true;
        createTimeout(() => {
          const pirateShip = contacts[1]; // The hostile battlecruiser
          
          addDialogue("Engineer: Captain! I'm detecting missile launches from the enemy vessel!", engineerColor);
          
          // Launch first missile
          pirateShip.launchMissileAtContact(contacts[0], tartarusMissileFuelTime, tartarusMissileArmingTime, tartarusMissileSpeed, false);
          
          // Launch second missile after a delay
          createTimeout(() => {
            pirateShip.launchMissileAtContact(contacts[0], tartarusMissileFuelTime, tartarusMissileArmingTime, tartarusMissileSpeed, false);
            
            // Launch third missile after a delay
            createTimeout(() => {
              pirateShip.launchMissileAtContact(contacts[0], tartarusMissileFuelTime, tartarusMissileArmingTime, tartarusMissileSpeed, false);
              
              // Launch fourth missile after a delay
              createTimeout(() => {
                pirateShip.launchMissileAtContact(contacts[0], tartarusMissileFuelTime, tartarusMissileArmingTime, tartarusMissileSpeed, false);
                
                // Set a check to see when all missiles are destroyed
                const checkMissiles = createInterval(() => {
                  const activeMissiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE").length;
                  
                  if (activeMissiles === 0) {
                    uncreateInterval(checkMissiles);
                    response6 = true;
                  }
                }, 1000);
                
              }, 2000);
            }, 2000);
          }, 2000);
        }, 10000);
      }

      // Comment after first wave of missiles is destroyed
      if (response6 && !response7 && !response7a) {
        response7a = true;
        createTimeout(() => {
          addDialogue("Captain: That was too easy. They're only probing us. I don't like it. Be on the lookout for tricks.", captainColor, defaultDialogueTime, captainPortraitFilePath);
          
          // Prepare for second attack with zig-zag missiles
          createTimeout(() => {
            const pirateShip = contacts[1]; // The hostile battlecruiser

            addDialogue("Engineer: More missile launches detected!", engineerColor);

            // Launch two zig-zag missiles
            const playerBearing = Math.atan2(
              -Math.sin(pirateShip.realBearing) * pirateShip.realDistance,
              -Math.cos(pirateShip.realBearing) * pirateShip.realDistance
            );

            // Create off-angled missiles that will change course
            pirateShip.launchMissileAlongAngle(playerBearing + Math.PI/6, tartarusMissileFuelTime, tartarusMissileArmingTime, tartarusMissileSpeed);

            createTimeout(() => {
              pirateShip.launchMissileAlongAngle(playerBearing - Math.PI/6, tartarusMissileFuelTime, tartarusMissileArmingTime, tartarusMissileSpeed);

              // Get reference to the missiles we just launched
              const missiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE");

              if (missiles.length >= 2) {
                // Store the time each missile was created to identify them reliably
                const missile1Id = Date.now();
                const missile2Id = Date.now() + 1;

                // Add zigzag properties to the missiles
                missiles[missiles.length-1].zigzagState = true;  // Last created missile
                missiles[missiles.length-1].missileId = missile2Id;
                missiles[missiles.length-2].zigzagState = false; // Second-to-last created missile
                missiles[missiles.length-2].missileId = missile1Id;

                // Setup course changes for both missiles
                const zigzagInterval = createInterval(() => {
                  const activeMissiles = contacts.filter(c => 
                    c.isMissile && 
                    c.contactType === "HOSTILE" && 
                    (c.missileId === missile1Id || c.missileId === missile2Id)
                  );
                
                  if (activeMissiles.length === 0) {
                    uncreateInterval(zigzagInterval);
                    response7 = true;
                    return;
                  }
                
                  // Make each active missile change direction in zigzag pattern
                  for (let missile of activeMissiles) {
                    // Check distance to player
                    const distToPlayer = Math.sqrt(
                      Math.pow(Math.cos(missile.realBearing) * missile.realDistance, 2) + 
                      Math.pow(Math.sin(missile.realBearing) * missile.realDistance, 2)
                    );
                  
                    if (distToPlayer < radius * 0.25) {
                      // Close to player, home in
                      missile.targetContact = contacts[0];
                      missile.hasTarget = true;
                    } else {
                      // Apply zig or zag based on current state
                      if (missile.zigzagState) {
                        missile.movementDirection += Math.PI / 3;  // Zig right
                      } else {
                        missile.movementDirection -= Math.PI / 3;  // Zag left
                      }
                    
                      // Toggle the state for next time
                      missile.zigzagState = !missile.zigzagState;
                    
                      // After changing direction, make sure it's still generally heading toward player
                      const toPlayerBearing = Math.atan2(
                        -Math.sin(missile.realBearing) * missile.realDistance,
                        -Math.cos(missile.realBearing) * missile.realDistance
                      );
                    
                      // Limit how far the missile can turn away from player
                      const angleDiff = normalizeAngle(missile.movementDirection - toPlayerBearing);
                      if (Math.abs(angleDiff) > Math.PI/2) {
                        // If missile is heading more than 90° away from player, correct course
                        missile.movementDirection = toPlayerBearing + (angleDiff > 0 ? Math.PI/3 : -Math.PI/3);
                      }
                    }
                  }
                }, 800); // Change course every 800 milliseconds
              }
            }, 2000);
          }, 8000);
        }, 3000);
      }

      // Comment after zigzag missiles are destroyed
      if (response7 && !response8 && !response8a) {
        response8a = true;
        createTimeout(() => {
          addDialogue("Captain: Damn that pirate! How are they able to update their targeting solution so quickly?", captainColor, defaultDialogueTime, captainPortraitFilePath);
          
          createTimeout(() => {
            addDialogue("Engineer: Sir, that ship seems like it's sporting a lot of state of the art equipment. Their sensors and targeting systems are way out of the league of what a pirate ship should have.", engineerColor);

            createTimeout(() => {
              addDialogue("Captain: How would rabble like that get their hands on such advanced technology?", captainColor, defaultDialogueTime, captainPortraitFilePath);

              // Prepare for third attack - combination of direct and zigzag missiles
              createTimeout(() => {
                const pirateShip = contacts[1]; // The hostile battlecruiser

                addDialogue("Engineer: Massive missile launch detected! They're firing a lot!", engineerColor);

                // Launch four direct missiles
                for (let i = 0; i < 4; i++) {
                  createTimeout(() => {
                    pirateShip.launchMissileAtContact(contacts[0], tartarusMissileFuelTime, tartarusMissileArmingTime, tartarusMissileSpeed, false);
                  }, i * 1500);
                }

                // Launch four zigzag missiles
                createTimeout(() => {
                  const playerBearing = Math.atan2(
                    -Math.sin(pirateShip.realBearing) * pirateShip.realDistance,
                    -Math.cos(pirateShip.realBearing) * pirateShip.realDistance
                  );
                    
                  // Create four zigzag missiles at different angles
                  const angles = [-Math.PI/4, -Math.PI/8, Math.PI/8, Math.PI/4];
                    
                  for (let i = 0; i < 4; i++) {
                    createTimeout(() => {
                      // Create unique ID for this missile to track it
                      const missileId = Date.now() + i;

                      // Launch missile
                      pirateShip.launchMissileAlongAngle(playerBearing + angles[i], tartarusMissileFuelTime, tartarusMissileArmingTime, tartarusMissileSpeed);

                      // Set up zigzag behavior
                      createTimeout(() => {
                        const missiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE");
                        if (missiles.length > 0) {
                          const missile = missiles[missiles.length - 1];

                          // Add zigzag properties directly to the missile
                          missile.zigzagState = true;
                          missile.missileId = missileId;
                          missile.zigzagAngle = angles[i];

                          const zigzagInterval = createInterval(() => {
                            if (!missile || missile.destroyed) {
                              uncreateInterval(zigzagInterval);
                              return;
                            }

                            // Check distance to player
                            const distToPlayer = Math.sqrt(
                              Math.pow(Math.cos(missile.realBearing) * missile.realDistance, 2) + 
                              Math.pow(Math.sin(missile.realBearing) * missile.realDistance, 2)
                            );

                            if (distToPlayer < radius * 0.25) {
                              // Close to player, home in
                              missile.targetContact = contacts[0];
                              missile.hasTarget = true;
                              uncreateInterval(zigzagInterval);
                            } else {
                              // Calculate direction toward player
                              const toPlayerBearing = Math.atan2(
                                -Math.sin(missile.realBearing) * missile.realDistance,
                                -Math.cos(missile.realBearing) * missile.realDistance
                              );
                                
                              // Update movement direction based on zigzag state
                              if (missile.zigzagState) {
                                // Zig - adjust direction to one side
                                missile.movementDirection = toPlayerBearing + Math.abs(missile.zigzagAngle);
                              } else {
                                // Zag - adjust direction to other side
                                missile.movementDirection = toPlayerBearing - Math.abs(missile.zigzagAngle);
                              }

                              // Toggle state for next time
                              missile.zigzagState = !missile.zigzagState;
                            }
                          }, 800);
                        }
                      }, 500);
                    }, i * 2000);
                  }
    
                  // Set a check to see when all missiles are destroyed
                  const checkAllMissiles = createInterval(() => {
                    const activeMissiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE").length;
    
                    if (activeMissiles === 0) {
                      uncreateInterval(checkAllMissiles);
                      response8 = true;
                    }
                  }, 1000);
                }, 8000);
              }, 10000);
            }, 6000);
          }, 6000);
        }, 6000);
      }

      // After third wave is destroyed
      if (response8 && !response9 && !response9a) {
        response9a = true;
        createTimeout(() => {
          addDialogue("Captain: Helm, what's the status of our engines?", captainColor, defaultDialogueTime, captainPortraitFilePath);
          
          createTimeout(() => {
            addDialogue("Helmsman: We're almost ready to give it full power sir.", helmsmanColor);
            
            createTimeout(() => {
              addDialogue("Captain: Almost isn't good enough. We can't afford to let that battlecruiser get any closer.", captainColor, defaultDialogueTime, captainPortraitFilePath);
              
              createTimeout(() => {
                addDialogue("Helmsman: Yes sir, we're working on it.", helmsmanColor);
                
                // Final attack - spread of missiles that all home in after delay
                createTimeout(() => {
                  const pirateShip = contacts[1];
                  
                  addDialogue("Engineer: Captain! They're launching a massive spread!", engineerColor);

                  // Give the players a hint of what's coming
                  createTimeout(() => {
                    addDialogue("Captain: Most of those are going to miss. Why would they fire unless... They're going to arc them back! Get ready!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                  }, 2000);
                  
                  // Launch 8 missiles in a wide spread
                  const playerBearing = Math.atan2(
                    -Math.sin(pirateShip.realBearing) * pirateShip.realDistance,
                    -Math.cos(pirateShip.realBearing) * pirateShip.realDistance
                  );
                  
                  const spreadWidth = Math.PI / 2; // 90 degree spread
                  const numMissiles = 8;
                  
                  for (let i = 0; i < numMissiles; i++) {
                    const angle = playerBearing - spreadWidth/2 + i * (spreadWidth / (numMissiles - 1));
                    
                    createTimeout(() => {
                      pirateShip.launchMissileAlongAngle(angle, tartarusMissileFuelTime, tartarusMissileArmingTime, tartarusMissileSpeed);
                    }, i * 500);
                  }
                  
                  // After 10 seconds, make all missiles home in on player
                  createTimeout(() => {
                    const missiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE");
                    
                    for (let missile of missiles) {
                      missile.targetContact = contacts[0];
                      missile.hasTarget = true;
                    }
                    
                    // Set a check to see when all missiles are destroyed
                    const checkFinalMissiles = createInterval(() => {
                      const activeMissiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE").length;
                      
                      if (activeMissiles === 0) {
                        uncreateInterval(checkFinalMissiles);
                        response9 = true;
                      }
                    }, 1000);
                  }, 10000);
                }, 8000);
              }, 3000);
            }, 3000);
          }, 3000);
        }, 3000);
      }

      // Final victory sequence
      if (response9 && !response10 && !response10a) {
        response10a = true;
        createTimeout(() => {
          addDialogue("Helmsman: Captain, we're ready to go to full power!", helmsmanColor);
          
          createTimeout(() => {
            addDialogue("Captain: Good. Get us out of here!", captainColor, defaultDialogueTime, captainPortraitFilePath);
            
            createTimeout(() => {
              addDialogue("Helmsman: Yes sir!", helmsmanColor);
              
              // Trigger victory after a short delay
              createTimeout(() => {
                gameOver = true;
                $playerWonO2 = true;
                gameOverMessage = "VICTORY!";
                gameOverColor = "green";
                // Play victory sound
                const audio = new Audio("../assets/victory.mp3");
                audio.play();
              }, 2000);
            }, 2000);
          }, 2000);
        }, 3000);
      }

      
      // Cap deltaTime to prevent huge jumps if tab was inactive
      const cappedDeltaTime = Math.min(deltaTime, 0.5);
      
      drawBackground(cappedDeltaTime);
      
      // Calculate thermal scan absolute angle
      const thermalScanAbsoluteAngle = thermalScanAngle + thermalScanCenter;

      // Sort contacts into friendly and hostile arrays
      // Do not include missiles in these arrays
      const friendlyContacts = contacts.filter(contact => contact.contactType === "FRIENDLY" || contact.contactType === "PLAYER" && !contact.isMissile);
      const hostileContacts = contacts.filter(contact => contact.contactType === "HOSTILE" && !contact.isMissile);
      
      // Update and draw contacts
      for (let contact of contacts) {
        contact.updatePosition(cappedDeltaTime);
        contact.checkDetection(angle, thermalScanAbsoluteAngle, thermalScanRadius, cappedDeltaTime);
        contact.draw(cappedDeltaTime);
      }
      
      // Draw the radar line and thermal scan
      drawRadarLine();
      drawThermalScan();
      // Draw the text telling the player in the top left how many missiles are left
      drawCurrentMissiles();
      // Draw the dialogue messages in the top right corner
      drawDialogue();
      
      // Update and draw contact reports
      for (let i = contactReports.length - 1; i >= 0; i--) {
        if (!contactReports[i].update(cappedDeltaTime)) {
          contactReports.splice(i, 1);
        } else {
          contactReports[i].draw();
        }
      }
      
      // Update the radar scan angle (rotate by specified degrees per second)
      angle += (Math.PI * radarSpeed / 180) * cappedDeltaTime;
      if (angle >= Math.PI * 2) angle = 0;

      // Update the thermal scan angle
      if (thermalScanReversed) {
        thermalScanAngle -= (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle <= -thermalScanWidth/2) {
          thermalScanAngle = -thermalScanWidth/2;
          thermalScanReversed = false;
        }
      } else {
        thermalScanAngle += (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle >= thermalScanWidth/2) {
          thermalScanAngle = thermalScanWidth/2;
          thermalScanReversed = true;
        }
      }
      
      requestAnimationFrame(animate);
    }

    // Track mouse position
    let mouseX, mouseY;
    canvas.addEventListener('mousemove', function(event) {
      const rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    });

    // Add click event listener for contact reports
    canvas.addEventListener('click', function(event) {
      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $operation2Allowed === "undefined" || $operation2Allowed === null || !$operation2Allowed) {
        // Cancel the event if the operation is not allowed to be running
        return;
      }

      // If paused, do nothing
      if (gamePaused) return;

      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
    
      // Check if click is on a contact report
      let wasOnContactReport = false;
      for (let i = 0; i < contactReports.length; i++) {
        // Launch a missile if the click is on a contact report and the player ship still has missiles
        // PLayer ship should be the first contact in the contacts array
        if (contactReports[i].contains(mouseX, mouseY) && contacts[0].numMissiles > 0) {
          console.log(`Radar contact at ${contactReports[i].timestamp} reported`);

          wasOnContactReport = true;

          // If this isn't the first contact report clicked and the associated contact is a missile, add a dialogue message for that
          if (contactReports[i].contact.isMissile && !isFirstContact && isFirstMissile) {
            addDialogue(`Engineer: Fast movers! We have incoming!`, engineerColor);
            // Wait for 3 seconds, then have the captain respond
            createTimeout(() => {
              addDialogue(`Captain: Fire countermissile!`, captainColor, 12);
            }, 2000);
            isFirstMissile = false;
          }
      
          // If not allowed to fire, do nothing
          if (allowedToFire) {
            // Fire at the contact report's associated contact
            // contacts[0] is the player ship, so we will use it to launch the missile
            // launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed)
            contacts[0].launchMissileAtContact(contactReports[i].contact, 30, 0.9, 10, false);
          }

          // Remove the report after clicking
          contactReports.splice(i, 1);
          break;
        }
      }
      // If not on a contact report, check if click is on the radar screen
      if (!wasOnContactReport) {
        // Figure out the fire coordinates based on the mouse position
        const dx = mouseX - centerX;
        const dy = mouseY - centerY;

        if (!allowedToFireAtSpot || !allowedToFire) return; // Don't fire if not allowed
        

        // Try to fire at the given coordinates
        // contacts[0] is the player ship, so we will use it to launch the missile
        // launchMissileAtPoint(targetX, targetY, missileFuelTime, missileArmingTime, missileMovementSpeed)
        contacts[0].launchMissileAtPoint(dx, dy, 30, 0.9, 10);
      }
    });

    // Key event listeners for thermal scan control
    document.addEventListener('keydown', function(event) {
      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $operation2Allowed === "undefined" || $operation2Allowed === null || !$operation2Allowed) {
        // Cancel the event if the operation is not allowed to be running
        return;
      }
      if (event.key === 'a' || event.key === 'A') {
        // Rotate thermal scan left
        // If paused, do nothing
        if (!gamePaused) {
          thermalScanCenter -= 0.1;
          if (thermalScanCenter < 0) thermalScanCenter += Math.PI * 2;
        }
      } else if (event.key === 'd' || event.key === 'D') {
        // Rotate thermal scan right
        // If paused, do nothing
        if (!gamePaused) {
          thermalScanCenter += 0.1;
          if (thermalScanCenter >= Math.PI * 2) thermalScanCenter -= Math.PI * 2;
        }
      } else if (event.key === 'x' || event.key === 'X') {
        // Check if the mouse is over a contact report
        // If paused, do nothing
        if (!gamePaused) {
          for (let i = 0; i < contactReports.length; i++) {
            if (contactReports[i].contains(mouseX, mouseY)) {
              // Dismiss the contact report
              console.log(`Contact report at ${contactReports[i].timestamp} dismissed`);
              contactReports.splice(i, 1);
              break;
            }
          }
        }
      } else if (event.key === 'q' || event.key === 'q') {
        // If not allowed to fire, do nothing
        if (!allowedToFire) return;

        // Check if the mouse is over a contact report
        // If paused, do nothing
        if (!gamePaused) {
          for (let i = 0; i < contactReports.length; i++) {
            if (contactReports[i].contains(mouseX, mouseY)) {
              // Fire a spread at the contact in the contact report
              
              // Fire at the contact report's associated contact
              // contacts[0] is the player ship, so we will use it to launch the missile
              // launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed, isSpreadAttack)
              contacts[0].launchMissileAtContact(contactReports[i].contact, 30, 0.9, 10, true);

              console.log(`Spread fired at Contact report at ${contactReports[i].timestamp}`);
              contactReports.splice(i, 1);
              break;
            }
          }
        }
      } else if (event.key === 'p' || event.key === 'P') {
        // Toggle pause state if not in game over state
        if (!gameOver) {
          // If viewing message history, just exit that view but remain paused
          if (isViewingMessageHistory) {
            isViewingMessageHistory = false;
            drawPauseMenu();
          } else {
            gamePaused = !gamePaused;
            if (gamePaused) {
              console.log("Game paused");
              // Draw it here to ensure it's only drawn once when paused
              drawPauseMenu();
            } else {
              console.log("Game unpaused");
            }
          }
        }
      } else if (event.key === 'h' || event.key === 'H') {
        // Toggle message history view
        if (isViewingMessageHistory) {
          // Exit message history view but stay paused
          isViewingMessageHistory = false;
          drawPauseMenu();
        } else {
          // If game is not already paused, pause it
          if (!gamePaused) {
            gamePaused = true;
          }
          // Switch to message history view
          isViewingMessageHistory = true;
          // Reset scroll position when first opening
          messageHistoryScrollPosition = 0;
        }
      } else if (event.key === 'ArrowUp') {
        // Scroll message history up
        if (isViewingMessageHistory) {
          messageHistoryScrollPosition = Math.max(0, messageHistoryScrollPosition - 40);
        }
      } else if (event.key === 'ArrowDown') {
        // Scroll message history down
        if (isViewingMessageHistory) {
          messageHistoryScrollPosition += 40;
          // Upper limit will be checked in draw function
        }
      }
    });

    // Create contacts array with initial contacts
    // Parameters: bearing, distance, size, 
    //             movementSpeed, directionChangeFrequency, movementDirection, 
    //             visible, opacity, emittingRadiation, emissionDetectionChance,
    //             radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
    //             iffBroadcasting, iffString, contactColor, contactType,
    //             numMissilesLoaded
    const contacts = [
      // The player's ship. Always visible and at the center of the radar
      // Has 100 missiles loaded
      new Contact(0, 0, 5, 
                  0, 0, 0, 
                  true, 1, true, 0, 
                  true, 0, true, 0,
                  true, "PLAYER SHIP, Heavy Cruiser\nCRS Bounty\nCairn Class", [255, 255, 255],
                  "PLAYER", 100),
      // The Tartarus. Nearly unlimited missiles, each of which has an extremely long range. 
      // Keeps out of the Cairn's range while bombarding it from afar.
      new Contact(Math.PI/2, radius * 0.9, 5, 
                  0, 0, 0, 
                  false, 0, true, 0.3,
                  true, 1, true, 1,
                  false, "", [255, 0, 0],
                  "HOSTILE"),
      // ELINT Ghosts (No thermal, no radar detection)
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      // Radar ghosts (No ELINT, No thermal detection)
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
    ];

    // Fill the canvas with black initially
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, width, height);
    
    // Start the animation with the timestamp
    lastFrameTime = performance.now();

    requestAnimationFrame(animate);
  })();
</script>

[[See Operation Results->Operation Result 2]]
[[Back->Operation 1]]

(set: $operation1Allowed to false)
(set: $operation3Allowed to false)
(set: $operation4Allowed to false)
(set: $operation5Allowed to false)
(set: $tutorialOperationAllowed to false)
(set: $operationDebugAllowed to false)

:: Operation Result 2 {"position":"1400,400","size":"100,100"}

[[Click to go Back->Operation 2]]
(if: $playerWonO2 is true)[[[Victory! Click to continue->Operation 3]]]

:: Operation 3 {"position":"1600,200","size":"100,100"}
Operation 3: Specters in the Dark

Controls:
F11 for fullscreen
Thermal Scan - Use A/D to rotate
Contact Report - Left click to fire at, X to Dismiss, Q to fire a spread at
Pause - P to toggle pause
Message history - H to pause and view message history
<!-- Operation 2 -->
<!-- Removal of padding allows for much more game room on small monitors -->
<style>
tw-story {
  padding: 0% 0%;
  padding-top: 0%;
  padding-right: 0%;
  padding-bottom: 0%;
  padding-left: 0%;
}

@media (min-width: 576px) {
  tw-story {
    padding: 0% 0%;
    padding-top: 0%;
    padding-right: 0%;
    padding-bottom: 0%;
    padding-left: 0%;
  }
}
</style>


<canvas id="operation3" width="1350" height="750"></canvas>
<script>
    // Mark operation 3 as being usable
    $operation3Allowed = true;
    // Stops the previous audio
    if (typeof audio !== 'undefined') {
      audio.pause();
      // And probably remove it from the memory
      delete audio;
    }
  (function() {
    const canvas = document.getElementById("operation3");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 3;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 2 - 10;

    // Array of elint beep audios. Rather than create and play a new beep each time there is a detection,
    // we will instead reuse numBeeps number of beeps. This is to prevent the audio from overlapping and
    // creating a cacophony of beeps that can overload the number of audio channels available in the browser.
    const numBeeps = 20;
    const elintBeeps = Array.from({ length: numBeeps }, () => new Audio("../assets/ELINTBeep.mp3"));
    
    // Track the start time
    const startTime = Date.now();
    let lastFrameTime = performance.now();
    // Track the unpaused elapsed time
    let unpausedElapsedTimeMillis = 0;
    // Time multiplier
    // 1 = normal speed
    // 2 = double speed
    // 0.5 = half speed
    const deltaTimeMultiplier = 2.4;
    // Detection chance time multiplier
    // Intended to address the fact that PC performance can affect detection chances
    const detectionTimeMultiplier = 1;

    // Game state variables
    let gameOver = false;
    let gamePaused = true;
    let gameOverMessage = "";
    let gameOverColor = "";

    // If the game is paused, go ahead and draw the pause screen
    if (gamePaused) {
      requestAnimationFrame(drawPauseMenu);
    }

    // Customizable parameters - now in units per second instead of per frame
    const radarSpeed = 30; // degrees per second
    const fadeRate = 6;   // fade opacity per second
    const ELINTHalfAngle = Math.PI/36; // 5 degrees in radians
    
    // Radar line angle
    let angle = 0;
    // Thermal scan angle
    let thermalScanAngle = 0;
    
    // Thermal scan parameters
    const thermalScanWidth = Math.PI/6; // 30 degrees in radians
    const thermalScanRadius = radius * 0.25; // 0.25ls circle
    const thermalScanSpeed = 30; // degrees per second
    let thermalScanCenter = 0; // Center of thermal scan area
    let thermalScanReversed = false; // Direction of thermal scan rotation

    // Missile thermal scan parameters
    const missileScanWidth = Math.PI/6; // 30 degrees in radians
    const missileScanRadius = radius * 0.05; // 0.05ls circle
    const missileScanSpeed = 60; // degrees per second

    // Random missile launch parameters
    const baseMissileLaunchChance = 0;
    let missileLaunchChance = baseMissileLaunchChance;
    let missileLaunchIncrease = 0;
    // Missile attack type parameters
    const chanceOfSpreadAttack = 0.0;
    const spreadAttackMissilePerRadiusAmount = 0.05; // Add 1 more missile for every radius amount of distance to target
    let allowedToFireAtSpot = false; // If true, the player can fire at any point on the screen, not just contacts. If false, they can't.
    let allowedToFire = false; // If true, the player can cause a missile to be launched. If false, all controls related to firing are disabled. 
    // Enemy missile parameters
    const enemyMissileFuelTime = 120; // Lifetime of the enemy missiles in seconds. Default 120
    const enemyMissileArmingTime = 1.0; // Time it takes for enemy missiles to arm in seconds. Default 1.0
    const enemyMissileSpeed = 6; // Speed of enemy missiles. Default 6

    // Contact report parameters
    const contactReports = [];
    const reportLifetime = 10; // lifetime in seconds

    // IFF Parameters
    const iffBoxDisplayDistance = 100; // How far away the mouse can be before the IFF box stops displaying
    const acceptedTypes = ["FRIENDLY", "HOSTILE", "NEUTRAL", "GHOST", "PLAYER"]; // Accepted contact types

    // Dialogue message parameters
    const dialogueMessages = []; // Array to store dialogue messages with text, color, and time they should disappear
    const defaultDialogueTime = 8; // Default time for dialogue messages to disappear
    // Dialogue flags
    let isFirstContact = true;
    let isFirstMissile = true;
    let shotDownFirstMissile = false;
    let firedFirstSpread = false;
    let firedSpreadAtMissile = false;
    let firedSpreadAtInvalidTarget = false;
    let response1 = false;
    let response1a = false;
    let response2 = false;
    let response2a = false;
    let response3 = false;
    let response3a = false;
    let response4 = false;
    let response4a = false;
    let response5 = false;
    let response5a = false;
    let response6 = false;
    let response6a = false;
    let response7 = false;
    let response7a = false;
    let response8 = false;
    let response8a = false;
    let response9 = false;
    let response9a = false;
    let response10 = false;
    let response10a = false;
    let response11 = false;
    let response11a = false;
    let response12 = false;
    let response12a = false;
    let response13 = false;
    let response13a = false;
    let response14 = false;
    let response14a = false;
    let response15 = false;
    let response15a = false;
    let response16 = false;
    let response16a = false;
    let response17 = false;
    let response17a = false;
    let response18 = false;
    let response18a = false;
    let response19 = false;
    let response19a = false;
    let response20 = false;
    let response20a = false;

    // How many missiles both enemy ships start with
    const numEnemyMissiles = 15; 
    
    // Flag that tells whether the victory check code can run
    let checkForVictory = false;
    // Flag that tells whether or not the enemy can attack
    let enemyCanAttack = false;

  
    // Tracks what attack patterns have been seen
    let seenZigZagMissiles = false;
    let seenThreeProngedAttack = false;
    let enemyShip1Destroyed = false;
    let enemyMissilesLaunched = 0;
    let enemyMissilesRemaining = 0;
    let missileCheckInterval = null;

    // Dialogue message colors for certain characters
    const engineerColor = "#00FF00";
    const captainColor = "#34eb7a";
    const helmsmanColor = "#9ceb34";
    const friendlyColor = "#FF00FF"
    const unidentifiedColor = "#FFFFFF"
    const pirateColor = "#FF0000"
    // Dialogue portrait paths
    const captainPortraitFilePath = "../assets/characters/CaptainPortrait.png";

    // Function to create explosion effect
    function createExplosion(x, y) {
      // Play explosion sound (Unused for now)
      // const explosionSound = new Audio("../assets/MissileHit.mp3");
      // explosionSound.play();

      // Visual explosion effect (flash)
      ctx.beginPath();
      ctx.arc(x, y, 30, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255, 200, 50, 0.8)";
      ctx.fill();
    }

    // Function to check if all contacts of a specific type are gone
    function areAllContactsGone(type) {
      return !contacts.some(contact => contact.contactType === type && !contact.destroyed);
    }

    // Contact Report class
    class ContactReport {
      constructor(x, y, timestamp, contactType, contact) {
        this.x = x;
        this.y = y;
        this.timestamp = timestamp;
        this.contactType = contactType;
        this.contact = contact;
        this.timeCreated = Date.now();
        this.age = 0;
        this.maxAge = reportLifetime;
      }
      
      update(deltaTime) {
        // Increment age, but only if the contact is no longer visible or no longer exists
        if (!this.contact || !this.contact.visible || this.contact.destroyed || typeof this.contact === 'undefined') {
          this.age += deltaTime;
        }
        return this.age < this.maxAge;
      }
      
      draw() {
        // Calculate opacity based on age
        const opacity = 1 - (this.age / this.maxAge);
        
        // Determine position (ensure it's on screen)
        const boxWidth = 180;
        const boxHeight = 75; // Increased height to fit new line
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        // Draw connection line
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(boxX + (boxX > this.x ? 0 : boxWidth), boxY + boxHeight/2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw box
        ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.7})`;
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Draw text
        ctx.font = "10px monospace";
        ctx.fillStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.textAlign = "left";
        ctx.fillText(`DETECTED: ${this.timestamp}`, boxX + 5, boxY + 15);
        ctx.fillText(`POTENTIAL ${this.contactType} CONTACT`, boxX + 5, boxY + 30);
        ctx.fillText("CLICK TO REPORT CONTACT", boxX + 5, boxY + 45);
        ctx.fillText("X TO DISMISS, Q TO FIRE SPREAD", boxX + 5, boxY + 60);
      }
      
      contains(mouseX, mouseY) {
        // Determine box position
        const boxWidth = 180;
        const boxHeight = 75; // TODO: Make boxWidth and boxHeight not exist both here and in draw() separately in order to make it easier to change
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        return mouseX >= boxX && mouseX <= boxX + boxWidth && 
               mouseY >= boxY && mouseY <= boxY + boxHeight;
      }
    }

    // Contact class definition
    class Contact {
      constructor(bearing, distance, size, movementSpeed, directionChangeFrequency, movementDirection, 
                  visible, opacity, emittingRadiation, emissionDetectionChance, 
                  radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
                  iffBroadcasting, iffString, contactColor, contactType, numMissilesLoaded) {
        // Affects displayed position
        this.bearing = bearing;
        this.distance = distance;
        this.size = size;
        
        // Affects real position for sim (moves independently of the displayed blip)
        this.realBearing = bearing;
        this.realDistance = distance;
        
        // Movement parameters for sim (now per second rather than per frame)
        this.movementSpeed = movementSpeed;
        this.directionChangeFrequency = directionChangeFrequency;
        this.movementDirection = movementDirection;
        this.directionChangeCounter = 0;
        
        // Visibility properties for contact blip
        this.visible = visible;
        this.opacity = opacity;
        this.fadeSpeed = 0.6; // fade per second

        // ELINT detection properties
        this.emittingRadiation = emittingRadiation;
        this.emissionDetectionChance = emissionDetectionChance;
        this.radiationDetected = false;
        this.radiationDetectionDuration = 0;
        
        // Radar detection properties
        this.radarDetectable = radarDetectable;
        this.radarDetectionChance = radarDetectionChance;
        this.lastDetectedTime = null;

        // Thermal detection properties
        this.thermalDetectable = thermalDetectable;
        this.thermalDetectionChance = thermalDetectionChance;

        // IFF (Identification Friend or Foe) properties
        this.iffBroadcasting = iffBroadcasting;
        this.iffString = iffString;
        this.contactColor = contactColor;

        // How many missiles are aboard the ship
        this.numMissiles = numMissilesLoaded;

        // Currently, there are five types of contacts: "FRIENDLY", "HOSTILE", "NEUTRAL", "GHOST", and "PLAYER"
        // Anything else is treated as "GHOST"
        if (acceptedTypes.includes(contactType)) {
          this.contactType = contactType;
        } else {
          this.contactType = "GHOST";
        }
        // Ghosts must not be thermally detectable
        if (this.contactType === "GHOST") {
          this.thermalDetectable = false;
        }
      }
      
      updatePosition(deltaTime) {
        // Randomly change direction occasionally, now based on elapsed time
        this.directionChangeCounter += deltaTime;
        if (this.directionChangeCounter > (1 / this.directionChangeFrequency)) {
          this.movementDirection += (Math.random() - 0.5) * Math.PI / 2; // Change by up to +/-45 degrees
          this.directionChangeCounter = 0;
        }
        
        // Convert polar movement to cartesian
        let dx = Math.cos(this.movementDirection) * this.movementSpeed * deltaTime;
        let dy = Math.sin(this.movementDirection) * this.movementSpeed * deltaTime;
        
        // Convert contact position from polar to cartesian
        let contactX = Math.cos(this.realBearing) * this.realDistance;
        let contactY = Math.sin(this.realBearing) * this.realDistance;
        
        // Update position
        contactX += dx;
        contactY += dy;
        
        // Convert back to polar coordinates
        this.realDistance = Math.sqrt(contactX * contactX + contactY * contactY);
        this.realBearing = Math.atan2(contactY, contactX);
        
        // Keep contact within radar bounds
        if (this.realDistance > radius * 0.95) {
          // If near edge, bounce back, unless a missile, in which case it should self-destruct
          if (this.isMissile) {
            // Create explosion effect
            createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                           centerY + this.realDistance * Math.sin(this.realBearing));
            
            // Remove from contacts array
            const index = contacts.indexOf(this);
            if (index > -1) {
              contacts.splice(index, 1);
            }
            return;
          }
          this.movementDirection = Math.atan2(-contactY, -contactX);
          this.realDistance = radius * 0.95;
        } else if (this.realDistance < 0) {
          // If somehow at a negative distance, reset to 0
          this.realDistance = 0;
        }
        
        // Check for radiation detection
        this.checkRadiationDetection(deltaTime);
        
        // Decrease radiation detection duration
        if (this.radiationDetected) {
          this.radiationDetectionDuration -= deltaTime;
          if (this.radiationDetectionDuration <= 0) {
            this.radiationDetected = false;
          }
        }
      }
      
      checkRadiationDetection(deltaTime) {
        // Adjust chance based on time
        const timeAdjustedChance = this.emissionDetectionChance * deltaTime * detectionTimeMultiplier;
        
        if (this.emittingRadiation && Math.random() < timeAdjustedChance) {
          // Play a beep
          // Iterate through beeps to find one that is not currently playing
          for (let i = 0; i < numBeeps; i++) {
            if (elintBeeps[i].paused) {
              elintBeeps[i].play();
              break;
            }
          }

          this.radiationDetected = true;
          this.radiationDetectionDuration = 0.25; // Show for 0.25 second
        }
      }
      
      checkDetection(radarAngle, thermalScanAbsoluteAngle, thermalScanRadius, deltaTime) {
        // Check if radar is sweeping over the contact
        const angleDiff = Math.abs(normalizeAngle(radarAngle - this.realBearing));
        let wasNewDetection = false;
        
        // Adjust chances based on time
        // If something has a 100% chance of being detected, it should be detected
        const timeAdjustedRadarChance = this.radarDetectionChance >= 1 ? 1 : this.radarDetectionChance * deltaTime * detectionTimeMultiplier;
        //const timeAdjustedThermalChance = this.thermalDetectionChance * deltaTime * detectionTimeMultiplier;
        const timeAdjustedThermalChance = this.thermalDetectionChance > 0 ? 1 : 0; // If something is thermal detectable, it should be detected
        
        if (angleDiff < 0.1 && this.radarDetectable && Math.random() < timeAdjustedRadarChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            // Play a ping
            const audio = new Audio("../assets/RadarPing.mp3");
            audio.play();
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const minutes = Math.floor(unpausedElapsedTimeMillis / 60000);
            const seconds = Math.floor((unpausedElapsedTimeMillis % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "RADAR", this));
          }
        }
        
        // Check if thermal scan is over the contact
        const thermalDiff = Math.abs(normalizeAngle(thermalScanAbsoluteAngle - this.realBearing));
        
        if (thermalDiff < 0.1 && this.realDistance < thermalScanRadius && 
            this.thermalDetectable && Math.random() < timeAdjustedThermalChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const minutes = Math.floor(unpausedElapsedTimeMillis / 60000);
            const seconds = Math.floor((unpausedElapsedTimeMillis % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "THERMAL", this));
          }
        }
      }

      // Launch a missile along a given bearing
      launchMissileAlongAngle(targetBearing, missileFuelTime, missileArmingTime, missileMovementSpeed) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          // General idea: Create a unit circle around this contact, then create a contact at the 
          // corresponding point on the circle with the matching bearing.

          // Figure out the polar coordinates of a point on the unit circle with angle targetBearing
          const targetX = Math.cos(targetBearing);
          const targetY = Math.sin(targetBearing);

          // Center the unit circle around the launcher's position
          const missileX = Math.cos(this.realBearing) * this.realDistance;
          const missileY = Math.sin(this.realBearing) * this.realDistance;

          // Figure out the actual position in the game world that the missile is being launched towards
          const trueTargetX = missileX + targetX;
          const trueTargetY = missileY + targetY;

          // Convert back to polar coordinates
          const targetContactBearing = Math.atan2(trueTargetY, trueTargetX);
          const targetContactDistance = Math.sqrt(trueTargetX * trueTargetX + trueTargetY * trueTargetY);

          // Create a new contact that just gives a bearing and unit distance
          // to tell the missile what direction to aim in
          // If this is not done, then missiles launched will not know
          // which direction to go in. They will only know where to spawn.
          let targetContact = new Contact(targetContactBearing, targetContactDistance);

          // Set the missile's contact type to match whoever launched it, unless the contact is a player
          // Set it to friendly in that latter case
          let contactType = this.contactType;
          if (this.contactType === "PLAYER") {
            contactType = "FRIENDLY";
          }
          const missile = new MissileContact(this.realBearing, this.realDistance, targetContact, missileFuelTime, contactType, missileArmingTime, missileMovementSpeed);
          contacts.push(missile);

          // Reduce the number of missiles available if applicable
          if (this.numMissiles !== undefined && this.numMissiles !== null) {
            this.numMissiles--;
          }
        } 
      }

      // Launch a missile at the given position (Requires target contact just to tell the missile who it's initially targeting)
      launchMissileAtPoint(targetX, targetY, missileFuelTime, missileArmingTime, missileMovementSpeed) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          
          // Figure out the angle of the line which points from this contact to the target
          // Convert contact position from polar to Cartesian
          const contactX = Math.cos(this.realBearing) * this.realDistance;
          const contactY = Math.sin(this.realBearing) * this.realDistance;

          // Calculate angle from contact to target
          const targetAngle = Math.atan2(targetY - contactY, targetX - contactX);

          // Delegate to launchMissileAlongAngle with the target angle
          this.launchMissileAlongAngle(targetAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
        }
      }

      // Launch a missile at the given contact
      launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed, isSpreadAttack) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          // Basic idea: We have four parametric equations, two for the target's position as a function
          // of time, and two for the missile's position as a function of time. 
          // The missile position in x is given by
          //
          // missileX(t) = t * missileVelocityX + missileX(0)    <-- missileX(0) is the initial x position of the missile, so in this case, the launcher's x position
          //
          // The missile position in y is given by
          //
          // missileY(t) = t * missileVelocityY + missileY(0)  <-- missileY(0) is the initial y position of the missile, so in this case, the launcher's y position
          //
          // The target position in x is given by
          //
          // targetX(t) = t * targetVelocityX + targetX(0)  <-- targetX(0) is the initial x position of the target contact, so in this case, its current x position
          //
          // The target position in y is given by
          //
          // targetY(t) = t * targetVelocityY + targetY(0)  <-- targetY(0) is the initial y position of the target contact, so in this case, its current y position
          //
          // We want all four quantities to equal, so we arrive at a system of two equations:
          //
          // missileX(t) = targetX(t) && missileY(t) = targetY(t)
          //
          // We actually have two unknowns. Time is of course one of them, but the other is the angle at which we must launch the missile to collide with the target.
          // It is this quantity we are interested in. We know that launch angle is actually a part of the missile's velocity vector, so we can write
          //
          // missileVelocityX = missileSpeed * cos(missileLaunchAngle) && missileVelocityY = missileSpeed * sin(missileLaunchAngle)
          //
          // We then substitute these into the system of equations, and solve for time and missileLaunchAngle. 
          // It is somewhat challenging to solve this, but by using a symbolic algebra system like the one used by Wolfram Mathematica, we get that there
          // are actually two solutions for both time and angle. We will look at both solutions and chooose which, if any, is the correct one to use.
          // For instance, if angle or time are undefined or infinite, we know that something is wrong with that solution, likely because none is possible.
          // This could happen in a case where we're shooting at something going away faster than we can catch up to it, for instance.
          // Moreover, if time is negative, then our window of opportunity has already passed, and we should not launch the missile using the given solution.
          // Those interested in the derivation of this equation for themselves should be familiar with solutions of equations of the form 
          //
          // sin(x) + b cos(x) = c for real valued constants b and c

          // Time, angle equations 1.
          // These symbols correspond to these quantities:
          // evx - Enemy velocity x
          // evy - Enemy velocity y
          // mxi - Missile initial x position
          // myi - Missile initial y position
          // exi - Enemy initial x position
          // eyi - Enemy initial y position
          // mspeed - Missile speed
          // t - Time
          // a - Angle

          // In Mathematica code, solution pair 1 is given by
          // t=1/(evx^2+evy^2-mspeed^2) (-evx  exi-evy  eyi+evx  mxi+evy  myi-1/2  \[Sqrt](4  (evx (exi-mxi)+evy (eyi-myi))^2-4  (evx^2+evy^2-mspeed^2)  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))
          // a=ArcTan[(-evy  (exi-mxi)  (eyi-myi)+evx  (eyi-myi)^2+(exi-mxi)  \[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)),(evy  (exi-mxi+(eyi-myi)  (-evx  exi+evx  mxi+\[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))]
          
          // In Mathematica code, solution pair 2 is given by
          // t=1/(evx^2+evy^2-mspeed^2) (-evx  exi-evy  eyi+evx  mxi+evy  myi+1/2  \[Sqrt](4  (evx (exi-mxi)+evy (eyi-myi))^2-4  (evx^2+evy^2-mspeed^2)  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))
          // a=ArcTan[(-evy  (exi-mxi)  (eyi-myi)+evx  (eyi-myi)^2+(-exi+mxi)  \[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)),(evy  (exi-mxi)^2-(eyi-myi)  (evx  exi-evx  mxi+\[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))]

          // Convert both contacts' polar coordinates to Cartesian
          // For the missile launcher (this contact)
          const mxi = Math.cos(this.realBearing) * this.realDistance; // Missile initial x
          const myi = Math.sin(this.realBearing) * this.realDistance; // Missile initial y
          
          // For the target
          const exi = Math.cos(targetContact.realBearing) * targetContact.realDistance; // Enemy initial x
          const eyi = Math.sin(targetContact.realBearing) * targetContact.realDistance; // Enemy initial y
          
          // Calculate enemy velocity components
          const evx = Math.cos(targetContact.movementDirection) * targetContact.movementSpeed; // Enemy velocity x
          const evy = Math.sin(targetContact.movementDirection) * targetContact.movementSpeed; // Enemy velocity y
          
          // Missile speed
          const mspeed = missileMovementSpeed;
          
          // Calculate values needed for the formulas
          const dx = exi - mxi;
          const dy = eyi - myi;
          const distSquared = dx*dx + dy*dy;

          // We first check to see if we're firing at a ghost
          if (targetContact.contactType === "GHOST") {
            // If we're firing at a ghost, launch directly at ghost's last sighted position
            // Looks odd otherwise (Why is my missile going to this random position this game is buggy!!!)

            // Handle firing a spread as well
            if (isSpreadAttack) {
              // Check if the player ship is the launcher
              // and if firedFirstSpread is false
              // If so, write dialogue 
              if(this.contactType === "PLAYER" && !firedFirstSpread) {
                addDialogue("Captain: Gunnery control, fire a spread at that contact!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                firedFirstSpread = true;
              }

              // Calculate distance in radius units
              const distance = Math.sqrt(distSquared);
               
              // Calculate number of missiles based on distance
              // Add 1 missile for every spreadAttackMissilePerRadiusAmount * radius
              let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
               
              // Set minimum and maximum number of missiles
              numMissiles = Math.max(2, numMissiles);
               
              // Calculate increased arming time (0.5 seconds per missile)
              const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);

              // Figure out angle between this contact and the target contact
              const selectedAngle = Math.atan2(dy, dx);
               
              // Launch a spread of missiles
              const spreadAngle = Math.PI / 6; // 30 degrees
              for (let i = 0; i < numMissiles; i++) {
                const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              }
               
              // Launch one more missile directly at the target
              this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              return;
            }

            this.launchMissileAtPoint(targetContact.distance * Math.cos(targetContact.bearing), targetContact.distance * Math.sin(targetContact.bearing), missileFuelTime, missileArmingTime, missileMovementSpeed);
            return;
          }
          
          // Check if player tried to fire spread at missile (moved up to check in all cases)
          if (this.contactType === "PLAYER" && targetContact.isMissile && isSpreadAttack) {
            if (!firedSpreadAtMissile) {
              addDialogue("Captain: Gunnery control, belay that order! That's a missile, don't waste a spread! Sensors, you should have known better!", captainColor, defaultDialogueTime, captainPortraitFilePath);
            }
            firedSpreadAtMissile = true;
            // Continue with normal single missile firing
            isSpreadAttack = false;
          }
          
          // Calculate the determinant inside the square root
          const determinant = 4 * Math.pow(evx*dx + evy*dy, 2) - 
                              4 * (evx*evx + evy*evy - mspeed*mspeed) * distSquared;
          
          // Only proceed if the determinant is positive (solutions exist)
          if (determinant >= 0) {
            // Calculate solutions for time
            const t1 = 1/(evx*evx + evy*evy - mspeed*mspeed) * 
                     (-evx*exi - evy*eyi + evx*mxi + evy*myi - 0.5 * Math.sqrt(determinant));
            
            const t2 = 1/(evx*evx + evy*evy - mspeed*mspeed) * 
                     (-evx*exi - evy*eyi + evx*mxi + evy*myi + 0.5 * Math.sqrt(determinant));
            
            // Calculate the square root term for angle calculations
            const sqrtTerm = Math.sqrt(-evy*evy*dx*dx + 
                                       2*evx*evy*dx*dy - 
                                       evx*evx*dy*dy + 
                                       mspeed*mspeed*distSquared);
            
            // Calculate angles for both solutions
            const a1x = (-evy*dx*dy + evx*dy*dy + dx*sqrtTerm) / (mspeed*distSquared);
            const a1y = (evy*dx*dx + dy*(-evx*exi + evx*mxi + sqrtTerm)) / (mspeed*distSquared);
            const a1 = Math.atan2(a1y, a1x);
            
            const a2x = (-evy*dx*dy + evx*dy*dy - dx*sqrtTerm) / (mspeed*distSquared);
            const a2y = (evy*dx*dx - dy*(evx*exi - evx*mxi + sqrtTerm)) / (mspeed*distSquared);
            const a2 = Math.atan2(a2y, a2x);
            
            // Choose the best solution (positive time, earliest intercept)
            let selectedTime = null;
            let selectedAngle = null;
            
            if (t1 > 0 && (selectedTime === null || t1 < selectedTime)) {
              selectedTime = t1;
              selectedAngle = a1;
            }
            
            if (t2 > 0 && (selectedTime === null || t2 < selectedTime)) {
              selectedTime = t2;
              selectedAngle = a2;
            }

            // If selected time is greater than missile fuel time, reset selected time to null
            if (selectedTime > missileFuelTime) {
              selectedTime = null;
            } 

            // If we found a valid solution, launch the missile
            if (selectedTime !== null) {
              // this.launchMissileAlongAngle(selectedAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
              // If isSpreadAttack, instead fire a spread of missiles at the target and its immediate surroundings
              // Only do this if firing at a non-missile contact
              if (isSpreadAttack && !targetContact.isMissile) {
                // Check if the player ship is the launcher
                // and if firedFirstSpread is false
                // If so, write dialogue 
                if(this.contactType === "PLAYER" && !firedFirstSpread) {
                  addDialogue("Captain: Gunnery control, fire a spread at that contact!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                  firedFirstSpread = true;
                }

                // Calculate distance in radius units
                const distance = Math.sqrt(distSquared);
                
                // Calculate number of missiles based on distance
                // Add 1 missile for every spreadAttackMissilePerRadiusAmount * radius
                let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                
                // Set minimum and maximum number of missiles
                numMissiles = Math.max(2, numMissiles);
                
                // Calculate increased arming time (0.5 seconds per missile)
                const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                
                // Launch a spread of missiles
                const spreadAngle = Math.PI / 6; // 30 degrees
                for (let i = 0; i < numMissiles; i++) {
                  const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                  this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                }
                
                // Launch one more missile directly at the target
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              } else {
                
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
              }
            } else {
              // No valid solution found, launch directly at current position as fallback
              
              // NPC ships will never fire a spread at invalid targets
              if (isSpreadAttack && this.contactType !== "PLAYER") {
                // Just fire a single missile to conserve ammo
                this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
              } else {
                // For player, allow them to mess up and fire a spread if that's what they requested
                if (this.contactType === "PLAYER" && isSpreadAttack) {
                  // Calculate spread as in normal spread code
                  const distance = Math.sqrt(distSquared);
                  let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                  numMissiles = Math.max(2, numMissiles);
                  const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                  
                  // Direct angle toward target's current position
                  const selectedAngle = Math.atan2(dy, dx);
                  
                  // Launch spread
                  const spreadAngle = Math.PI / 6; // 30 degrees
                  for (let i = 0; i < numMissiles; i++) {
                    const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                    this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                  }
                  
                  // Launch direct missile too
                  this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                } else {
                  // Just fire a single missile for non-spread or non-player
                  this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
                }
              }
            }
          } else {
            // No intercept solution exists, launch directly at current position
            
            // NPC ships will never fire a spread at invalid targets
            if (isSpreadAttack && this.contactType !== "PLAYER") {
              // Just fire a single missile to conserve ammo
              this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
            } else {
              // For player, allow them to mess up and fire a spread if that's what they requested
              if (this.contactType === "PLAYER" && isSpreadAttack) {
                // Calculate spread as in normal spread code
                const distance = Math.sqrt(distSquared);
                let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                numMissiles = Math.max(2, numMissiles);
                const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                
                // Direct angle toward target's current position
                const selectedAngle = Math.atan2(dy, dx);
                
                // Launch spread
                const spreadAngle = Math.PI / 6; // 30 degrees
                for (let i = 0; i < numMissiles; i++) {
                  const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                  this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                }
                
                // Launch direct missile too
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              } else {
                // Just fire a single missile for non-spread or non-player
                this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
              }
            }
          }
        }
      }
      
      draw(deltaTime) {
        // If IFF is broadcasting, the contact should always be visible and updating its contact position
        if (this.iffBroadcasting) {
          this.visible = true;
          this.opacity = 1.0;
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
        }

        if (this.visible) {
          // Draw the contact at the last detected position
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          ctx.beginPath();
          ctx.arc(contactX, contactY, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${this.contactColor[0]}, ${this.contactColor[1]}, ${this.contactColor[2]}, ${this.opacity})`;
          ctx.fill();
          
          // Draw IFF bubble if broadcasting and mouse is nearby
          if (this.iffBroadcasting && typeof mouseX !== 'undefined' && typeof mouseY !== 'undefined') {
            // Calculate distance from mouse to contact
            const dx = mouseX - contactX;
            const dy = mouseY - contactY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate opacity based on distance (fully visible when close, fades out as distance increases)
            const iffOpacity = Math.max(0, 1 - (distance / iffBoxDisplayDistance));
            
            // Only draw if opacity > 0
            if (iffOpacity > 0) {
              // Draw IFF bubble
              const bubblePadding = 10;
              const lines = this.iffString.split('\n');
              const lineHeight = 16;
              const bubbleWidth = lines.reduce((max, line) => Math.max(max, ctx.measureText(line).width), 0) + (bubblePadding * 2);
              var bubbleHeight = ((lines.length + 1) * lineHeight) + (bubblePadding * 2); // Add 1 for the missile count line
              
              // Add extra height for missile count if it exists
              const hasMissiles = this.numMissiles !== undefined && this.numMissiles !== null;
              if (hasMissiles) {
                bubbleHeight += lineHeight;
              }
              
              // Calculate box position - default is to the right of the contact
              let boxX = contactX + 15;
              let boxY = contactY - 10;
              
              // Adjust if the box would go off the right edge of the canvas
              if (boxX + bubbleWidth > width) {
                boxX = contactX - bubbleWidth - 15; // Move to the left of the contact
              }
              
              // Adjust if the box would go off the top or bottom of the canvas
              if (boxY < 0) {
                boxY = 0; // Align with top of canvas
              } else if (boxY + bubbleHeight > height) {
                boxY = height - bubbleHeight; // Align with bottom of canvas
              }
              
              // Draw bubble background
              ctx.fillStyle = `rgba(0, 0, 0, ${iffOpacity * 0.7})`;
              ctx.fillRect(boxX, boxY, bubbleWidth, bubbleHeight);
              ctx.strokeStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.strokeRect(boxX, boxY, bubbleWidth, bubbleHeight);
              
              // Draw IFF string
              ctx.fillStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.font = "12px monospace";
              ctx.textAlign = "left";
              lines.forEach((line, i) => {
                ctx.fillText(line, boxX + bubblePadding, boxY + 15 + (i * lineHeight));
              });
              
              // Draw IFF status
              // ctx.fillStyle = `rgba(0, 255, 0, ${iffOpacity})`;
              // Frienly contacts have a green IFF broadcast, hostile contacts have a red IFF broadcast
              // Neutral contacts have a yellow IFF broadcast. Ghosts should not have an IFF broadcast but if they do, it should be white
              if (this.contactType === "FRIENDLY" || this.contactType === "PLAYER") {
                ctx.fillStyle = `rgba(0, 255, 0, ${iffOpacity})`;
              } else if (this.contactType === "HOSTILE") {
                ctx.fillStyle = `rgba(255, 0, 0, ${iffOpacity})`;
              } else if (this.contactType === "NEUTRAL") {
                ctx.fillStyle = `rgba(255, 255, 0, ${iffOpacity})`;
              } else {
                ctx.fillStyle = `rgba(255, 255, 255, ${iffOpacity})`;
              }
              ctx.fillText("IFF: BROADCASTING", boxX + bubblePadding, boxY + 15 + (lines.length * lineHeight));
              
              // Show missile count if available
              if (hasMissiles) {
                ctx.fillText(`MISSILES: ${this.numMissiles}`, boxX + bubblePadding, boxY + 15 + ((lines.length + 1) * lineHeight));
              }
            }
          }
          
          // Fade out the contact - now based on time
          this.opacity -= this.fadeSpeed * deltaTime;
          if (this.opacity <= 0) {
            this.visible = false;
          }
        }
        
        // Draw ELINT radiation cone if detected
        if (this.radiationDetected) {
          const startAngle = this.realBearing - ELINTHalfAngle;
          const endAngle = this.realBearing + ELINTHalfAngle;
          
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, startAngle, endAngle);
          ctx.lineTo(centerX, centerY);
          ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
          ctx.fill();
          
          // Draw the ELINT cone boundary lines
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(startAngle), 
            centerY + radius * Math.sin(startAngle)
          );
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(endAngle), 
            centerY + radius * Math.sin(endAngle)
          );
          ctx.strokeStyle = "#FFFF00";
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
    }

    // Extend Contacts to add heat seeking missiles
    class MissileContact extends Contact {
      constructor(bearing, distance, targetContact, fuelTime, contactType, armingTime, movementSpeed = 10) {
        // If the contact type is not one of the accepted types, default to "HOSTILE"
        if (!acceptedTypes.includes(contactType)) {
          contactType = "HOSTILE";
        }
        // Figure out the movement direction based on the target contact and the current bearing and distance
        // We are at (bearing, distance) and the target is at (targetContact.bearing, targetContact.distance), in polar coordinates
        // We want to move towards the target, so we need to calculate the angle between the two points
        // This is done by calculating the angle between the two points in cartesian coordinates and then converting it to polar coordinates
        // Figure out our position in cartesian coordinates
        const missileX = Math.cos(bearing) * distance;
        const missileY = Math.sin(bearing) * distance;
        // Figure out the target position in cartesian coordinates
        // so long as the target contact is not null or undefined or something like that
        if (targetContact) {
          var targetXv = Math.cos(targetContact.bearing) * targetContact.distance;
          var targetYv = Math.sin(targetContact.bearing) * targetContact.distance;
        } else {
          // If the target contact is null or undefined, default to the point at the radius and bearing
          var targetXv = Math.cos(bearing) * radius;
          var targetYv = Math.sin(bearing) * radius;
        }
        const targetX = targetXv;
        const targetY = targetYv;
        // Calculate the angle to the target
        const targetAngle = Math.atan2(targetY - missileY, targetX - missileX);

        // If the contact is friendly, create it like so
        if (contactType === "FRIENDLY") {
          // Create a friendly missile
          super(
            bearing, distance, 3, // bearing, starting distance, size
            movementSpeed, 0, targetAngle, // movementSpeed (fast enough to catch just about anything else), directionChangeFrequency (none as it should go only in one direction), movementDirection (direction of the target)
            true, 1.0, true, 1, // visible, opacity, immense radiation emission "due to really powerful engine" or something like that
            true, 1.0, true, 1.0, // fully radar and thermal detectable
            true, "HEAT SEEKING MISSILE\nACTIVE GUIDANCE\nFRIENDLY FIRE", [255, 0, 255], // IFF broadcasting
            contactType // Contact type
          );
        } else {
          // Create a hostile missile
          super(
            bearing, distance, 3, // bearing, starting distance, size
            movementSpeed, 0, targetAngle, // movementSpeed (fast enough to catch just about anything else), directionChangeFrequency (none as it should go only in one direction), movementDirection 
            false, 0, true, 1, // visible, opacity, immense radiation emission "due to really powerful engine" or something like that
            true, 1.0, true, 1.0, // fully radar and thermal detectable
            false, "", [255, 0, 0], // IFF broadcasting
            contactType // Contact type
          );
        }
        
        this.isMissile = true;
        this.targetContact = targetContact;
        this.thermalScanRadius = missileScanRadius;
        this.hasTarget = false;
        
        // Add fuel time property (in seconds)
        this.fuelTime = fuelTime; // Keeps track of original fuel time
        this.fuelRemaining = fuelTime;
        
        // Missile scan properties
        this.scanWidth = missileScanWidth; // Use the same width as the main scanner
        this.scanAngle = 0; // Current scan offset angle
        this.scanReversed = false; // Direction of scan
        this.scanCenter = 0; // Scan is centered forward of the missile

        // Arming time - Missile will not trigger collision check/explosion until armed
        this.armingTime = armingTime;

        // // debug
        // this.positionHistoryString = "Time = 0: " + centerX + ", " + centerY + "\n";
        // this.positionHistory = [{x: centerX, y: centerY, time: 0}];
      }
      
      updatePosition(deltaTime) {
        // debug
        // // get previous time
        // const prevTime = this.positionHistory[this.positionHistory.length - 1].time;
        // this.positionHistoryString += "Time = " + deltaTime + prevTime + ": " + this.realDistance * Math.cos(this.realBearing) + centerX + ", " + this.realDistance * Math.sin(this.realBearing) + centerY + "\n";
        // this.positionHistory.push({x: this.realDistance * Math.cos(this.realBearing) + centerX, y: this.realDistance * Math.sin(this.realBearing) + centerY, time: deltaTime + prevTime});

        // If not armed, count down arming time
        if (this.armingTime > 0) {
          this.armingTime -= deltaTime;
        }

        // Update fuel remaining
        this.fuelRemaining -= deltaTime;
        
        // Self-destruct if out of fuel
        if (this.fuelRemaining <= 0) {
          // Create explosion effect
          createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                         centerY + this.realDistance * Math.sin(this.realBearing));
          
          // Remove from contacts array
          const index = contacts.indexOf(this);
          if (index > -1) {
            contacts.splice(index, 1);
          }
          return;
        }
        
        // Update scan angle
        if (this.scanReversed) {
          this.scanAngle -= (Math.PI * missileScanSpeed / 180) * deltaTime;
          if (this.scanAngle <= -this.scanWidth/2) {
            this.scanAngle = -this.scanWidth/2;
            this.scanReversed = false;
          }
        } else {
          this.scanAngle += (Math.PI * missileScanSpeed / 180) * deltaTime;
          if (this.scanAngle >= this.scanWidth/2) {
            this.scanAngle = this.scanWidth/2;
            this.scanReversed = true;
          }
        }
        
        // Scan for thermal contacts if no target yet and armed 
        if (!this.hasTarget && this.armingTime <= 0) {
          // Use the missile's movement direction as its orientation.
          const missileOrientation = this.movementDirection;
          const absoluteScanAngle = missileOrientation + this.scanAngle;
          
          // Look for contacts in thermal scan range
          for (let contact of contacts) {
            if (contact === this) continue; // Skip self
            
            // Determine missile and contact positions in cartesian coordinates
            const missileX = centerX + this.realDistance * Math.cos(this.realBearing);
            const missileY = centerY + this.realDistance * Math.sin(this.realBearing);
            const contactX = centerX + contact.realDistance * Math.cos(contact.realBearing);
            const contactY = centerY + contact.realDistance * Math.sin(contact.realBearing);
            
            // Calculate position difference and distance
            const dx = contactX - missileX;
            const dy = contactY - missileY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate angle to contact relative to the missile's orientation
            const angleToContact = Math.atan2(dy, dx);
            const angleDiff = normalizeAngle(angleToContact - missileOrientation);
            
            // Check if contact is within scan arc and radius
            if (distance < this.thermalScanRadius &&
                Math.abs(angleDiff - this.scanAngle) < 0.1 &&
                contact.thermalDetectable) {
              this.targetContact = contact;
              this.hasTarget = true;
              break;
            }
          }
        }
        
        // Update missile direction if it has a target
        if (this.hasTarget && this.targetContact && !this.targetContact.destroyed) {
          // Calculate direction to target
          const targetX = Math.cos(this.targetContact.realBearing) * this.targetContact.realDistance;
          const targetY = Math.sin(this.targetContact.realBearing) * this.targetContact.realDistance;
          const missileX = Math.cos(this.realBearing) * this.realDistance;
          const missileY = Math.sin(this.realBearing) * this.realDistance;
          
          // Set movement direction toward target
          this.movementDirection = Math.atan2(targetY - missileY, targetX - missileX);
        }
        
        // Call parent updatePosition
        super.updatePosition(deltaTime);
        
        // Check for collisions with contacts, but only if it has a target
        if (this.hasTarget) {
          this.checkCollisions();
        }
      }
      
      checkCollisions() {
        // Only check for collisions if armed
        if (this.armingTime > 0) return;

        for (let i = 0; i < contacts.length; i++) {
          const contact = contacts[i];
          if (contact === this) continue; // Skip self and other missiles
          
          // Calculate distance between missile and contact
          const dx = Math.cos(contact.realBearing) * contact.realDistance - Math.cos(this.realBearing) * this.realDistance;
          const dy = Math.sin(contact.realBearing) * contact.realDistance - Math.sin(this.realBearing) * this.realDistance;
          const distance = Math.sqrt(dx*dx + dy*dy);
          
          // If collision detected with a thermal detectable contact, destroy both
          if (distance < (this.size + contact.size) && contact.thermalDetectable) {
            // Mark both as destroyed
            this.destroyed = true;
            contact.destroyed = true;
            
            // Create explosion effect
            createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                           centerY + this.realDistance * Math.sin(this.realBearing));
            
            // Remove both from contacts array
            console.log("Missile collided with contact:", contact);
            console.log("Missile destroyed:", this);

            contacts.splice(contacts.indexOf(this), 1);
            contacts.splice(contacts.indexOf(contact), 1);
            return;
          }
        }
      }
      
      draw(deltaTime) {
        // Draw the thermal scan cone if visible and friendly
        // Friendly contacts are "sending missile telemetry" to the player
        // Doesn't make sense for hostile or neutral contacts to do this
        if (this.visible && this.contactType === "FRIENDLY") {
          this.drawScanCone();
        }
        
        // Call parent draw method
        super.draw(deltaTime);
        
        // Draw fuel indicator if visible and friendly (see earlier comment about telemetry)
        if (this.visible && this.contactType === "FRIENDLY") {
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          // Draw fuel bar
          const barWidth = 20;
          const barHeight = 4;
          const fuelPercentage = this.fuelRemaining / this.fuelTime;
          
          // Draw fuel background
          ctx.fillStyle = "rgba(100, 100, 100, 0.7)";
          ctx.fillRect(contactX - barWidth/2, contactY + 8, barWidth, barHeight);
          
          // Draw remaining fuel - color changes as fuel depletes
          let fuelColor;
          if (fuelPercentage > 0.6) {
            fuelColor = "rgba(0, 255, 0, 0.7)"; // Green
          } else if (fuelPercentage > 0.3) {
            fuelColor = "rgba(255, 255, 0, 0.7)"; // Yellow
          } else {
            fuelColor = "rgba(255, 0, 0, 0.7)"; // Red
          }
          
          ctx.fillStyle = fuelColor;
          ctx.fillRect(contactX - barWidth/2, contactY + 8, barWidth * fuelPercentage, barHeight);
          
          // Update IFF string with fuel information
          const fuelSeconds = Math.round(this.fuelRemaining);
          this.iffString = `HEAT SEEKING MISSILE\nACTIVE GUIDANCE\nFUEL: ${fuelSeconds}s REMAINING`;
        }
      }
      
      drawScanCone() {
        // Calculate position on screen
        const missileX = centerX + this.realDistance * Math.cos(this.realBearing);
        const missileY = centerY + this.realDistance * Math.sin(this.realBearing);
        
        // Calculate orientation of missile (direction of movement)
        const missileOrientation = this.movementDirection;
        
        // Calculate start and end angles for the scan cone
        const absoluteScanAngle = missileOrientation + this.scanAngle;
        const startAngle = missileOrientation + this.scanCenter - this.scanWidth/2;
        const endAngle = missileOrientation + this.scanCenter + this.scanWidth/2;
        
        // Draw the thermal scan area
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.arc(missileX, missileY, this.thermalScanRadius, startAngle, endAngle);
        ctx.lineTo(missileX, missileY);
        ctx.fillStyle = "rgba(0, 0, 255, 0.2)"; // Thermal blue for missile scan
        ctx.fill();
        
        // Draw the thermal scan boundary lines
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(startAngle), 
          missileY + this.thermalScanRadius * Math.sin(startAngle)
        );
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(endAngle), 
          missileY + this.thermalScanRadius * Math.sin(endAngle)
        );
        ctx.strokeStyle = "#0000FF"; // Blue outline
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw the active scan line
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(absoluteScanAngle), 
          missileY + this.thermalScanRadius * Math.sin(absoluteScanAngle)
        );
        ctx.strokeStyle = "#0000FF"; // Blue
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    function drawBackground(deltaTime) {
      // Draw fading overlay - fade rate now per second
      ctx.fillStyle = `rgba(0, 0, 0, ${fadeRate * deltaTime})`;
      ctx.fillRect(0, 0, width, height);
      
      // Draw radar circle
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.strokeStyle = "#00AA00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw grid lines
      drawGrid();
    }
    
    function drawGrid() {
      // Draw crosshairs
      ctx.beginPath();
      ctx.moveTo(centerX - radius, centerY);
      ctx.lineTo(centerX + radius, centerY);
      ctx.moveTo(centerX, centerY - radius);
      ctx.lineTo(centerX, centerY + radius);
      ctx.strokeStyle = "#004400";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw concentric circles with range readouts
      const rangeLabels = ["0.25ls", "0.5ls", "0.75ls", "1ls"];
      
      for (let i = 1; i <= 4; i++) {
        const circleRadius = radius * i/4;
        // Draw the circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = "#004400";
        ctx.stroke();
        
        // Draw the range readout at the top of each circle
        ctx.fillStyle = "#00FF00";
        ctx.font = "12px monospace";
        ctx.textAlign = "center";
        ctx.fillText(rangeLabels[i-1], centerX, centerY - circleRadius);
      }
    }
    
    function drawRadarLine() {
      // Calculate the endpoint of the rotating line
      const endX = centerX + radius * Math.cos(angle);
      const endY = centerY + radius * Math.sin(angle);

      // Draw the rotating line
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw radar sweep (the glow effect)
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0, 
        centerX, centerY, radius
      );
      gradient.addColorStop(0, "rgba(0, 255, 0, 0.2)");
      gradient.addColorStop(1, "rgba(0, 255, 0, 0)");
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, angle - 0.2, angle, false);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
    
    function drawThermalScan() {
      // Draw the thermal scan zone
      const startAngle = thermalScanCenter - thermalScanWidth/2;
      const endAngle = thermalScanCenter + thermalScanWidth/2;
      
      // Draw the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, thermalScanRadius, startAngle, endAngle);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = "rgba(0, 0, 255, 0.2)";
      ctx.fill();
      
      // Draw the thermal scan boundary lines
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(startAngle), 
                 centerY + thermalScanRadius * Math.sin(startAngle));
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(endAngle), 
                 centerY + thermalScanRadius * Math.sin(endAngle));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw a line sweeping across the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(thermalScanAngle + thermalScanCenter), 
                 centerY + thermalScanRadius * Math.sin(thermalScanAngle + thermalScanCenter));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // For drawing how many missiles are left in stock on the player ship
    // Draws in the top left corner of the screen
    function drawCurrentMissiles() {
      const playerContact = contacts[0]; // Assuming the player ship is the first contact

      if (playerContact && playerContact.visible && playerContact.numMissiles !== undefined) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(10, 10, 150, 50);
        
        ctx.fillStyle = "#00FF00";
        ctx.font = "20px monospace";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText(`MISSILES: ${playerContact.numMissiles}`, 20, 20);
      }

    }

    // Function to add a new dialogue message
    function addDialogue(text, color, duration = defaultDialogueTime, imageFilePath) {
      // Add the message to the array with current time + duration as expiry time
      dialogueMessages.push({
      text: text,
      color: color,
      expiryTime: Date.now() + (duration * 1000), // Multiply by 1000 to convert to milliseconds
      image: imageFilePath
      });
    }

    // Function to draw dialogue messages in the top right corner
    function drawDialogue() {
      const currentTime = Date.now();
      
      // If no messages or all messages expired, don't draw anything
      if (dialogueMessages.length === 0 || dialogueMessages[dialogueMessages.length - 1].expiryTime < currentTime) {
        return;
      }
      
      const maxWidth = 375;
      const padding = 15;
      const lineHeight = 20;
      let currentY = 10; // Start at the top
      
      // Image dimensions
      const imageWidth = 80;
      const imageHeight = 120;
      
      // Draw messages from newest to oldest
      for (let i = dialogueMessages.length - 1; i >= 0; i--) {
        const message = dialogueMessages[i];
        
        // Skip expired messages
        if (message.expiryTime < currentTime) {
          continue;
        }
        
        // Split text into lines for wrapping
        const words = message.text.split(' ');
        let lines = [];
        let currentLine = words.length > 0 ? words[0] : '';
        
        ctx.font = "16px Arial";
        
        // Create wrapped lines
        for (let j = 1; j < words.length; j++) {
          const testLine = currentLine + ' ' + words[j];
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth) {
            lines.push(currentLine);
            currentLine = words[j];
          } else {
            currentLine = testLine;
          }
        }
        lines.push(currentLine);
        
        // Calculate box dimensions based on whether there's an image
        // Has image is true if the image property is defined.
        const hasImage = message.image !== undefined && message.image !== null && message.image !== "" ;
        const boxWidth = maxWidth + (padding * 2) + (hasImage ? imageWidth + padding : 0);
        const boxHeight = Math.max((lines.length * lineHeight) + (padding * 2), hasImage ? imageHeight + (padding * 2) : 0);
        
        // Check if we're going off-screen and need to stop drawing
        if (currentY + boxHeight > height) {
          break;
        }
        
        const boxX = width - boxWidth - 10;
        const boxY = currentY;
        
        // Draw the background box
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Draw the image if specified
        if (hasImage) {
          // If image hasn't been loaded yet, create and cache it
          if (!message.imageObject) {
            message.imageObject = new Image();
            message.imageObject.src = message.image;
          }
          
          // Position image inside the box with some padding
          const imgX = boxX + padding;
          const imgY = boxY + (boxHeight - imageHeight) / 2; // Center vertically
          
          // Only draw if the image is loaded
          if (message.imageObject.complete && message.imageObject.naturalWidth > 0) {
            ctx.drawImage(message.imageObject, imgX, imgY, imageWidth, imageHeight);
          }
        }
        
        // Draw the text - right aligned if no image, left aligned if there is an image
        ctx.fillStyle = message.color;
        ctx.textAlign = hasImage ? "left" : "right";
        ctx.textBaseline = "top";
        
        // Calculate text position
        const textX = hasImage 
          ? boxX + imageWidth + (padding * 2) // If image, position text after image
          : boxX + boxWidth - padding; // If no image, position from right edge
        
        const textY = boxY + (hasImage 
          ? (boxHeight - (lines.length * lineHeight)) / 2 // Center text vertically if there's an image
          : padding); // Default padding if no image
        
        lines.forEach((line, index) => {
          ctx.fillText(line, textX, textY + (index * lineHeight));
        });
        
        // Update Y position for next message
        currentY += boxHeight + 5; // 5px gap between boxes
      }
    }

    // Variables for message history
    let isViewingMessageHistory = false;
    let messageHistoryScrollPosition = 0;
    
    // Function to draw message history window
    function drawMessageHistory() {
      // Clear the screen with a dark background
      ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
      ctx.fillRect(0, 0, width, height);
      
      // Calculate window dimensions
      const margin = 50;
      const windowWidth = width - (margin * 2);
      const windowHeight = height - (margin * 2);
      
      // Draw window background
      ctx.fillStyle = "rgba(20, 20, 30, 0.8)";
      ctx.fillRect(margin, margin, windowWidth, windowHeight);
      ctx.strokeStyle = "rgba(0, 255, 255, 0.7)";
      ctx.lineWidth = 2;
      ctx.strokeRect(margin, margin, windowWidth, windowHeight);
      
      // Draw title
      ctx.font = "bold 24px Arial";
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText("MESSAGE HISTORY", centerX, margin + 20);
      
      // Draw navigation instructions
      ctx.font = "16px Arial";
      ctx.fillStyle = "#AAAAAA";
      ctx.fillText("Use UP/DOWN arrows to scroll, press H to return", centerX, margin + 50);
      
      // Draw divider line
      ctx.beginPath();
      ctx.moveTo(margin + 20, margin + 80);
      ctx.lineTo(margin + windowWidth - 20, margin + 80);
      ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Set up scrollable area
      const contentAreaTop = margin + 100;
      const contentAreaHeight = windowHeight - 120;
      const contentAreaBottom = contentAreaTop + contentAreaHeight;
      
      // Clip to content area
      ctx.save();
      ctx.beginPath();
      ctx.rect(margin + 20, contentAreaTop, windowWidth - 40, contentAreaHeight);
      ctx.clip();
      
      // Display messages
      const lineHeight = 24;
      const visibleMessages = [...dialogueMessages].reverse(); // Show newest messages first
      let y = contentAreaTop - messageHistoryScrollPosition;
      
      ctx.textAlign = "left";
      ctx.font = "16px Arial";
      
      visibleMessages.forEach(message => {
        // Format timestamp
        const timestamp = new Date(message.expiryTime - (defaultDialogueTime * 1000));
        const timeString = timestamp.toTimeString().split(' ')[0];
        
        // Draw timestamp
        ctx.fillStyle = "#888888";
        ctx.fillText(timeString, margin + 40, y);
        
        // Calculate text dimensions and position
        const textMaxWidth = windowWidth - 250;
        
        // Split text into lines for wrapping
        const words = message.text.split(' ');
        let lines = [];
        let currentLine = words.length > 0 ? words[0] : '';
        
        // Create wrapped lines
        for (let i = 1; i < words.length; i++) {
          const testLine = currentLine + ' ' + words[i];
          const metrics = ctx.measureText(testLine);
          if (metrics.width > textMaxWidth) {
            lines.push(currentLine);
            currentLine = words[i];
          } else {
            currentLine = testLine;
          }
        }
        lines.push(currentLine);
        
        // Draw message text
        ctx.fillStyle = message.color;
        lines.forEach((line, index) => {
          ctx.fillText(line, margin + 150, y + (index * lineHeight));
        });
        
        // Move Y position for next message
        y += (lines.length * lineHeight) + 15;
      });
      
      // Restore clipping
      ctx.restore();
      
      // Draw scroll indicators if needed
      if (messageHistoryScrollPosition > 0) {
        // Draw up arrow
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        ctx.moveTo(width - margin - 30, contentAreaTop + 20);
        ctx.lineTo(width - margin - 15, contentAreaTop + 5);
        ctx.lineTo(width - margin - 45, contentAreaTop + 5);
        ctx.closePath();
        ctx.fill();
      }
      
      // Check if we need to show down arrow (if more content exists below)
      const totalContentHeight = visibleMessages.reduce((total, msg) => {
        const lines = Math.ceil(ctx.measureText(msg.text).width / (windowWidth - 150));
        return total + (lines * lineHeight) + 15;
      }, 0);
      
      if (messageHistoryScrollPosition < totalContentHeight - contentAreaHeight && totalContentHeight > contentAreaHeight) {
        // Draw down arrow
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        ctx.moveTo(width - margin - 30, contentAreaBottom - 20);
        ctx.lineTo(width - margin - 15, contentAreaBottom - 5);
        ctx.lineTo(width - margin - 45, contentAreaBottom - 5);
        ctx.closePath();
        ctx.fill();
      }
    }

    // Draws the game over message in the center of the screen
    function drawGameOver() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, width, height);
      
      ctx.font = "bold 48px Arial";
      ctx.fillStyle = gameOverColor;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(gameOverMessage, centerX, centerY);
    }

    // Draws the pause menu in the center of the screen
    // Says "PAUSED" in big centered letters, then below it "Press P to unpause"
    function drawPauseMenu() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, width, height);
      
      ctx.font = "bold 48px Arial";
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("PAUSED", centerX, centerY - 20);
      ctx.font = "24px Arial";
      ctx.fillText("Press P to unpause", centerX, centerY + 20);
      ctx.fillText("Press H for message history", centerX, centerY + 60);
    }
    
    function normalizeAngle(a) {
      // Normalize angle to be between -pi and pi
      return a - Math.PI * 2 * Math.floor((a + Math.PI) / (Math.PI * 2));
    }
      
    // Function to create custom timeouts that respect pause state
    function createTimeout(callback, delay) {
      window.customTimeouts.push({
        callback: callback,
        delay: delay,
        elapsed: 0
      });
    }

    // Function to create custom intervals that respect pause state
    function createInterval(callback, delay) {
      const intervalId = Date.now() + Math.random(); // Generate a unique ID
      
      if (!window.customIntervals) {
        window.customIntervals = [];
      }
      
      window.customIntervals.push({
        callback: callback,
        delay: delay,
        elapsed: 0,
        id: intervalId
      });
      
      return intervalId; // Return ID so it can be cleared later
    }

    // Function to clear a custom interval
    function uncreateInterval(intervalId) {
      if (!window.customIntervals) return;
      
      const index = window.customIntervals.findIndex(interval => interval.id === intervalId);
      if (index !== -1) {
        window.customIntervals.splice(index, 1);
      }
    }

    // Activate enemy ships to start attacking
    function activateEnemyShips() {
      // The enemies are already spawned, this just triggers their first attack
      const hostileShips = contacts.filter(c => c.contactType === "HOSTILE" && !c.isMissile);
      
      for (let ship of hostileShips) {
        createTimeout(() => {
          enemyCanAttack = true; // Allow enemy to attack
          launchRandomAttack(ship);
        }, Math.random() * 3000); // Random delay between 0-3 seconds
      }
    }

    // Function to launch a random attack from an enemy ship
    function launchRandomAttack(ship) {
      // Stop if the ship is out of missiles
      if (ship.numMissiles <= 0) return;
      
      // Choose a random attack type
      const attackType = Math.floor(Math.random() * 4);
      
      // Get player ship
      const playerShip = contacts[0];
      
      switch (attackType) {
        case 0: // Single direct missile
          ship.launchMissileAtContact(playerShip, enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed, false);
          enemyMissilesLaunched++;
          break;
          
        case 1: // Two direct missiles
          ship.launchMissileAtContact(playerShip, enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed, false);
          enemyMissilesLaunched++;
          
          createTimeout(() => {
            if (ship.numMissiles > 0) {
              ship.launchMissileAtContact(playerShip, enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed, false);
              enemyMissilesLaunched++;
            }
          }, 2000);
          break;
          
        case 2: // Two zig-zag missiles
          const playerBearing = Math.atan2(
            -Math.sin(ship.realBearing) * ship.realDistance,
            -Math.cos(ship.realBearing) * ship.realDistance
          );
          
          // Create off-angled missiles that will change course
          ship.launchMissileAlongAngle(playerBearing + Math.PI/6, enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed);
          enemyMissilesLaunched++;
          
          createTimeout(() => {
            if (ship.numMissiles > 0) {
              ship.launchMissileAlongAngle(playerBearing - Math.PI/6, enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed);
              enemyMissilesLaunched++;
              
              // Get reference to the missiles we just launched
              const missiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE");
              
              if (missiles.length >= 2) {
                // Store the time each missile was created
                const missile1Id = Date.now();
                const missile2Id = Date.now() + 1;
                
                // Add zigzag properties to the missiles
                missiles[missiles.length-1].zigzagState = true;  // Last created missile
                missiles[missiles.length-1].missileId = missile2Id;
                missiles[missiles.length-2].zigzagState = false; // Second-to-last created missile
                missiles[missiles.length-2].missileId = missile1Id;
                
                // Setup zigzag behavior
                const zigzagInterval = createInterval(() => {
                  const activeMissiles = contacts.filter(c => 
                    c.isMissile && 
                    c.contactType === "HOSTILE" && 
                    (c.missileId === missile1Id || c.missileId === missile2Id)
                  );
                  
                  if (activeMissiles.length === 0) {
                    uncreateInterval(zigzagInterval);
                    return;
                  }
                  
                  // Make each active missile change direction in zigzag pattern
                  for (let missile of activeMissiles) {
                    // Check distance to player
                    const distToPlayer = Math.sqrt(
                      Math.pow(Math.cos(missile.realBearing) * missile.realDistance, 2) + 
                      Math.pow(Math.sin(missile.realBearing) * missile.realDistance, 2)
                    );
                  
                    if (distToPlayer < radius * 0.25) {
                      // Close to player, home in
                      missile.targetContact = playerShip;
                      missile.hasTarget = true;
                    } else {
                      // Apply zig or zag based on current state
                      if (missile.zigzagState) {
                        missile.movementDirection += Math.PI / 3;  // Zig right
                      } else {
                        missile.movementDirection -= Math.PI / 3;  // Zag left
                      }
                    
                      // Toggle the state for next time
                      missile.zigzagState = !missile.zigzagState;
                    
                      // After changing direction, make sure it's still generally heading toward player
                      const toPlayerBearing = Math.atan2(
                        -Math.sin(missile.realBearing) * missile.realDistance,
                        -Math.cos(missile.realBearing) * missile.realDistance
                      );
                    
                      // Limit how far the missile can turn away from player
                      const angleDiff = normalizeAngle(missile.movementDirection - toPlayerBearing);
                      if (Math.abs(angleDiff) > Math.PI/2) {
                        // If missile is heading more than 90° away from player, correct course
                        missile.movementDirection = toPlayerBearing + (angleDiff > 0 ? Math.PI/3 : -Math.PI/3);
                      }
                    }
                  }
                }, 800);
              }
            }
          }, 2000);
          break;
          
        case 3: // Three-pronged attack (-45, 0, +45 degrees then all home in)
          if (!seenThreeProngedAttack) {
            seenThreeProngedAttack = true;
            createTimeout(() => {
              addDialogue("Captain: Looks like they're firing a three pronged spread! Watch out for the ones on the sides, they might arc back!", captainColor, defaultDialogueTime, captainPortraitFilePath);
            }, 2000);
          }
          
          const toPlayerBearing = Math.atan2(
            -Math.sin(ship.realBearing) * ship.realDistance,
            -Math.cos(ship.realBearing) * ship.realDistance
          );
          
          // Fire center missile
          ship.launchMissileAlongAngle(toPlayerBearing, enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed);
          enemyMissilesLaunched++;
          
          // Fire left missile
          if (ship.numMissiles > 0) {
            createTimeout(() => {
              ship.launchMissileAlongAngle(toPlayerBearing - Math.PI/4, enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed);
              enemyMissilesLaunched++;
            }, 1000);
          }
          
          // Fire right missile
          if (ship.numMissiles > 0) {
            createTimeout(() => {
              ship.launchMissileAlongAngle(toPlayerBearing + Math.PI/4, enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed);
              enemyMissilesLaunched++;
              
              // After 4 seconds, make all three missiles home in on player
              createTimeout(() => {
                const missiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE");
                for (let missile of missiles) {
                  missile.targetContact = playerShip;
                  missile.hasTarget = true;
                }
              }, 4000);
            }, 2000);
          }
          break;
      }
    }

    // Function to create asteroid contacts
    function createAsteroids(numAsteroids) {
      for (let i = 0; i < numAsteroids; i++) {
        // Generate evenly distributed positions around the circle
        const angle = (i / numAsteroids) * Math.PI * 2;
        const distance = Math.random() * radius * 0.8 + radius * 0.1; // Between 0.1 and 0.9 radius
        
        contacts.push(
          new Contact(
            angle, distance, 4, // bearing, distance, size
            0, 0, 0, // Speed 0 (stationary), no direction change
            false, 0, false, 0, // Not visible initially, no ELINT
            true, 1.0, true, 1.0, // 100% radar detection, thermally detectable
            false, "ASTEROID\nNO TRANSPONDER", [255, 0, 0], // IFF info
            "NEUTRAL" // Contact type
          )
        );
      }
    }

    // Function to spawn enemy ships
    function spawnEnemyShips() {
      // Ship at 90 degrees (bottom side)
      contacts.push(
        new Contact(
          Math.PI/2, radius * 0.5, 6, // bearing, distance, size
          1.2, 1, Math.random() * Math.PI * 2, // Some movement, occasional direction change
          false, 0, true, 0.7, // Not visible, high ELINT detection
          false, 0, true, 1.0, // No radar detection, thermally detectable
          false, "HOSTILE SHIP\nPIRATE VESSEL", [255, 0, 0], // IFF info
          "HOSTILE", // Contact type
          numEnemyMissiles // numEnemyMissiles missiles
        )
      );
      
      // Ship at 270 degrees (top side)
      contacts.push(
        new Contact(
          3 * Math.PI/2, radius * 0.5, 6, // bearing, distance, size
          1.2, 1, Math.random() * Math.PI * 2, // Some movement, occasional direction change
          false, 0, true, 0.7, // Not visible, high ELINT detection
          false, 0, true, 1.0, // No radar detection, thermally detectable
          false, "HOSTILE SHIP\nPIRATE VESSEL", [255, 0, 0], // IFF info
          "HOSTILE", // Contact type
          numEnemyMissiles // numEnemyMissiles missiles
        )
      );
      
      // Set up interval to track enemy missiles
      missileCheckInterval = createInterval(() => {
        // Get all hostile non-missile contacts
        const hostileShips = contacts.filter(c => c.contactType === "HOSTILE" && !c.isMissile);
        
        // Get all hostile missiles
        const hostileMissiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE");
        
        // Check for zigzag pattern
        if (hostileMissiles.length > 0 && !seenZigZagMissiles) {
          for (let missile of hostileMissiles) {
            if (missile.zigzagState !== undefined) {
              seenZigZagMissiles = true;
              createTimeout(() => {
                addDialogue("Engineer: Captain, I'm picking up a similar zig-zag pattern to the one we saw before.", engineerColor);
                createTimeout(() => {
                  addDialogue("Captain: Again with the zig-zag missiles? Wait for them to home in, then knock them out.", captainColor, defaultDialogueTime, captainPortraitFilePath);
                }, 3000);
              }, 1000);
              break;
            }
          }
        }
        
        // If no hostile ships left, clear interval
        if (hostileShips.length === 0) {
          uncreateInterval(missileCheckInterval);
        }
        
        // If no hostile missiles present, check if ships need to attack
        if (hostileMissiles.length === 0 && hostileShips.length > 0) {
          for (let ship of hostileShips) {
            // Only launch if the ship has missiles left and is within proper range, and the flag for attacking is set
            if (ship.numMissiles > 0 && ship.realDistance > radius * 0.25 && ship.realDistance < radius * 0.75 && enemyCanAttack) {
              launchRandomAttack(ship);
            }
            
            // Check if ship is out of missiles and needs to retreat
            if (ship.numMissiles === 0) {
              // Set retreat direction away from center
              ship.directionChangeFrequency = 0; // No more direction change
              ship.movementDirection = ship.realBearing; // The bearing also give the direction to retreat
              
              // Check if both ships are out of missiles
              if (enemyMissilesRemaining == 0 && !response8) {
                response8 = true;
                addDialogue("Engineer: Seems like they're out of ammo. Why else would they have ceased fire?", engineerColor, defaultDialogueTime);
                // Add a delay before the captain's response
                createTimeout(() => {
                  ship.movementSpeed *= 2; // Double speed for retreat
                  addDialogue("Captain: Excellent. I imagine they're retreating now. But we will remain at general quarters until they're gone.", captainColor, defaultDialogueTime, captainPortraitFilePath);
                }, 3000);
              }
            }
            
            // Remove ship if it reaches the edge during retreat
            if (ship.numMissiles === 0 && ship.realDistance > radius * 0.9) {
              const index = contacts.indexOf(ship);
              if (index > -1) {
                contacts.splice(index, 1);
              }
            }
          }
        }
        
        // Check for any ship destruction
        if (!enemyShip1Destroyed && hostileShips.length === 1 && areAllContactsGone("HOSTILE") === false) {
          enemyShip1Destroyed = true;
          addDialogue("Engineer: Telemetry indicates target destroyed!", engineerColor);
          createTimeout(() => {
            addDialogue("Captain: Good work. Now let's finish off the other one.", captainColor, defaultDialogueTime, captainPortraitFilePath);
          }, 3000);
        }
      }, 1000);
    }
    
    function animate(currentTime) {

      // Keep track of how many enemy missiles are remaining
      // Get all hostile contacts that are not missiles
      const hostileShips = contacts.filter(c => c.contactType === "HOSTILE" && !c.isMissile);
      // Iterate through and add up the number of missiles remaining
      let totalMissiles = 0;
      for (let ship of hostileShips) {
        totalMissiles += ship.numMissiles;
      }
      enemyMissilesRemaining = totalMissiles;


      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $operation3Allowed === "undefined" || $operation3Allowed === null || !$operation3Allowed) {
        // Cancel the animation frame if the operation is not allowed to run
        return;
      }
    
      // Game over check
      if (gameOver) {
        // If viewing message history, draw that instead of game over menu
        if (isViewingMessageHistory) {
          drawMessageHistory();
        } else {
          // Draw game over message
          drawGameOver();
        }

        // Keep animating, but only up to here
        requestAnimationFrame(animate)
        return;
      }
      
      // Check if game should end now
      // Check if all player ships are gone
      if (areAllContactsGone("PLAYER") && checkForVictory) {
        gameOver = true;
        $playerWonO3 = false;
        gameOverMessage = "DEFEAT!";
        gameOverColor = "red";
        // Play defeat sound
        const audio = new Audio("../assets/defeat.mp3");
        audio.play();
      }

      // Check if all hostile contacts are gone
      if (areAllContactsGone("HOSTILE") && checkForVictory) {
        gameOver = true;
        $playerWonO3 = true;
        gameOverMessage = "VICTORY!";
        gameOverColor = "green";
        // Play victory sound
        const audio = new Audio("../assets/victory.mp3");
        audio.play();
      }
      
      // Calculate time since last frame
      const deltaTime = ((currentTime - lastFrameTime) / 1000) * deltaTimeMultiplier; // Convert to seconds, then scale by deltaTimeMultiplier
      // Helps with keeping track of unpaused time
      let trueDeltaTimeMillis = currentTime - lastFrameTime;
      lastFrameTime = currentTime;

      // Pause check is placed here to ensure deltaTime will not jump when unpausing
      if (gamePaused) {
        // If viewing message history, draw that instead of pause menu
        if (isViewingMessageHistory) {
          drawMessageHistory();
        } else {
          // Pause menu is drawn in the event listener
        }

        // Keep animating, but only up to here
        requestAnimationFrame(animate)
        return;
      }

      // Keep track of how much time has been spent outside of pause
      unpausedElapsedTimeMillis += trueDeltaTimeMillis;
      
      // Custom timeout handling system
      if (!window.customTimeouts) {
        window.customTimeouts = [];
      }
      
      // Process any active timeouts
      for (let i = window.customTimeouts.length - 1; i >= 0; i--) {
        const timeout = window.customTimeouts[i];
        timeout.elapsed += trueDeltaTimeMillis;
        
        if (timeout.elapsed >= timeout.delay) {
          // Execute the callback and remove from array
          timeout.callback();
          window.customTimeouts.splice(i, 1);
        }
      }

      // Custom interval handling system
      if (!window.customIntervals) {
        window.customIntervals = [];
      }
    
      // Process any active intervals
      for (let i = window.customIntervals.length - 1; i >= 0; i--) {
        // Check if the interval still exists (may have been removed by another callback)
        if (i < window.customIntervals.length) {
          const interval = window.customIntervals[i];

          // Make sure interval is defined before trying to use it
          // Shouldn't be necessary, yet if this check is not here, the tutorial operation breaks after the missiles collide
          // May indicate that other operations could similarly break, hence this check is here
          if (interval) {
            // Only increment elapsed time when game is not paused
            interval.elapsed += trueDeltaTimeMillis;

            if (interval.elapsed >= interval.delay) {
              try {
                // Execute the callback but don't remove from array
                interval.callback();
                // Reset elapsed time for next interval
                interval.elapsed = 0;
              } catch (error) {
                console.error("Error in interval callback:", error);
                // Remove problematic interval
                window.customIntervals.splice(i, 1);
              }
            }
          } else {
            // Remove undefined interval if it somehow exists
            window.customIntervals.splice(i, 1);
          }
        }
      }


      // // Initial dialogue
      // if (!response1 && !response1a) {
      //   response1a = true;
      //   addDialogue("Engineer: Radar's been acting up. I think I'm seeing ghosts, although we have a faint but consistent contact somewhere between 110 and 80 degrees.", engineerColor);
        
      //   createTimeout(() => {
      //     response1 = true;
      //   }, 5000);
      // }

      // if (response1 && !response2 && !response2a) {
      //   response2a = true;
      //   createTimeout(() => {
      //     addDialogue("Captain: I don't like the sound of that last contact. Keep me informed if anything changes. That distress call could have attracted unwanted attention.", captainColor, defaultDialogueTime, captainPortraitFilePath);
      //     response2 = true;
      //   }, 4000);
      // }

      // if (response2 && !response3 && !response3a) {
      //   response3a = true;
      //   createTimeout(() => {
      //     addDialogue("Engineer: We have an incoming broadcast, bearing 90 degrees!", engineerColor);
      //     response3 = true;
      //   }, 5000);
      // }

      // if (response3 && !response4 && !response4a) {
      //   response4a = true;
      //   createTimeout(() => {
      //     addDialogue("Captain: Put it through.", captainColor, 4, captainPortraitFilePath);
          
      //     createTimeout(() => {
      //       addDialogue("???: Hello prey. You would do well to cut engines and power down your weapons.", unidentifiedColor);
      //       response4 = true;
      //     }, 6000);
      //   }, 3000);
      // }

      // if (response4 && !response5 && !response5a) {
      //   response5a = true;
      //   createTimeout(() => {
      //     addDialogue("Captain: I will do no such thing. Who do you think you are, ordering around a Central Republic warship?", captainColor, defaultDialogueTime, captainPortraitFilePath);
          
      //     createTimeout(() => {
      //       addDialogue("Corsair: The man commanding the pirates and the battlecruiser chasing you. Onboard, I have over one thousand extended range missiles loaded and ready to fire.", pirateColor);
            
      //       createTimeout(() => {
      //         addDialogue("Corsair: Now I will repeat my dema-", pirateColor, 3);
              
      //         createTimeout(() => {
      //           addDialogue("Captain: Over my dead body. I don't care what you have. Nobody pushes the Republic around! Least of all a rag tag band of vermin!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                
      //           createTimeout(() => {
      //             addDialogue("Corsair: I plan on it being over your dead body. But, if you surrender now, the rest of your crew will get to live! If you flee, I will just have to kill all of you. And to the crew of the ship I see before me, I offer boundless riches to the individual brave enough to bring me the head of the pig I am speaking with.", pirateColor, 12);
                  
      //             createTimeout(() => {
      //               addDialogue("Captain: Your cynicism appalls me! I have five hundred officers and ratings willing to die for the republic! Your lies fall on deaf ears, scum!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                    
      //               createTimeout(() => {
      //                 addDialogue("Captain: Shut off that transmission. Helm, warm up the engines and get us away from that battlecruiser. General quarters, all hands man your battlestations!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                      
      //                 createTimeout(() => {
      //                   addDialogue("Captain: Sensors, I'm networking you into the fire control computer. Help gunnery control shoot down any incoming missiles.", captainColor, defaultDialogueTime, captainPortraitFilePath);
                        
      //                   createTimeout(() => {
      //                     addDialogue("Engineer: Affirmative captain.", engineerColor);
                          
      //                     // Enable firing capabilities for player
      //                     allowedToFire = true;
      //                     allowedToFireAtSpot = true;
                          
      //                     // Prepare for first attack
      //                     response5 = true;
      //                   }, 3000);
      //                 }, 8000);
      //               }, 8000);
      //             }, 12000);
      //           }, 8000);
      //         }, 2500);
      //       }, 8000);
      //     }, 8000);
      //   }, 8000);
      // }

      // // First missile attack - Four missiles fired in sequence
      // if (response5 && !response6 && !response6a) {
      //   response6a = true;
      //   createTimeout(() => {
      //     const pirateShip = contacts[1]; // The hostile battlecruiser
          
      //     addDialogue("Engineer: Captain! I'm detecting missile launches from the enemy vessel!", engineerColor);
          
      //     // Launch first missile
      //     pirateShip.launchMissileAtContact(contacts[0], enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed, false);
          
      //     // Launch second missile after a delay
      //     createTimeout(() => {
      //       pirateShip.launchMissileAtContact(contacts[0], enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed, false);
            
      //       // Launch third missile after a delay
      //       createTimeout(() => {
      //         pirateShip.launchMissileAtContact(contacts[0], enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed, false);
              
      //         // Launch fourth missile after a delay
      //         createTimeout(() => {
      //           pirateShip.launchMissileAtContact(contacts[0], enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed, false);
                
      //           // Set a check to see when all missiles are destroyed
      //           const checkMissiles = createInterval(() => {
      //             const activeMissiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE").length;
                  
      //             if (activeMissiles === 0) {
      //               uncreateInterval(checkMissiles);
      //               response6 = true;
      //             }
      //           }, 1000);
                
      //         }, 2000);
      //       }, 2000);
      //     }, 2000);
      //   }, 10000);
      // }

      // // Comment after first wave of missiles is destroyed
      // if (response6 && !response7 && !response7a) {
      //   response7a = true;
      //   createTimeout(() => {
      //     addDialogue("Captain: That was too easy. They're only probing us. I don't like it. Be on the lookout for tricks.", captainColor, defaultDialogueTime, captainPortraitFilePath);
          
      //     // Prepare for second attack with zig-zag missiles
      //     createTimeout(() => {
      //       const pirateShip = contacts[1]; // The hostile battlecruiser

      //       addDialogue("Engineer: More missile launches detected!", engineerColor);

      //       // Launch two zig-zag missiles
      //       const playerBearing = Math.atan2(
      //         -Math.sin(pirateShip.realBearing) * pirateShip.realDistance,
      //         -Math.cos(pirateShip.realBearing) * pirateShip.realDistance
      //       );

      //       // Create off-angled missiles that will change course
      //       pirateShip.launchMissileAlongAngle(playerBearing + Math.PI/6, enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed);

      //       createTimeout(() => {
      //         pirateShip.launchMissileAlongAngle(playerBearing - Math.PI/6, enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed);

      //         // Get reference to the missiles we just launched
      //         const missiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE");

      //         if (missiles.length >= 2) {
      //           // Store the time each missile was created to identify them reliably
      //           const missile1Id = Date.now();
      //           const missile2Id = Date.now() + 1;

      //           // Add zigzag properties to the missiles
      //           missiles[missiles.length-1].zigzagState = true;  // Last created missile
      //           missiles[missiles.length-1].missileId = missile2Id;
      //           missiles[missiles.length-2].zigzagState = false; // Second-to-last created missile
      //           missiles[missiles.length-2].missileId = missile1Id;

      //           // Setup course changes for both missiles
      //           const zigzagInterval = createInterval(() => {
      //             const activeMissiles = contacts.filter(c => 
      //               c.isMissile && 
      //               c.contactType === "HOSTILE" && 
      //               (c.missileId === missile1Id || c.missileId === missile2Id)
      //             );
                
      //             if (activeMissiles.length === 0) {
      //               uncreateInterval(zigzagInterval);
      //               response7 = true;
      //               return;
      //             }
                
      //             // Make each active missile change direction in zigzag pattern
      //             for (let missile of activeMissiles) {
      //               // Check distance to player
      //               const distToPlayer = Math.sqrt(
      //                 Math.pow(Math.cos(missile.realBearing) * missile.realDistance, 2) + 
      //                 Math.pow(Math.sin(missile.realBearing) * missile.realDistance, 2)
      //               );
                  
      //               if (distToPlayer < radius * 0.25) {
      //                 // Close to player, home in
      //                 missile.targetContact = contacts[0];
      //                 missile.hasTarget = true;
      //               } else {
      //                 // Apply zig or zag based on current state
      //                 if (missile.zigzagState) {
      //                   missile.movementDirection += Math.PI / 3;  // Zig right
      //                 } else {
      //                   missile.movementDirection -= Math.PI / 3;  // Zag left
      //                 }
                    
      //                 // Toggle the state for next time
      //                 missile.zigzagState = !missile.zigzagState;
                    
      //                 // After changing direction, make sure it's still generally heading toward player
      //                 const toPlayerBearing = Math.atan2(
      //                   -Math.sin(missile.realBearing) * missile.realDistance,
      //                   -Math.cos(missile.realBearing) * missile.realDistance
      //                 );
                    
      //                 // Limit how far the missile can turn away from player
      //                 const angleDiff = normalizeAngle(missile.movementDirection - toPlayerBearing);
      //                 if (Math.abs(angleDiff) > Math.PI/2) {
      //                   // If missile is heading more than 90° away from player, correct course
      //                   missile.movementDirection = toPlayerBearing + (angleDiff > 0 ? Math.PI/3 : -Math.PI/3);
      //                 }
      //               }
      //             }
      //           }, 800); // Change course every 800 milliseconds
      //         }
      //       }, 2000);
      //     }, 8000);
      //   }, 3000);
      // }

      // // Comment after zigzag missiles are destroyed
      // if (response7 && !response8 && !response8a) {
      //   response8a = true;
      //   createTimeout(() => {
      //     addDialogue("Captain: Damn that pirate! How are they able to update their targeting solution so quickly?", captainColor, defaultDialogueTime, captainPortraitFilePath);
          
      //     createTimeout(() => {
      //       addDialogue("Engineer: Sir, that ship seems like it's sporting a lot of state of the art equipment. Their sensors and targeting systems are way out of the league of what a pirate ship should have.", engineerColor);

      //       createTimeout(() => {
      //         addDialogue("Captain: How would rabble like that get their hands on such advanced technology?", captainColor, defaultDialogueTime, captainPortraitFilePath);

      //         // Prepare for third attack - combination of direct and zigzag missiles
      //         createTimeout(() => {
      //           const pirateShip = contacts[1]; // The hostile battlecruiser

      //           addDialogue("Engineer: Massive missile launch detected! They're firing a lot!", engineerColor);

      //           // Launch four direct missiles
      //           for (let i = 0; i < 4; i++) {
      //             createTimeout(() => {
      //               pirateShip.launchMissileAtContact(contacts[0], enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed, false);
      //             }, i * 1500);
      //           }

      //           // Launch four zigzag missiles
      //           createTimeout(() => {
      //             const playerBearing = Math.atan2(
      //               -Math.sin(pirateShip.realBearing) * pirateShip.realDistance,
      //               -Math.cos(pirateShip.realBearing) * pirateShip.realDistance
      //             );
                    
      //             // Create four zigzag missiles at different angles
      //             const angles = [-Math.PI/4, -Math.PI/8, Math.PI/8, Math.PI/4];
                    
      //             for (let i = 0; i < 4; i++) {
      //               createTimeout(() => {
      //                 // Create unique ID for this missile to track it
      //                 const missileId = Date.now() + i;

      //                 // Launch missile
      //                 pirateShip.launchMissileAlongAngle(playerBearing + angles[i], enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed);

      //                 // Set up zigzag behavior
      //                 createTimeout(() => {
      //                   const missiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE");
      //                   if (missiles.length > 0) {
      //                     const missile = missiles[missiles.length - 1];

      //                     // Add zigzag properties directly to the missile
      //                     missile.zigzagState = true;
      //                     missile.missileId = missileId;
      //                     missile.zigzagAngle = angles[i];

      //                     const zigzagInterval = createInterval(() => {
      //                       if (!missile || missile.destroyed) {
      //                         uncreateInterval(zigzagInterval);
      //                         return;
      //                       }

      //                       // Check distance to player
      //                       const distToPlayer = Math.sqrt(
      //                         Math.pow(Math.cos(missile.realBearing) * missile.realDistance, 2) + 
      //                         Math.pow(Math.sin(missile.realBearing) * missile.realDistance, 2)
      //                       );

      //                       if (distToPlayer < radius * 0.25) {
      //                         // Close to player, home in
      //                         missile.targetContact = contacts[0];
      //                         missile.hasTarget = true;
      //                         uncreateInterval(zigzagInterval);
      //                       } else {
      //                         // Calculate direction toward player
      //                         const toPlayerBearing = Math.atan2(
      //                           -Math.sin(missile.realBearing) * missile.realDistance,
      //                           -Math.cos(missile.realBearing) * missile.realDistance
      //                         );
                                
      //                         // Update movement direction based on zigzag state
      //                         if (missile.zigzagState) {
      //                           // Zig - adjust direction to one side
      //                           missile.movementDirection = toPlayerBearing + Math.abs(missile.zigzagAngle);
      //                         } else {
      //                           // Zag - adjust direction to other side
      //                           missile.movementDirection = toPlayerBearing - Math.abs(missile.zigzagAngle);
      //                         }

      //                         // Toggle state for next time
      //                         missile.zigzagState = !missile.zigzagState;
      //                       }
      //                     }, 800);
      //                   }
      //                 }, 500);
      //               }, i * 2000);
      //             }
    
      //             // Set a check to see when all missiles are destroyed
      //             const checkAllMissiles = createInterval(() => {
      //               const activeMissiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE").length;
    
      //               if (activeMissiles === 0) {
      //                 uncreateInterval(checkAllMissiles);
      //                 response8 = true;
      //               }
      //             }, 1000);
      //           }, 8000);
      //         }, 10000);
      //       }, 6000);
      //     }, 6000);
      //   }, 6000);
      // }

      // // After third wave is destroyed
      // if (response8 && !response9 && !response9a) {
      //   response9a = true;
      //   createTimeout(() => {
      //     addDialogue("Captain: Helm, what's the status of our engines?", captainColor, defaultDialogueTime, captainPortraitFilePath);
          
      //     createTimeout(() => {
      //       addDialogue("Helmsman: We're almost ready to give it full power sir.", helmsmanColor);
            
      //       createTimeout(() => {
      //         addDialogue("Captain: Almost isn't good enough. We can't afford to let that battlecruiser get any closer.", captainColor, defaultDialogueTime, captainPortraitFilePath);
              
      //         createTimeout(() => {
      //           addDialogue("Helmsman: Yes sir, we're working on it.", helmsmanColor);
                
      //           // Final attack - spread of missiles that all home in after delay
      //           createTimeout(() => {
      //             const pirateShip = contacts[1];
                  
      //             addDialogue("Engineer: Captain! They're launching a massive spread!", engineerColor);

      //             // Give the players a hint of what's coming
      //             createTimeout(() => {
      //               addDialogue("Captain: Most of those are going to miss. Why would they fire unless... They're going to arc them back! Get ready!", captainColor, defaultDialogueTime, captainPortraitFilePath);
      //             }, 2000);
                  
      //             // Launch 8 missiles in a wide spread
      //             const playerBearing = Math.atan2(
      //               -Math.sin(pirateShip.realBearing) * pirateShip.realDistance,
      //               -Math.cos(pirateShip.realBearing) * pirateShip.realDistance
      //             );
                  
      //             const spreadWidth = Math.PI / 2; // 90 degree spread
      //             const numMissiles = 8;
                  
      //             for (let i = 0; i < numMissiles; i++) {
      //               const angle = playerBearing - spreadWidth/2 + i * (spreadWidth / (numMissiles - 1));
                    
      //               createTimeout(() => {
      //                 pirateShip.launchMissileAlongAngle(angle, enemyMissileFuelTime, enemyMissileArmingTime, enemyMissileSpeed);
      //               }, i * 500);
      //             }
                  
      //             // After 10 seconds, make all missiles home in on player
      //             createTimeout(() => {
      //               const missiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE");
                    
      //               for (let missile of missiles) {
      //                 missile.targetContact = contacts[0];
      //                 missile.hasTarget = true;
      //               }
                    
      //               // Set a check to see when all missiles are destroyed
      //               const checkFinalMissiles = createInterval(() => {
      //                 const activeMissiles = contacts.filter(c => c.isMissile && c.contactType === "HOSTILE").length;
                      
      //                 if (activeMissiles === 0) {
      //                   uncreateInterval(checkFinalMissiles);
      //                   response9 = true;
      //                 }
      //               }, 1000);
      //             }, 10000);
      //           }, 8000);
      //         }, 3000);
      //       }, 3000);
      //     }, 3000);
      //   }, 3000);
      // }

      // // Final victory sequence
      // if (response9 && !response10 && !response10a) {
      //   response10a = true;
      //   createTimeout(() => {
      //     addDialogue("Helmsman: Captain, we're ready to go to full power!", helmsmanColor);
          
      //     createTimeout(() => {
      //       addDialogue("Captain: Good. Get us out of here!", captainColor, defaultDialogueTime, captainPortraitFilePath);
            
      //       createTimeout(() => {
      //         addDialogue("Helmsman: Yes sir!", helmsmanColor);
              
      //         // Trigger victory after a short delay
      //         createTimeout(() => {
      //           gameOver = true;
      //           $playerWonO2 = true;
      //           gameOverMessage = "VICTORY!";
      //           gameOverColor = "green";
      //           // Play victory sound
      //           const audio = new Audio("../assets/victory.mp3");
      //           audio.play();
      //         }, 2000);
      //       }, 2000);
      //     }, 2000);
      //   }, 3000);
      // }

      // Old operation 2 custom dialogue and triggers - shows how to script gameworld and dialogue updates

      // Current operation 3 plan: Initially spawn in const numAsteroids = 36 asteroid contacts, with 100% radar detection range, and 0% ELINT detection chance. As will all real contacts,
      // make the asteroids thermally detectable. Also make the asteroids totally stationary.

      // After a specific dialogue section runs, at 90 and 270 degrees, spawn in two hostile ships with high ELINT detection chance, and 0% radar detection chance. These ships will be the ones that fire missiles at the player.
      // Have them randomly move around, but clamp them to be between 0.75 and 0.25 radii from the center. 

      // Every time there are no hostile missiles present, have both the enemies randomly select an attack type from one of the following :  

      // one missile launched directly at the player, 
      // two missiles launched directly at the player, 
      // two zig-zag missiles launched directly at the player,
      // or three missiles which head -45 degrees from the player, directly at the player, and +45 degrees from the player. After 2 seconds have all three missiles home in on the player.

      // Limit both ships to 50 missiles in stock, for a total of 100 missiles fireable at the player.

      // Once both ships run out of ammo, have them both retreat directly away from the player, and delete them once they reach 0.95 radii from the center.
      // Alternatively, the player can win by destroying both ships, but this is already handled by the game engine.

      // Dialogue plan: 

      // 1. Captain: "There's no way that battlecruiser can follow us into this field. Worst case scenario, we only have to deal with a few asteroids."

      // 2. Captain: "What a mess. Pirates shouldn't have access to that kind of hardware. It doesn't make sense."

      // 3. Captain: "And those missiles... How did they have enough range to hit us while we couldn't strike back...?"

      // Spawn in the two enemies at this point, but don't let them fire just yet.

      // 4. Engineer: "Captain, I'm detecting major and consistent emissions from 90 and 270 degrees!"

      // 5. Captain: "What? Sensors, what are you seeing on the radar?"

      // 6. Engineer: "Nothing sir, just a lot of asteroids. But the emissions are definitely coming from 90 and 270 degrees."

      // 7. Captain: "We need to assume those pirates have dispatched a few ships to hunt us. I'm authorizing you to fire at will, but be careful. We can't afford to waste missiles on asteroids."

      // Enemy ships will now be able to fire at the player, and the player can fire back.

      // Once the player sees more zig-zag missiles, have the engineer say "Captain, I'm picking up a similar zig-zag pattern to the one we saw before.". Captain will respond "Again with the zig-zag missiles? Wait for them to home in, then knock them out." 

      // Once the player sees the three-pronged +45, 0, -45 degree missiles, have the captain say "Looks like they're firing a three pronged spread! Watch out for the ones on the sides, they might arc back!"

      // Once the player destroys one of the ships, have the engineer say "Telemetry indicates target destroyed!" and the captain say "Good work. Now let's finish off the other one."

      // If the pirates have run out of missiles, have the captain say "That makes one hundred missiles fired. Seems like they're out of ammo."

      // Initial dialogue
      if (!response1 && !response1a) {
        response1a = true;
        addDialogue("Captain: There's no way that battlecruiser can follow us into this field. Worst case scenario, we only have to deal with a few asteroids.", captainColor, defaultDialogueTime, captainPortraitFilePath);
        // Create the asteroids
        createAsteroids(6);
        
        createTimeout(() => {
          response1 = true;
        }, 5000);
      }

      if (response1 && !response2 && !response2a) {
        response2a = true;
        createTimeout(() => {
          addDialogue("Captain: What a mess. Pirates shouldn't have access to that kind of hardware. It doesn't make sense.", captainColor, defaultDialogueTime, captainPortraitFilePath);
          response2 = true;
        }, 5000);
      }

      if (response2 && !response3 && !response3a) {
        response3a = true;
        createTimeout(() => {
          addDialogue("Captain: And those missiles... How did they have enough range to hit us while we couldn't strike back...?", captainColor, defaultDialogueTime, captainPortraitFilePath);
          
          // Spawn the enemy ships but don't let them fire yet
          createTimeout(() => {
            spawnEnemyShips();
            // Since there are now hostiles, we can enable the victory checking code without worrying about an instant win
            checkForVictory = true;
            response3 = true;
          }, 4000);
        }, 6000);
      }

      if (response3 && !response4 && !response4a) {
        response4a = true;
        createTimeout(() => {
          addDialogue("Engineer: Captain, I'm detecting major and consistent emissions from 90 and 270 degrees!", engineerColor);
          response4 = true;
        }, 4000);
      }

      if (response4 && !response5 && !response5a) {
        response5a = true;
        createTimeout(() => {
          addDialogue("Captain: What? Sensors, what are you seeing on the radar?", captainColor, defaultDialogueTime, captainPortraitFilePath);
          response5 = true;
        }, 4000);
      }

      if (response5 && !response6 && !response6a) {
        response6a = true;
        createTimeout(() => {
          addDialogue("Engineer: Nothing sir, just a lot of asteroids. But the emissions are definitely coming from 90 and 270 degrees.", engineerColor);
          response6 = true;
        }, 6000);
      }

      if (response6 && !response7 && !response7a) {
        response7a = true;
        createTimeout(() => {
          addDialogue("Captain: We need to assume those pirates have dispatched a few ships to hunt us. I'm authorizing you to fire at will, but be careful. We can't afford to waste missiles on asteroids.", captainColor, 12, captainPortraitFilePath);
          
          // Enable firing and activate enemy ships
          allowedToFire = true;
          allowedToFireAtSpot = true;
          activateEnemyShips();
          
          response7 = true;
        }, 6000);
      }
      
      // Cap deltaTime to prevent huge jumps if tab was inactive
      const cappedDeltaTime = Math.min(deltaTime, 0.5);
      
      drawBackground(cappedDeltaTime);
      
      // Calculate thermal scan absolute angle
      const thermalScanAbsoluteAngle = thermalScanAngle + thermalScanCenter;

      // Sort contacts into friendly and hostile arrays
      // Do not include missiles in these arrays
      const friendlyContacts = contacts.filter(contact => contact.contactType === "FRIENDLY" || contact.contactType === "PLAYER" && !contact.isMissile);
      const hostileContacts = contacts.filter(contact => contact.contactType === "HOSTILE" && !contact.isMissile);
      
      // Update and draw contacts
      for (let contact of contacts) {
        contact.updatePosition(cappedDeltaTime);
        contact.checkDetection(angle, thermalScanAbsoluteAngle, thermalScanRadius, cappedDeltaTime);
        contact.draw(cappedDeltaTime);
      }
      
      // Draw the radar line and thermal scan
      drawRadarLine();
      drawThermalScan();
      // Draw the text telling the player in the top left how many missiles are left
      drawCurrentMissiles();
      // Draw the dialogue messages in the top right corner
      drawDialogue();
      
      // Update and draw contact reports
      for (let i = contactReports.length - 1; i >= 0; i--) {
        if (!contactReports[i].update(cappedDeltaTime)) {
          contactReports.splice(i, 1);
        } else {
          contactReports[i].draw();
        }
      }
      
      // Update the radar scan angle (rotate by specified degrees per second)
      angle += (Math.PI * radarSpeed / 180) * cappedDeltaTime;
      if (angle >= Math.PI * 2) angle = 0;

      // Update the thermal scan angle
      if (thermalScanReversed) {
        thermalScanAngle -= (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle <= -thermalScanWidth/2) {
          thermalScanAngle = -thermalScanWidth/2;
          thermalScanReversed = false;
        }
      } else {
        thermalScanAngle += (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle >= thermalScanWidth/2) {
          thermalScanAngle = thermalScanWidth/2;
          thermalScanReversed = true;
        }
      }
      
      requestAnimationFrame(animate);
    }

    // Track mouse position
    let mouseX, mouseY;
    canvas.addEventListener('mousemove', function(event) {
      const rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    });

    // Add click event listener for contact reports
    canvas.addEventListener('click', function(event) {
      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $operation3Allowed === "undefined" || $operation3Allowed === null || !$operation3Allowed) {
        // Cancel the event if the operation is not allowed to be running
        return;
      }

      // If paused, do nothing
      if (gamePaused) return;

      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
    
      // Check if click is on a contact report
      let wasOnContactReport = false;
      for (let i = 0; i < contactReports.length; i++) {
        // Launch a missile if the click is on a contact report and the player ship still has missiles
        // PLayer ship should be the first contact in the contacts array
        if (contactReports[i].contains(mouseX, mouseY) && contacts[0].numMissiles > 0) {
          console.log(`Radar contact at ${contactReports[i].timestamp} reported`);

          wasOnContactReport = true;

          // If this isn't the first contact report clicked and the associated contact is a missile, add a dialogue message for that
          if (contactReports[i].contact.isMissile && !isFirstContact && isFirstMissile) {
            addDialogue(`Engineer: Fast movers! Countermissile out!`, engineerColor);
            // Wait for 3 seconds, then have the captain respond
            createTimeout(() => {
              addDialogue(`Captain: Good job with the rapid countermissile fire!`, captainColor, 12);
            }, 2000);
            isFirstMissile = false;
          }
      
          // If not allowed to fire, do nothing
          if (allowedToFire) {
            // Fire at the contact report's associated contact
            // contacts[0] is the player ship, so we will use it to launch the missile
            // launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed)
            contacts[0].launchMissileAtContact(contactReports[i].contact, 30, 0.9, 10, false);
          }

          // Remove the report after clicking
          contactReports.splice(i, 1);
          break;
        }
      }
      // If not on a contact report, check if click is on the radar screen
      if (!wasOnContactReport) {
        // Figure out the fire coordinates based on the mouse position
        const dx = mouseX - centerX;
        const dy = mouseY - centerY;

        if (!allowedToFireAtSpot || !allowedToFire) return; // Don't fire if not allowed
        

        // Try to fire at the given coordinates
        // contacts[0] is the player ship, so we will use it to launch the missile
        // launchMissileAtPoint(targetX, targetY, missileFuelTime, missileArmingTime, missileMovementSpeed)
        contacts[0].launchMissileAtPoint(dx, dy, 30, 0.9, 10);
      }
    });

    // Key event listeners for thermal scan control
    document.addEventListener('keydown', function(event) {
      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $operation3Allowed === "undefined" || $operation3Allowed === null || !$operation3Allowed) {
        // Cancel the event if the operation is not allowed to be running
        return;
      }
      if (event.key === 'a' || event.key === 'A') {
        // Rotate thermal scan left
        // If paused, do nothing
        if (!gamePaused) {
          thermalScanCenter -= 0.1;
          if (thermalScanCenter < 0) thermalScanCenter += Math.PI * 2;
        }
      } else if (event.key === 'd' || event.key === 'D') {
        // Rotate thermal scan right
        // If paused, do nothing
        if (!gamePaused) {
          thermalScanCenter += 0.1;
          if (thermalScanCenter >= Math.PI * 2) thermalScanCenter -= Math.PI * 2;
        }
      } else if (event.key === 'x' || event.key === 'X') {
        // Check if the mouse is over a contact report
        // If paused, do nothing
        if (!gamePaused) {
          for (let i = 0; i < contactReports.length; i++) {
            if (contactReports[i].contains(mouseX, mouseY)) {
              // Dismiss the contact report
              console.log(`Contact report at ${contactReports[i].timestamp} dismissed`);
              contactReports.splice(i, 1);
              break;
            }
          }
        }
      } else if (event.key === 'q' || event.key === 'q') {
        // If not allowed to fire, do nothing
        if (!allowedToFire) return;

        // Check if the mouse is over a contact report
        // If paused, do nothing
        if (!gamePaused) {
          for (let i = 0; i < contactReports.length; i++) {
            if (contactReports[i].contains(mouseX, mouseY)) {
              // Fire a spread at the contact in the contact report
              
              // Fire at the contact report's associated contact
              // contacts[0] is the player ship, so we will use it to launch the missile
              // launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed, isSpreadAttack)
              contacts[0].launchMissileAtContact(contactReports[i].contact, 30, 0.9, 10, true);

              console.log(`Spread fired at Contact report at ${contactReports[i].timestamp}`);
              contactReports.splice(i, 1);
              break;
            }
          }
        }
      } else if (event.key === 'p' || event.key === 'P') {
        // Toggle pause state if not in game over state
        if (!gameOver) {
          // If viewing message history, just exit that view but remain paused
          if (isViewingMessageHistory) {
            isViewingMessageHistory = false;
            drawPauseMenu();
          } else {
            gamePaused = !gamePaused;
            if (gamePaused) {
              console.log("Game paused");
              // Draw it here to ensure it's only drawn once when paused
              drawPauseMenu();
            } else {
              console.log("Game unpaused");
            }
          }
        }
      } else if (event.key === 'h' || event.key === 'H') {
        // Toggle message history view
        if (isViewingMessageHistory) {
          // Exit message history view but stay paused
          isViewingMessageHistory = false;
          drawPauseMenu();
        } else {
          // If game is not already paused, pause it
          if (!gamePaused) {
            gamePaused = true;
          }
          // Switch to message history view
          isViewingMessageHistory = true;
          // Reset scroll position when first opening
          messageHistoryScrollPosition = 0;
        }
      } else if (event.key === 'ArrowUp') {
        // Scroll message history up
        if (isViewingMessageHistory) {
          messageHistoryScrollPosition = Math.max(0, messageHistoryScrollPosition - 40);
        }
      } else if (event.key === 'ArrowDown') {
        // Scroll message history down
        if (isViewingMessageHistory) {
          messageHistoryScrollPosition += 40;
          // Upper limit will be checked in draw function
        }
      }
    });

    // Create contacts array with initial contacts
    // Parameters: bearing, distance, size, 
    //             movementSpeed, directionChangeFrequency, movementDirection, 
    //             visible, opacity, emittingRadiation, emissionDetectionChance,
    //             radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
    //             iffBroadcasting, iffString, contactColor, contactType,
    //             numMissilesLoaded
    const contacts = [
      // The player's ship. Always visible and at the center of the radar
      // Has 100 missiles loaded
      new Contact(0, 0, 5, 
                  0, 0, 0, 
                  true, 1, true, 0, 
                  true, 0, true, 0,
                  true, "PLAYER SHIP, Heavy Cruiser\nCRS Bounty\nCairn Class", [255, 255, 255],
                  "PLAYER", 100),
      // ELINT Ghosts (No thermal, no radar detection)
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      // Radar ghosts (No ELINT, No thermal detection)
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
    ];

    // Fill the canvas with black initially
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, width, height);
    
    // Start the animation with the timestamp
    lastFrameTime = performance.now();

    requestAnimationFrame(animate);
  })();
</script>

[[See Operation Results->Operation Result 3]]
[[Back->Operation 2]]

(set: $operation1Allowed to false)
(set: $operation2Allowed to false)
(set: $operation4Allowed to false)
(set: $operation5Allowed to false)
(set: $tutorialOperationAllowed to false)
(set: $operationDebugAllowed to false)

:: Operation Result 3 {"position":"1600,400","size":"100,100"}

[[Click to go Back->Operation 3]]
(if: $playerWonO3 is true)[[[Victory! Click to continue->Operation 4]]]

:: Operation 4 {"position":"1800,200","size":"100,100"}

[[See Operation Results->Operation Result 4]]
[[Back->Operation 3]]

(set: $operation1Allowed to false)
(set: $operation2Allowed to false)
(set: $operation3Allowed to false)
(set: $operation5Allowed to false)
(set: $tutorialOperationAllowed to false)
(set: $operationDebugAllowed to false)

:: Operation Result 4 {"position":"1800,400","size":"100,100"}

[[Click to go Back->Operation 4]]
(if: $playerWonO4 is true)[[[Victory! Click to continue->Operation 5]]]


(set: $operation1Allowed to false)
(set: $operation2Allowed to false)
(set: $operation3Allowed to false)
(set: $operation4Allowed to false)
(set: $operation5Allowed to false)
(set: $tutorialOperationAllowed to false)
(set: $operationDebugAllowed to false)

:: Operation 5 {"position":"2000,200","size":"100,100"}

[[See Operation Results->Operation Result 5]]
[[Back->Operation 4]]


(set: $operation1Allowed to false)
(set: $operation2Allowed to false)
(set: $operation3Allowed to false)
(set: $operation4Allowed to false)
(set: $tutorialOperationAllowed to false)
(set: $operationDebugAllowed to false)

:: Operation Result 5 {"position":"2000,400","size":"100,100"}


(set: $operation1Allowed to false)
(set: $operation2Allowed to false)
(set: $operation3Allowed to false)
(set: $operation4Allowed to false)
(set: $operation5Allowed to false)
(set: $tutorialOperationAllowed to false)
(set: $operationDebugAllowed to false)

[[Click to go Back->Operation 5]]


:: Debug Operation {"position":"1000,600","size":"100,100"}
Debug Operation.

TRIVIA:
LS: Light Second = 299,792,458 Meters

TIPS:
Left clicking on a contact report will fire a missile at it. 

Left clicking elsewhere on the screen will fire a missile at the clicked location.

Mousing over a contact report and pressing "X" will dismiss it. 

Mousing over a friendly contact will display miscellaneous information about it, such as the name of a friendly ship, or the remaining fuel time of a friendly missile.

Radar and radiation detectors can be faulty, displaying false detections occasionally and randomly. Real contacts will be far more consisently located in one place.

Missiles, both friendly and hostile, give off an immense amount of electromagnetic radiation, making them show up near continuously on the radiation detectors.

Radar can be fooled by stealthy contacts, but thermal sensors never lie. 

In combat, missiles can be flying at your ship so fast that you might not detect them on the radar until they are right on top of you. 
Orient the thermal scanner to the direction of the enemy ship to get the most live data on any incoming missiles.

Incoming missiles can be shot down by other missiles.

Missiles are equipped with very short range thermal scanners that let them see what's in front of them. 

Missiles do not care if you're friendly or hostile or neutral. If they see something, they will home in on it until they run out of fuel or until they strike true.

That means your own missiles, if somehow redirected towards yourself or a friendly ship, will blow you up.

Conserve your missiles. Once you're out, you have no way of defending yourself from incoming fire.

Fire missiles in a spread of all possible positions you think they enemy could be in so they can't get away in time regardless of how they dodge.

When firing a spread, make sure to also spread the missiles out in time so they don't get launched so quickly that they lock onto each other and either blow themselves up or alter course and mess up the spread.

Controls:
Thermal Scan - Use A/D to rotate
Contact Report - Left click to fire at, X to Dismiss, Q to fire a spread at
Pause - P to toggle pause
Message history - H to pause and view message history
<script>
  // Stops the previous audio
  if (typeof audio !== 'undefined') {
    audio.pause();
    delete audio;
  }
</script>

<!-- Removal of padding allows for much more game room on small monitors -->
<style>
  tw-story {
    padding: 0% 0%;
    padding-top: 0%;
    padding-right: 0%;
    padding-bottom: 0%;
    padding-left: 0%;
  }
  
  @media (min-width: 576px) {
    tw-story {
      padding: 0% 0%;
      padding-top: 0%;
      padding-right: 0%;
      padding-bottom: 0%;
      padding-left: 0%;
    }
  }
  </style>
  

<!-- Debug Operation -->
<canvas id="debugOperation" width="1350" height="720"></canvas>
<script>
  $operationDebugAllowed = true; // Set to true to allow the operation to run
  $playerWon = false;
  (function() {
    const canvas = document.getElementById("debugOperation");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 3;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 2 - 10;

    // Array of elint beep audios. Rather than create and play a new beep each time there is a detection,
    // we will instead reuse numBeeps number of beeps. This is to prevent the audio from overlapping and
    // creating a cacophony of beeps that can overload the number of audio channels available in the browser.
    const numBeeps = 20;
    const elintBeeps = Array.from({ length: numBeeps }, () => new Audio("../assets/ELINTBeep.mp3"));
    
    // Track the start time
    const startTime = Date.now();
    let lastFrameTime = performance.now();
    // Track the unpaused elapsed time
    let unpausedElapsedTimeMillis = 0;
    // Time multiplier
    // 1 = normal speed
    // 2 = double speed
    // 0.5 = half speed
    const deltaTimeMultiplier = 2.4;
    // Detection chance time multiplier
    // Intended to address the fact that PC performance can affect detection chances
    const detectionTimeMultiplier = 1;

    // Game state variables
    let gameOver = false;
    let gamePaused = true;
    let gameOverMessage = "";
    let gameOverColor = "";

    // If the game is paused, go ahead and draw the pause screen
    if (gamePaused) {
      requestAnimationFrame(drawPauseMenu);
    }

    // Customizable parameters - now in units per second instead of per frame
    const radarSpeed = 30; // degrees per second
    const fadeRate = 6;   // fade opacity per second
    const ELINTHalfAngle = Math.PI/36; // 5 degrees in radians
    
    // Radar line angle
    let angle = 0;
    // Thermal scan angle
    let thermalScanAngle = 0;
    
    // Thermal scan parameters
    const thermalScanWidth = Math.PI/6; // 30 degrees in radians
    const thermalScanRadius = radius * 0.25; // 0.25ls circle
    const thermalScanSpeed = 30; // degrees per second
    let thermalScanCenter = 0; // Center of thermal scan area
    let thermalScanReversed = false; // Direction of thermal scan rotation

    // Missile thermal scan parameters
    const missileScanWidth = Math.PI/6; // 30 degrees in radians
    const missileScanRadius = radius * 0.05; // 0.05ls circle
    const missileScanSpeed = 60; // degrees per second

    // Random missile launch parameters
    const baseMissileLaunchChance = 0.0001;
    let missileLaunchChance = baseMissileLaunchChance;
    let missileLaunchIncrease = 0.00001;
    // Missile attack type parameters
    const chanceOfSpreadAttack = 0.5;
    const spreadAttackMissilePerRadiusAmount = 0.05; // Add 1 more missile for every radius amount of distance to target
    let allowedToFireAtSpot = false; // If true, the player can fire at any point on the screen, not just contacts. If false, they can't.
    let allowedToFire = true; // If true, the player can cause a missile to be launched. If false, all controls related to firing are disabled. 

    // Contact report parameters
    const contactReports = [];
    const reportLifetime = 10; // lifetime in seconds

    // IFF Parameters
    const iffBoxDisplayDistance = 100; // How far away the mouse can be before the IFF box stops displaying
    const acceptedTypes = ["FRIENDLY", "HOSTILE", "NEUTRAL", "GHOST", "PLAYER"]; // Accepted contact types

    // Dialogue message parameters
    const dialogueMessages = []; // Array to store dialogue messages with text, color, and time they should disappear
    const defaultDialogueTime = 5; // Default time for dialogue messages to disappear
    // Dialogue flags
    let isFirstContact = true;
    let isFirstMissile = true;
    let madeFirstKill = false;
    let madeSecondKill = false;
    let friendlyTookAShot = false;
    let madeFirstClick = false;
    let firedFirstSpread = false;
    let firedSpreadAtMissile = false;
    let firedSpreadAtInvalidTarget = false;
    // Dialogue message colors for certain characters
    const engineerColor = "#00FF00";
    const captainColor = "#34eb7a";
    const friendlyColor = "#FF00FF"
    // Dialogue portrait paths
    const captainPortraitFilePath = "../assets/characters/CaptainPortrait.png";
  
    // Function to create explosion effect
    function createExplosion(x, y) {
      // Play explosion sound (Unused for now)
      // const explosionSound = new Audio("../assets/MissileHit.mp3");
      // explosionSound.play();

      // Visual explosion effect (flash)
      ctx.beginPath();
      ctx.arc(x, y, 30, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255, 200, 50, 0.8)";
      ctx.fill();
    }

    // Function to check if all contacts of a specific type are gone
    function areAllContactsGone(type) {
      return !contacts.some(contact => contact.contactType === type && !contact.destroyed);
    }

    // Contact Report class
    class ContactReport {
      constructor(x, y, timestamp, contactType, contact) {
        this.x = x;
        this.y = y;
        this.timestamp = timestamp;
        this.contactType = contactType;
        this.contact = contact;
        this.timeCreated = Date.now();
        this.age = 0;
        this.maxAge = reportLifetime;
      }
      
      update(deltaTime) {
        // Increment age, but only if the contact is no longer visible or no longer exists
        if (!this.contact || !this.contact.visible || this.contact.destroyed || typeof this.contact === 'undefined') {
          this.age += deltaTime;
        }
        return this.age < this.maxAge;
      }
      
      draw() {
        // Calculate opacity based on age
        const opacity = 1 - (this.age / this.maxAge);
        
        // Determine position (ensure it's on screen)
        const boxWidth = 180;
        const boxHeight = 75; // Increased height to fit new line
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        // Draw connection line
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(boxX + (boxX > this.x ? 0 : boxWidth), boxY + boxHeight/2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw box
        ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.7})`;
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Draw text
        ctx.font = "10px monospace";
        ctx.fillStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.textAlign = "left";
        ctx.fillText(`DETECTED: ${this.timestamp}`, boxX + 5, boxY + 15);
        ctx.fillText(`POTENTIAL ${this.contactType} CONTACT`, boxX + 5, boxY + 30);
        ctx.fillText("CLICK TO REPORT CONTACT", boxX + 5, boxY + 45);
        ctx.fillText("X TO DISMISS, Q TO FIRE SPREAD", boxX + 5, boxY + 60);
      }
      
      contains(mouseX, mouseY) {
        // Determine box position
        const boxWidth = 180;
        const boxHeight = 75; // TODO: Make boxWidth and boxHeight not exist both here and in draw() separately in order to make it easier to change
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        return mouseX >= boxX && mouseX <= boxX + boxWidth && 
               mouseY >= boxY && mouseY <= boxY + boxHeight;
      }
    }

    // Contact class definition
    class Contact {
      constructor(bearing, distance, size, movementSpeed, directionChangeFrequency, movementDirection, 
                  visible, opacity, emittingRadiation, emissionDetectionChance, 
                  radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
                  iffBroadcasting, iffString, contactColor, contactType, numMissilesLoaded) {
        // Affects displayed position
        this.bearing = bearing;
        this.distance = distance;
        this.size = size;
        
        // Affects real position for sim (moves independently of the displayed blip)
        this.realBearing = bearing;
        this.realDistance = distance;
        
        // Movement parameters for sim (now per second rather than per frame)
        this.movementSpeed = movementSpeed;
        this.directionChangeFrequency = directionChangeFrequency;
        this.movementDirection = movementDirection;
        this.directionChangeCounter = 0;
        
        // Visibility properties for contact blip
        this.visible = visible;
        this.opacity = opacity;
        this.fadeSpeed = 0.6; // fade per second

        // ELINT detection properties
        this.emittingRadiation = emittingRadiation;
        this.emissionDetectionChance = emissionDetectionChance;
        this.radiationDetected = false;
        this.radiationDetectionDuration = 0;
        
        // Radar detection properties
        this.radarDetectable = radarDetectable;
        this.radarDetectionChance = radarDetectionChance;
        this.lastDetectedTime = null;

        // Thermal detection properties
        this.thermalDetectable = thermalDetectable;
        this.thermalDetectionChance = thermalDetectionChance;

        // IFF (Identification Friend or Foe) properties
        this.iffBroadcasting = iffBroadcasting;
        this.iffString = iffString;
        this.contactColor = contactColor;

        // How many missiles are aboard the ship
        this.numMissiles = numMissilesLoaded;

        // Currently, there are five types of contacts: "FRIENDLY", "HOSTILE", "NEUTRAL", "GHOST", and "PLAYER"
        // Anything else is treated as "GHOST"
        if (acceptedTypes.includes(contactType)) {
          this.contactType = contactType;
        } else {
          this.contactType = "GHOST";
        }
        // Ghosts must not be thermally detectable
        if (this.contactType === "GHOST") {
          this.thermalDetectable = false;
        }
      }
      
      updatePosition(deltaTime) {
        // Randomly change direction occasionally, now based on elapsed time
        this.directionChangeCounter += deltaTime;
        if (this.directionChangeCounter > (1 / this.directionChangeFrequency)) {
          this.movementDirection += (Math.random() - 0.5) * Math.PI / 2; // Change by up to +/-45 degrees
          this.directionChangeCounter = 0;
        }
        
        // Convert polar movement to cartesian
        let dx = Math.cos(this.movementDirection) * this.movementSpeed * deltaTime;
        let dy = Math.sin(this.movementDirection) * this.movementSpeed * deltaTime;
        
        // Convert contact position from polar to cartesian
        let contactX = Math.cos(this.realBearing) * this.realDistance;
        let contactY = Math.sin(this.realBearing) * this.realDistance;
        
        // Update position
        contactX += dx;
        contactY += dy;
        
        // Convert back to polar coordinates
        this.realDistance = Math.sqrt(contactX * contactX + contactY * contactY);
        this.realBearing = Math.atan2(contactY, contactX);
        
        // Keep contact within radar bounds
        if (this.realDistance > radius * 0.95) {
          // If near edge, bounce back, unless a missile, in which case it should self-destruct
          if (this.isMissile) {
            // Create explosion effect
            createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                           centerY + this.realDistance * Math.sin(this.realBearing));
            
            // Remove from contacts array
            const index = contacts.indexOf(this);
            if (index > -1) {
              contacts.splice(index, 1);
            }
            return;
          }
          this.movementDirection = Math.atan2(-contactY, -contactX);
          this.realDistance = radius * 0.95;
        } else if (this.realDistance < 0) {
          // If somehow at a negative distance, reset to 0
          this.realDistance = 0;
        }
        
        // Check for radiation detection
        this.checkRadiationDetection(deltaTime);
        
        // Decrease radiation detection duration
        if (this.radiationDetected) {
          this.radiationDetectionDuration -= deltaTime;
          if (this.radiationDetectionDuration <= 0) {
            this.radiationDetected = false;
          }
        }
      }
      
      checkRadiationDetection(deltaTime) {
        // Adjust chance based on time
        const timeAdjustedChance = this.emissionDetectionChance * deltaTime * detectionTimeMultiplier;
        
        if (this.emittingRadiation && Math.random() < timeAdjustedChance) {
          // Play a beep
          // Iterate through beeps to find one that is not currently playing
          for (let i = 0; i < numBeeps; i++) {
            if (elintBeeps[i].paused) {
              elintBeeps[i].play();
              break;
            }
          }

          this.radiationDetected = true;
          this.radiationDetectionDuration = 0.25; // Show for 0.25 second
        }
      }
      
      checkDetection(radarAngle, thermalScanAbsoluteAngle, thermalScanRadius, deltaTime) {
        // Check if radar is sweeping over the contact
        const angleDiff = Math.abs(normalizeAngle(radarAngle - this.realBearing));
        let wasNewDetection = false;
        
        // Adjust chances based on time
        // If something has a 100% chance of being detected, it should be detected
        const timeAdjustedRadarChance = this.radarDetectionChance >= 1 ? 1 : this.radarDetectionChance * deltaTime * detectionTimeMultiplier;
        //const timeAdjustedThermalChance = this.thermalDetectionChance * deltaTime * detectionTimeMultiplier;
        const timeAdjustedThermalChance = this.thermalDetectionChance > 0 ? 1 : 0; // If something is thermal detectable, it should be detected
        
        if (angleDiff < 0.1 && this.radarDetectable && Math.random() < timeAdjustedRadarChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            // Play a ping
            const audio = new Audio("../assets/RadarPing.mp3");
            audio.play();
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const minutes = Math.floor(unpausedElapsedTimeMillis / 60000);
            const seconds = Math.floor((unpausedElapsedTimeMillis % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "RADAR", this));
          }
        }
        
        // Check if thermal scan is over the contact
        const thermalDiff = Math.abs(normalizeAngle(thermalScanAbsoluteAngle - this.realBearing));
        
        if (thermalDiff < 0.1 && this.realDistance < thermalScanRadius && 
            this.thermalDetectable && Math.random() < timeAdjustedThermalChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const minutes = Math.floor(unpausedElapsedTimeMillis / 60000);
            const seconds = Math.floor((unpausedElapsedTimeMillis % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "THERMAL", this));
          }
        }
      }

      // Launch a missile along a given bearing
      launchMissileAlongAngle(targetBearing, missileFuelTime, missileArmingTime, missileMovementSpeed) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          // General idea: Create a unit circle around this contact, then create a contact at the 
          // corresponding point on the circle with the matching bearing.

          // Figure out the polar coordinates of a point on the unit circle with angle targetBearing
          const targetX = Math.cos(targetBearing);
          const targetY = Math.sin(targetBearing);

          // Center the unit circle around the launcher's position
          const missileX = Math.cos(this.realBearing) * this.realDistance;
          const missileY = Math.sin(this.realBearing) * this.realDistance;

          // Figure out the actual position in the game world that the missile is being launched towards
          const trueTargetX = missileX + targetX;
          const trueTargetY = missileY + targetY;

          // Convert back to polar coordinates
          const targetContactBearing = Math.atan2(trueTargetY, trueTargetX);
          const targetContactDistance = Math.sqrt(trueTargetX * trueTargetX + trueTargetY * trueTargetY);

          // Create a new contact that just gives a bearing and unit distance
          // to tell the missile what direction to aim in
          // If this is not done, then missiles launched will not know
          // which direction to go in. They will only know where to spawn.
          let targetContact = new Contact(targetContactBearing, targetContactDistance);

          // Set the missile's contact type to match whoever launched it, unless the contact is a player
          // Set it to friendly in that latter case
          let contactType = this.contactType;
          if (this.contactType === "PLAYER") {
            contactType = "FRIENDLY";
          }
          const missile = new MissileContact(this.realBearing, this.realDistance, targetContact, missileFuelTime, contactType, missileArmingTime, missileMovementSpeed);
          contacts.push(missile);

          // Reduce the number of missiles available if applicable
          if (this.numMissiles !== undefined && this.numMissiles !== null) {
            this.numMissiles--;
          }
        } 
      }

      // Launch a missile at the given position (Requires target contact just to tell the missile who it's initially targeting)
      launchMissileAtPoint(targetX, targetY, missileFuelTime, missileArmingTime, missileMovementSpeed) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          
          // Figure out the angle of the line which points from this contact to the target
          // Convert contact position from polar to Cartesian
          const contactX = Math.cos(this.realBearing) * this.realDistance;
          const contactY = Math.sin(this.realBearing) * this.realDistance;

          // Calculate angle from contact to target
          const targetAngle = Math.atan2(targetY - contactY, targetX - contactX);

          // Delegate to launchMissileAlongAngle with the target angle
          this.launchMissileAlongAngle(targetAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
        }
      }

      // Launch a missile at the given contact
      launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed, isSpreadAttack) {
        // Check if there are missiles available (undefined or null indicates infinite missiles)
        if (this.numMissiles > 0 || this.numMissiles === undefined || this.numMissiles === null) {
          // Basic idea: We have four parametric equations, two for the target's position as a function
          // of time, and two for the missile's position as a function of time. 
          // The missile position in x is given by
          //
          // missileX(t) = t * missileVelocityX + missileX(0)    <-- missileX(0) is the initial x position of the missile, so in this case, the launcher's x position
          //
          // The missile position in y is given by
          //
          // missileY(t) = t * missileVelocityY + missileY(0)  <-- missileY(0) is the initial y position of the missile, so in this case, the launcher's y position
          //
          // The target position in x is given by
          //
          // targetX(t) = t * targetVelocityX + targetX(0)  <-- targetX(0) is the initial x position of the target contact, so in this case, its current x position
          //
          // The target position in y is given by
          //
          // targetY(t) = t * targetVelocityY + targetY(0)  <-- targetY(0) is the initial y position of the target contact, so in this case, its current y position
          //
          // We want all four quantities to equal, so we arrive at a system of two equations:
          //
          // missileX(t) = targetX(t) && missileY(t) = targetY(t)
          //
          // We actually have two unknowns. Time is of course one of them, but the other is the angle at which we must launch the missile to collide with the target.
          // It is this quantity we are interested in. We know that launch angle is actually a part of the missile's velocity vector, so we can write
          //
          // missileVelocityX = missileSpeed * cos(missileLaunchAngle) && missileVelocityY = missileSpeed * sin(missileLaunchAngle)
          //
          // We then substitute these into the system of equations, and solve for time and missileLaunchAngle. 
          // It is somewhat challenging to solve this, but by using a symbolic algebra system like the one used by Wolfram Mathematica, we get that there
          // are actually two solutions for both time and angle. We will look at both solutions and chooose which, if any, is the correct one to use.
          // For instance, if angle or time are undefined or infinite, we know that something is wrong with that solution, likely because none is possible.
          // This could happen in a case where we're shooting at something going away faster than we can catch up to it, for instance.
          // Moreover, if time is negative, then our window of opportunity has already passed, and we should not launch the missile using the given solution.
          // Those interested in the derivation of this equation for themselves should be familiar with solutions of equations of the form 
          //
          // sin(x) + b cos(x) = c for real valued constants b and c

          // Time, angle equations 1.
          // These symbols correspond to these quantities:
          // evx - Enemy velocity x
          // evy - Enemy velocity y
          // mxi - Missile initial x position
          // myi - Missile initial y position
          // exi - Enemy initial x position
          // eyi - Enemy initial y position
          // mspeed - Missile speed
          // t - Time
          // a - Angle

          // In Mathematica code, solution pair 1 is given by
          // t=1/(evx^2+evy^2-mspeed^2) (-evx  exi-evy  eyi+evx  mxi+evy  myi-1/2  \[Sqrt](4  (evx (exi-mxi)+evy (eyi-myi))^2-4  (evx^2+evy^2-mspeed^2)  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))
          // a=ArcTan[(-evy  (exi-mxi)  (eyi-myi)+evx  (eyi-myi)^2+(exi-mxi)  \[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)),(evy  (exi-mxi+(eyi-myi)  (-evx  exi+evx  mxi+\[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))]
          
          // In Mathematica code, solution pair 2 is given by
          // t=1/(evx^2+evy^2-mspeed^2) (-evx  exi-evy  eyi+evx  mxi+evy  myi+1/2  \[Sqrt](4  (evx (exi-mxi)+evy (eyi-myi))^2-4  (evx^2+evy^2-mspeed^2)  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))
          // a=ArcTan[(-evy  (exi-mxi)  (eyi-myi)+evx  (eyi-myi)^2+(-exi+mxi)  \[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2)),(evy  (exi-mxi)^2-(eyi-myi)  (evx  exi-evx  mxi+\[Sqrt](-evy^2  (exi-mxi)^2+2  evx  evy  (exi-mxi)  (eyi-myi)-evx^2  (eyi-myi)^2+mspeed^2  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))))/(mspeed  (exi^2+eyi^2-2  exi  mxi+mxi^2-2  eyi  myi+myi^2))]

          // Convert both contacts' polar coordinates to Cartesian
          // For the missile launcher (this contact)
          const mxi = Math.cos(this.realBearing) * this.realDistance; // Missile initial x
          const myi = Math.sin(this.realBearing) * this.realDistance; // Missile initial y
          
          // For the target
          const exi = Math.cos(targetContact.realBearing) * targetContact.realDistance; // Enemy initial x
          const eyi = Math.sin(targetContact.realBearing) * targetContact.realDistance; // Enemy initial y
          
          // Calculate enemy velocity components
          const evx = Math.cos(targetContact.movementDirection) * targetContact.movementSpeed; // Enemy velocity x
          const evy = Math.sin(targetContact.movementDirection) * targetContact.movementSpeed; // Enemy velocity y
          
          // Missile speed
          const mspeed = missileMovementSpeed;
          
          // Calculate values needed for the formulas
          const dx = exi - mxi;
          const dy = eyi - myi;
          const distSquared = dx*dx + dy*dy;

          // We first check to see if we're firing at a ghost
          if (targetContact.contactType === "GHOST") {
            // If we're firing at a ghost, launch directly at ghost's last sighted position
            // Looks odd otherwise (Why is my missile going to this random position this game is buggy!!!)

            // Handle firing a spread as well
            if (isSpreadAttack) {
              // Check if the player ship is the launcher
              // and if firedFirstSpread is false
              // If so, write dialogue 
              if(this.contactType === "PLAYER" && !firedFirstSpread) {
                addDialogue("Captain: Gunnery control, you heard the engineer. Fire a spread at that contact!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                firedFirstSpread = true;
              }

              // Calculate distance in radius units
              const distance = Math.sqrt(distSquared);
               
              // Calculate number of missiles based on distance
              // Add 1 missile for every spreadAttackMissilePerRadiusAmount * radius
              let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
               
              // Set minimum and maximum number of missiles
              numMissiles = Math.max(2, numMissiles);
               
              // Calculate increased arming time (0.5 seconds per missile)
              const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);

              // Figure out angle between this contact and the target contact
              const selectedAngle = Math.atan2(dy, dx);
               
              // Launch a spread of missiles
              const spreadAngle = Math.PI / 6; // 30 degrees
              for (let i = 0; i < numMissiles; i++) {
                const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              }
               
              // Launch one more missile directly at the target
              this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              return;
            }

            this.launchMissileAtPoint(targetContact.distance * Math.cos(targetContact.bearing), targetContact.distance * Math.sin(targetContact.bearing), missileFuelTime, missileArmingTime, missileMovementSpeed);
            return;
          }
          
          // Check if player tried to fire spread at missile (moved up to check in all cases)
          if (this.contactType === "PLAYER" && targetContact.isMissile && isSpreadAttack) {
            if (!firedSpreadAtMissile) {
              addDialogue("Captain: Gunnery control, belay that order! That's a missile, don't waste a spread! Sensors, you should have known better!", captainColor, defaultDialogueTime, captainPortraitFilePath);
            }
            firedSpreadAtMissile = true;
            // Continue with normal single missile firing
            isSpreadAttack = false;
          }
          
          // Calculate the determinant inside the square root
          const determinant = 4 * Math.pow(evx*dx + evy*dy, 2) - 
                              4 * (evx*evx + evy*evy - mspeed*mspeed) * distSquared;
          
          // Only proceed if the determinant is positive (solutions exist)
          if (determinant >= 0) {
            // Calculate solutions for time
            const t1 = 1/(evx*evx + evy*evy - mspeed*mspeed) * 
                     (-evx*exi - evy*eyi + evx*mxi + evy*myi - 0.5 * Math.sqrt(determinant));
            
            const t2 = 1/(evx*evx + evy*evy - mspeed*mspeed) * 
                     (-evx*exi - evy*eyi + evx*mxi + evy*myi + 0.5 * Math.sqrt(determinant));
            
            // Calculate the square root term for angle calculations
            const sqrtTerm = Math.sqrt(-evy*evy*dx*dx + 
                                       2*evx*evy*dx*dy - 
                                       evx*evx*dy*dy + 
                                       mspeed*mspeed*distSquared);
            
            // Calculate angles for both solutions
            const a1x = (-evy*dx*dy + evx*dy*dy + dx*sqrtTerm) / (mspeed*distSquared);
            const a1y = (evy*dx*dx + dy*(-evx*exi + evx*mxi + sqrtTerm)) / (mspeed*distSquared);
            const a1 = Math.atan2(a1y, a1x);
            
            const a2x = (-evy*dx*dy + evx*dy*dy - dx*sqrtTerm) / (mspeed*distSquared);
            const a2y = (evy*dx*dx - dy*(evx*exi - evx*mxi + sqrtTerm)) / (mspeed*distSquared);
            const a2 = Math.atan2(a2y, a2x);
            
            // Choose the best solution (positive time, earliest intercept)
            let selectedTime = null;
            let selectedAngle = null;
            
            if (t1 > 0 && (selectedTime === null || t1 < selectedTime)) {
              selectedTime = t1;
              selectedAngle = a1;
            }
            
            if (t2 > 0 && (selectedTime === null || t2 < selectedTime)) {
              selectedTime = t2;
              selectedAngle = a2;
            }

            // If selected time is greater than missile fuel time, reset selected time to null
            if (selectedTime > missileFuelTime) {
              selectedTime = null;
            } 

            // If we found a valid solution, launch the missile
            if (selectedTime !== null) {
              // this.launchMissileAlongAngle(selectedAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
              // If isSpreadAttack, instead fire a spread of missiles at the target and its immediate surroundings
              // Only do this if firing at a non-missile contact
              if (isSpreadAttack && !targetContact.isMissile) {
                // Check if the player ship is the launcher
                // and if firedFirstSpread is false
                // If so, write dialogue 
                if(this.contactType === "PLAYER" && !firedFirstSpread) {
                  addDialogue("Captain: Gunnery control, you heard the engineer. Fire a spread at that contact!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                  firedFirstSpread = true;
                }

                // Calculate distance in radius units
                const distance = Math.sqrt(distSquared);
                
                // Calculate number of missiles based on distance
                // Add 1 missile for every spreadAttackMissilePerRadiusAmount * radius
                let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                
                // Set minimum and maximum number of missiles
                numMissiles = Math.max(2, numMissiles);
                
                // Calculate increased arming time (0.5 seconds per missile)
                const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                
                // Launch a spread of missiles
                const spreadAngle = Math.PI / 6; // 30 degrees
                for (let i = 0; i < numMissiles; i++) {
                  const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                  this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                }
                
                // Launch one more missile directly at the target
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              } else {
                
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, missileArmingTime, missileMovementSpeed);
              }
            } else {
              // No valid solution found, launch directly at current position as fallback
              
              // NPC ships will never fire a spread at invalid targets
              if (isSpreadAttack && this.contactType !== "PLAYER") {
                // Just fire a single missile to conserve ammo
                this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
              } else {
                // For player, allow them to mess up and fire a spread if that's what they requested
                if (this.contactType === "PLAYER" && isSpreadAttack) {
                  // Calculate spread as in normal spread code
                  const distance = Math.sqrt(distSquared);
                  let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                  numMissiles = Math.max(2, numMissiles);
                  const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                  
                  // Direct angle toward target's current position
                  const selectedAngle = Math.atan2(dy, dx);
                  
                  // Launch spread
                  const spreadAngle = Math.PI / 6; // 30 degrees
                  for (let i = 0; i < numMissiles; i++) {
                    const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                    this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                  }
                  
                  // Launch direct missile too
                  this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                } else {
                  // Just fire a single missile for non-spread or non-player
                  this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
                }
              }
            }
          } else {
            // No intercept solution exists, launch directly at current position
            
            // NPC ships will never fire a spread at invalid targets
            if (isSpreadAttack && this.contactType !== "PLAYER") {
              // Just fire a single missile to conserve ammo
              this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
            } else {
              // For player, allow them to mess up and fire a spread if that's what they requested
              if (this.contactType === "PLAYER" && isSpreadAttack) {
                // Calculate spread as in normal spread code
                const distance = Math.sqrt(distSquared);
                let numMissiles = Math.floor(distance / (spreadAttackMissilePerRadiusAmount * radius)) + 1;
                numMissiles = Math.max(2, numMissiles);
                const increasedArmingTime = missileArmingTime + (0.5 * numMissiles);
                
                // Direct angle toward target's current position
                const selectedAngle = Math.atan2(dy, dx);
                
                // Launch spread
                const spreadAngle = Math.PI / 6; // 30 degrees
                for (let i = 0; i < numMissiles; i++) {
                  const angle = selectedAngle - spreadAngle / 2 + i * spreadAngle / (numMissiles - 1);
                  this.launchMissileAlongAngle(angle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
                }
                
                // Launch direct missile too
                this.launchMissileAlongAngle(selectedAngle, missileFuelTime, increasedArmingTime, missileMovementSpeed);
              } else {
                // Just fire a single missile for non-spread or non-player
                this.launchMissileAtPoint(exi, eyi, missileFuelTime, missileArmingTime, missileMovementSpeed);
              }
            }
          }
        }
      }
      
      draw(deltaTime) {
        // If IFF is broadcasting, the contact should always be visible and updating its contact position
        if (this.iffBroadcasting) {
          this.visible = true;
          this.opacity = 1.0;
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
        }

        if (this.visible) {
          // Draw the contact at the last detected position
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          ctx.beginPath();
          ctx.arc(contactX, contactY, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${this.contactColor[0]}, ${this.contactColor[1]}, ${this.contactColor[2]}, ${this.opacity})`;
          ctx.fill();
          
          // Draw IFF bubble if broadcasting and mouse is nearby
          if (this.iffBroadcasting && typeof mouseX !== 'undefined' && typeof mouseY !== 'undefined') {
            // Calculate distance from mouse to contact
            const dx = mouseX - contactX;
            const dy = mouseY - contactY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate opacity based on distance (fully visible when close, fades out as distance increases)
            const iffOpacity = Math.max(0, 1 - (distance / iffBoxDisplayDistance));
            
            // Only draw if opacity > 0
            if (iffOpacity > 0) {
              // Draw IFF bubble
              const bubblePadding = 10;
              const lines = this.iffString.split('\n');
              const lineHeight = 16;
              const bubbleWidth = lines.reduce((max, line) => Math.max(max, ctx.measureText(line).width), 0) + (bubblePadding * 2);
              var bubbleHeight = ((lines.length + 1) * lineHeight) + (bubblePadding * 2); // Add 1 for the missile count line
              
              // Add extra height for missile count if it exists
              const hasMissiles = this.numMissiles !== undefined && this.numMissiles !== null;
              if (hasMissiles) {
                bubbleHeight += lineHeight;
              }
              
              // Calculate box position - default is to the right of the contact
              let boxX = contactX + 15;
              let boxY = contactY - 10;
              
              // Adjust if the box would go off the right edge of the canvas
              if (boxX + bubbleWidth > width) {
                boxX = contactX - bubbleWidth - 15; // Move to the left of the contact
              }
              
              // Adjust if the box would go off the top or bottom of the canvas
              if (boxY < 0) {
                boxY = 0; // Align with top of canvas
              } else if (boxY + bubbleHeight > height) {
                boxY = height - bubbleHeight; // Align with bottom of canvas
              }
              
              // Draw bubble background
              ctx.fillStyle = `rgba(0, 0, 0, ${iffOpacity * 0.7})`;
              ctx.fillRect(boxX, boxY, bubbleWidth, bubbleHeight);
              ctx.strokeStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.strokeRect(boxX, boxY, bubbleWidth, bubbleHeight);
              
              // Draw IFF string
              ctx.fillStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.font = "12px monospace";
              ctx.textAlign = "left";
              lines.forEach((line, i) => {
                ctx.fillText(line, boxX + bubblePadding, boxY + 15 + (i * lineHeight));
              });
              
              // Draw IFF status
              // ctx.fillStyle = `rgba(0, 255, 0, ${iffOpacity})`;
              // Frienly contacts have a green IFF broadcast, hostile contacts have a red IFF broadcast
              // Neutral contacts have a yellow IFF broadcast. Ghosts should not have an IFF broadcast but if they do, it should be white
              if (this.contactType === "FRIENDLY" || this.contactType === "PLAYER") {
                ctx.fillStyle = `rgba(0, 255, 0, ${iffOpacity})`;
              } else if (this.contactType === "HOSTILE") {
                ctx.fillStyle = `rgba(255, 0, 0, ${iffOpacity})`;
              } else if (this.contactType === "NEUTRAL") {
                ctx.fillStyle = `rgba(255, 255, 0, ${iffOpacity})`;
              } else {
                ctx.fillStyle = `rgba(255, 255, 255, ${iffOpacity})`;
              }
              ctx.fillText("IFF: BROADCASTING", boxX + bubblePadding, boxY + 15 + (lines.length * lineHeight));
              
              // Show missile count if available
              if (hasMissiles) {
                ctx.fillText(`MISSILES: ${this.numMissiles}`, boxX + bubblePadding, boxY + 15 + ((lines.length + 1) * lineHeight));
              }
            }
          }
          
          // Fade out the contact - now based on time
          this.opacity -= this.fadeSpeed * deltaTime;
          if (this.opacity <= 0) {
            this.visible = false;
          }
        }
        
        // Draw ELINT radiation cone if detected
        if (this.radiationDetected) {
          const startAngle = this.realBearing - ELINTHalfAngle;
          const endAngle = this.realBearing + ELINTHalfAngle;
          
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, startAngle, endAngle);
          ctx.lineTo(centerX, centerY);
          ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
          ctx.fill();
          
          // Draw the ELINT cone boundary lines
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(startAngle), 
            centerY + radius * Math.sin(startAngle)
          );
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(endAngle), 
            centerY + radius * Math.sin(endAngle)
          );
          ctx.strokeStyle = "#FFFF00";
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
    }

    // Extend Contacts to add heat seeking missiles
    class MissileContact extends Contact {
      constructor(bearing, distance, targetContact, fuelTime, contactType, armingTime, movementSpeed = 10) {
        // If the contact type is not one of the accepted types, default to "HOSTILE"
        if (!acceptedTypes.includes(contactType)) {
          contactType = "HOSTILE";
        }
        // Figure out the movement direction based on the target contact and the current bearing and distance
        // We are at (bearing, distance) and the target is at (targetContact.bearing, targetContact.distance), in polar coordinates
        // We want to move towards the target, so we need to calculate the angle between the two points
        // This is done by calculating the angle between the two points in cartesian coordinates and then converting it to polar coordinates
        // Figure out our position in cartesian coordinates
        const missileX = Math.cos(bearing) * distance;
        const missileY = Math.sin(bearing) * distance;
        // Figure out the target position in cartesian coordinates
        // so long as the target contact is not null or undefined or something like that
        if (targetContact) {
          var targetXv = Math.cos(targetContact.bearing) * targetContact.distance;
          var targetYv = Math.sin(targetContact.bearing) * targetContact.distance;
        } else {
          // If the target contact is null or undefined, default to the point at the radius and bearing
          var targetXv = Math.cos(bearing) * radius;
          var targetYv = Math.sin(bearing) * radius;
        }
        const targetX = targetXv;
        const targetY = targetYv;
        // Calculate the angle to the target
        const targetAngle = Math.atan2(targetY - missileY, targetX - missileX);

        // If the contact is friendly, create it like so
        if (contactType === "FRIENDLY") {
          // Create a friendly missile
          super(
            bearing, distance, 3, // bearing, starting distance, size
            movementSpeed, 0, targetAngle, // movementSpeed (fast enough to catch just about anything else), directionChangeFrequency (none as it should go only in one direction), movementDirection (direction of the target)
            true, 1.0, true, 1, // visible, opacity, immense radiation emission "due to really powerful engine" or something like that
            true, 1.0, true, 1.0, // fully radar and thermal detectable
            true, "HEAT SEEKING MISSILE\nACTIVE GUIDANCE\nFRIENDLY FIRE", [255, 0, 255], // IFF broadcasting
            contactType // Contact type
          );
        } else {
          // Create a hostile missile
          super(
            bearing, distance, 3, // bearing, starting distance, size
            movementSpeed, 0, targetAngle, // movementSpeed (fast enough to catch just about anything else), directionChangeFrequency (none as it should go only in one direction), movementDirection 
            false, 0, true, 1, // visible, opacity, immense radiation emission "due to really powerful engine" or something like that
            true, 1.0, true, 1.0, // fully radar and thermal detectable
            false, "", [255, 0, 0], // IFF broadcasting
            contactType // Contact type
          );
        }
        
        this.isMissile = true;
        this.targetContact = targetContact;
        this.thermalScanRadius = missileScanRadius;
        this.hasTarget = false;
        
        // Add fuel time property (in seconds)
        this.fuelTime = fuelTime; // Keeps track of original fuel time
        this.fuelRemaining = fuelTime;
        
        // Missile scan properties
        this.scanWidth = missileScanWidth; // Use the same width as the main scanner
        this.scanAngle = 0; // Current scan offset angle
        this.scanReversed = false; // Direction of scan
        this.scanCenter = 0; // Scan is centered forward of the missile

        // Arming time - Missile will not trigger collision check/explosion until armed
        this.armingTime = armingTime;

        // // debug
        // this.positionHistoryString = "Time = 0: " + centerX + ", " + centerY + "\n";
        // this.positionHistory = [{x: centerX, y: centerY, time: 0}];
      }
      
      updatePosition(deltaTime) {
        // debug
        // // get previous time
        // const prevTime = this.positionHistory[this.positionHistory.length - 1].time;
        // this.positionHistoryString += "Time = " + deltaTime + prevTime + ": " + this.realDistance * Math.cos(this.realBearing) + centerX + ", " + this.realDistance * Math.sin(this.realBearing) + centerY + "\n";
        // this.positionHistory.push({x: this.realDistance * Math.cos(this.realBearing) + centerX, y: this.realDistance * Math.sin(this.realBearing) + centerY, time: deltaTime + prevTime});

        // If not armed, count down arming time
        if (this.armingTime > 0) {
          this.armingTime -= deltaTime;
        }

        // Update fuel remaining
        this.fuelRemaining -= deltaTime;
        
        // Self-destruct if out of fuel
        if (this.fuelRemaining <= 0) {
          // Create explosion effect
          createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                         centerY + this.realDistance * Math.sin(this.realBearing));
          
          // Remove from contacts array
          const index = contacts.indexOf(this);
          if (index > -1) {
            contacts.splice(index, 1);
          }
          return;
        }
        
        // Update scan angle
        if (this.scanReversed) {
          this.scanAngle -= (Math.PI * missileScanSpeed / 180) * deltaTime;
          if (this.scanAngle <= -this.scanWidth/2) {
            this.scanAngle = -this.scanWidth/2;
            this.scanReversed = false;
          }
        } else {
          this.scanAngle += (Math.PI * missileScanSpeed / 180) * deltaTime;
          if (this.scanAngle >= this.scanWidth/2) {
            this.scanAngle = this.scanWidth/2;
            this.scanReversed = true;
          }
        }
        
        // Scan for thermal contacts if no target yet and armed 
        if (!this.hasTarget && this.armingTime <= 0) {
          // Use the missile's movement direction as its orientation.
          const missileOrientation = this.movementDirection;
          const absoluteScanAngle = missileOrientation + this.scanAngle;
          
          // Look for contacts in thermal scan range
          for (let contact of contacts) {
            if (contact === this) continue; // Skip self
            
            // Determine missile and contact positions in cartesian coordinates
            const missileX = centerX + this.realDistance * Math.cos(this.realBearing);
            const missileY = centerY + this.realDistance * Math.sin(this.realBearing);
            const contactX = centerX + contact.realDistance * Math.cos(contact.realBearing);
            const contactY = centerY + contact.realDistance * Math.sin(contact.realBearing);
            
            // Calculate position difference and distance
            const dx = contactX - missileX;
            const dy = contactY - missileY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate angle to contact relative to the missile's orientation
            const angleToContact = Math.atan2(dy, dx);
            const angleDiff = normalizeAngle(angleToContact - missileOrientation);
            
            // Check if contact is within scan arc and radius
            if (distance < this.thermalScanRadius &&
                Math.abs(angleDiff - this.scanAngle) < 0.1 &&
                contact.thermalDetectable) {
              this.targetContact = contact;
              this.hasTarget = true;
              break;
            }
          }
        }
        
        // Update missile direction if it has a target
        if (this.hasTarget && this.targetContact && !this.targetContact.destroyed) {
          // Calculate direction to target
          const targetX = Math.cos(this.targetContact.realBearing) * this.targetContact.realDistance;
          const targetY = Math.sin(this.targetContact.realBearing) * this.targetContact.realDistance;
          const missileX = Math.cos(this.realBearing) * this.realDistance;
          const missileY = Math.sin(this.realBearing) * this.realDistance;
          
          // Set movement direction toward target
          this.movementDirection = Math.atan2(targetY - missileY, targetX - missileX);
        }
        
        // Call parent updatePosition
        super.updatePosition(deltaTime);
        
        // Check for collisions with contacts, but only if it has a target
        if (this.hasTarget) {
          this.checkCollisions();
        }
      }
      
      checkCollisions() {
        // Only check for collisions if armed
        if (this.armingTime > 0) return;

        for (let i = 0; i < contacts.length; i++) {
          const contact = contacts[i];
          if (contact === this) continue; // Skip self and other missiles
          
          // Calculate distance between missile and contact
          const dx = Math.cos(contact.realBearing) * contact.realDistance - Math.cos(this.realBearing) * this.realDistance;
          const dy = Math.sin(contact.realBearing) * contact.realDistance - Math.sin(this.realBearing) * this.realDistance;
          const distance = Math.sqrt(dx*dx + dy*dy);
          
          // If collision detected with a thermal detectable contact, destroy both
          if (distance < (this.size + contact.size) && contact.thermalDetectable) {
            // Mark both as destroyed
            this.destroyed = true;
            contact.destroyed = true;
            
            // Create explosion effect
            createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                           centerY + this.realDistance * Math.sin(this.realBearing));
            
            // Remove both from contacts array
            console.log("Missile collided with contact:", contact);
            console.log("Missile destroyed:", this);

            // Check if it was a friendly missile that collided with a hostile contact
            if (this.contactType === "FRIENDLY" && contact.contactType === "HOSTILE") {
              // If the player hasn't made their first kill
              if (!madeFirstKill) {
                addDialogue("Engineer: Telemetry indicates one less hostile!", engineerColor);
                madeFirstKill = true;
              } else if (!madeSecondKill) {
                addDialogue("Captain: Good hit. Let's finish the last of these scum!", captainColor, defaultDialogueTime, captainPortraitFilePath);
                madeSecondKill = true;
              }
            }

            contacts.splice(contacts.indexOf(this), 1);
            contacts.splice(contacts.indexOf(contact), 1);
            return;
          }
        }
      }
      
      draw(deltaTime) {
        // Draw the thermal scan cone if visible and friendly
        // Friendly contacts are "sending missile telemetry" to the player
        // Doesn't make sense for hostile or neutral contacts to do this
        if (this.visible && this.contactType === "FRIENDLY") {
          this.drawScanCone();
        }
        
        // Call parent draw method
        super.draw(deltaTime);
        
        // Draw fuel indicator if visible and friendly (see earlier comment about telemetry)
        if (this.visible && this.contactType === "FRIENDLY") {
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          // Draw fuel bar
          const barWidth = 20;
          const barHeight = 4;
          const fuelPercentage = this.fuelRemaining / this.fuelTime;
          
          // Draw fuel background
          ctx.fillStyle = "rgba(100, 100, 100, 0.7)";
          ctx.fillRect(contactX - barWidth/2, contactY + 8, barWidth, barHeight);
          
          // Draw remaining fuel - color changes as fuel depletes
          let fuelColor;
          if (fuelPercentage > 0.6) {
            fuelColor = "rgba(0, 255, 0, 0.7)"; // Green
          } else if (fuelPercentage > 0.3) {
            fuelColor = "rgba(255, 255, 0, 0.7)"; // Yellow
          } else {
            fuelColor = "rgba(255, 0, 0, 0.7)"; // Red
          }
          
          ctx.fillStyle = fuelColor;
          ctx.fillRect(contactX - barWidth/2, contactY + 8, barWidth * fuelPercentage, barHeight);
          
          // Update IFF string with fuel information
          const fuelSeconds = Math.round(this.fuelRemaining);
          this.iffString = `HEAT SEEKING MISSILE\nACTIVE GUIDANCE\nFUEL: ${fuelSeconds}s REMAINING`;
        }
      }
      
      drawScanCone() {
        // Calculate position on screen
        const missileX = centerX + this.realDistance * Math.cos(this.realBearing);
        const missileY = centerY + this.realDistance * Math.sin(this.realBearing);
        
        // Calculate orientation of missile (direction of movement)
        const missileOrientation = this.movementDirection;
        
        // Calculate start and end angles for the scan cone
        const absoluteScanAngle = missileOrientation + this.scanAngle;
        const startAngle = missileOrientation + this.scanCenter - this.scanWidth/2;
        const endAngle = missileOrientation + this.scanCenter + this.scanWidth/2;
        
        // Draw the thermal scan area
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.arc(missileX, missileY, this.thermalScanRadius, startAngle, endAngle);
        ctx.lineTo(missileX, missileY);
        ctx.fillStyle = "rgba(0, 0, 255, 0.2)"; // Thermal blue for missile scan
        ctx.fill();
        
        // Draw the thermal scan boundary lines
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(startAngle), 
          missileY + this.thermalScanRadius * Math.sin(startAngle)
        );
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(endAngle), 
          missileY + this.thermalScanRadius * Math.sin(endAngle)
        );
        ctx.strokeStyle = "#0000FF"; // Blue outline
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw the active scan line
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(absoluteScanAngle), 
          missileY + this.thermalScanRadius * Math.sin(absoluteScanAngle)
        );
        ctx.strokeStyle = "#0000FF"; // Blue
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    function drawBackground(deltaTime) {
      // Draw fading overlay - fade rate now per second
      ctx.fillStyle = `rgba(0, 0, 0, ${fadeRate * deltaTime})`;
      ctx.fillRect(0, 0, width, height);
      
      // Draw radar circle
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.strokeStyle = "#00AA00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw grid lines
      drawGrid();
    }
    
    function drawGrid() {
      // Draw crosshairs
      ctx.beginPath();
      ctx.moveTo(centerX - radius, centerY);
      ctx.lineTo(centerX + radius, centerY);
      ctx.moveTo(centerX, centerY - radius);
      ctx.lineTo(centerX, centerY + radius);
      ctx.strokeStyle = "#004400";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw concentric circles with range readouts
      const rangeLabels = ["0.25ls", "0.5ls", "0.75ls", "1ls"];
      
      for (let i = 1; i <= 4; i++) {
        const circleRadius = radius * i/4;
        // Draw the circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = "#004400";
        ctx.stroke();
        
        // Draw the range readout at the top of each circle
        ctx.fillStyle = "#00FF00";
        ctx.font = "12px monospace";
        ctx.textAlign = "center";
        ctx.fillText(rangeLabels[i-1], centerX, centerY - circleRadius);
      }
    }
    
    function drawRadarLine() {
      // Calculate the endpoint of the rotating line
      const endX = centerX + radius * Math.cos(angle);
      const endY = centerY + radius * Math.sin(angle);
  
      // Draw the rotating line
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw radar sweep (the glow effect)
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0, 
        centerX, centerY, radius
      );
      gradient.addColorStop(0, "rgba(0, 255, 0, 0.2)");
      gradient.addColorStop(1, "rgba(0, 255, 0, 0)");
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, angle - 0.2, angle, false);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
    
    function drawThermalScan() {
      // Draw the thermal scan zone
      const startAngle = thermalScanCenter - thermalScanWidth/2;
      const endAngle = thermalScanCenter + thermalScanWidth/2;
      
      // Draw the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, thermalScanRadius, startAngle, endAngle);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = "rgba(0, 0, 255, 0.2)";
      ctx.fill();
      
      // Draw the thermal scan boundary lines
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(startAngle), 
                 centerY + thermalScanRadius * Math.sin(startAngle));
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(endAngle), 
                 centerY + thermalScanRadius * Math.sin(endAngle));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw a line sweeping across the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(thermalScanAngle + thermalScanCenter), 
                 centerY + thermalScanRadius * Math.sin(thermalScanAngle + thermalScanCenter));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // For drawing how many missiles are left in stock on the player ship
    // Draws in the top left corner of the screen
    function drawCurrentMissiles() {
      const playerContact = contacts[0]; // Assuming the player ship is the first contact

      if (playerContact && playerContact.visible && playerContact.numMissiles !== undefined) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(10, 10, 150, 50);
        
        ctx.fillStyle = "#00FF00";
        ctx.font = "20px monospace";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText(`MISSILES: ${playerContact.numMissiles}`, 20, 20);
      }

    }

    // Function to add a new dialogue message
    function addDialogue(text, color, duration = defaultDialogueTime, imageFilePath) {
      // Add the message to the array with current time + duration as expiry time
      dialogueMessages.push({
      text: text,
      color: color,
      expiryTime: Date.now() + (duration * 1000), // Multiply by 1000 to convert to milliseconds
      image: imageFilePath
      });
    }

    // Function to draw dialogue messages in the top right corner
    function drawDialogue() {
      const currentTime = Date.now();
      
      // If no messages or all messages expired, don't draw anything
      if (dialogueMessages.length === 0 || dialogueMessages[dialogueMessages.length - 1].expiryTime < currentTime) {
        return;
      }
      
      const maxWidth = 375;
      const padding = 15;
      const lineHeight = 20;
      let currentY = 10; // Start at the top
      
      // Image dimensions
      const imageWidth = 80;
      const imageHeight = 120;
      
      // Draw messages from newest to oldest
      for (let i = dialogueMessages.length - 1; i >= 0; i--) {
        const message = dialogueMessages[i];
        
        // Skip expired messages
        if (message.expiryTime < currentTime) {
          continue;
        }
        
        // Split text into lines for wrapping
        const words = message.text.split(' ');
        let lines = [];
        let currentLine = words.length > 0 ? words[0] : '';
        
        ctx.font = "16px Arial";
        
        // Create wrapped lines
        for (let j = 1; j < words.length; j++) {
          const testLine = currentLine + ' ' + words[j];
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth) {
            lines.push(currentLine);
            currentLine = words[j];
          } else {
            currentLine = testLine;
          }
        }
        lines.push(currentLine);
        
        // Calculate box dimensions based on whether there's an image
        // Has image is true if the image property is defined.
        const hasImage = message.image !== undefined && message.image !== null && message.image !== "" ;
        const boxWidth = maxWidth + (padding * 2) + (hasImage ? imageWidth + padding : 0);
        const boxHeight = Math.max((lines.length * lineHeight) + (padding * 2), hasImage ? imageHeight + (padding * 2) : 0);
        
        // Check if we're going off-screen and need to stop drawing
        if (currentY + boxHeight > height) {
          break;
        }
        
        const boxX = width - boxWidth - 10;
        const boxY = currentY;
        
        // Draw the background box
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Draw the image if specified
        if (hasImage) {
          // If image hasn't been loaded yet, create and cache it
          if (!message.imageObject) {
            message.imageObject = new Image();
            message.imageObject.src = message.image;
          }
          
          // Position image inside the box with some padding
          const imgX = boxX + padding;
          const imgY = boxY + (boxHeight - imageHeight) / 2; // Center vertically
          
          // Only draw if the image is loaded
          if (message.imageObject.complete && message.imageObject.naturalWidth > 0) {
            ctx.drawImage(message.imageObject, imgX, imgY, imageWidth, imageHeight);
          }
        }
        
        // Draw the text - right aligned if no image, left aligned if there is an image
        ctx.fillStyle = message.color;
        ctx.textAlign = hasImage ? "left" : "right";
        ctx.textBaseline = "top";
        
        // Calculate text position
        const textX = hasImage 
          ? boxX + imageWidth + (padding * 2) // If image, position text after image
          : boxX + boxWidth - padding; // If no image, position from right edge
        
        const textY = boxY + (hasImage 
          ? (boxHeight - (lines.length * lineHeight)) / 2 // Center text vertically if there's an image
          : padding); // Default padding if no image
        
        lines.forEach((line, index) => {
          ctx.fillText(line, textX, textY + (index * lineHeight));
        });
        
        // Update Y position for next message
        currentY += boxHeight + 5; // 5px gap between boxes
      }
    }

    // Variables for message history
    let isViewingMessageHistory = false;
    let messageHistoryScrollPosition = 0;
    
    // Function to draw message history window
    function drawMessageHistory() {
      // Clear the screen with a dark background
      ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
      ctx.fillRect(0, 0, width, height);
      
      // Calculate window dimensions
      const margin = 50;
      const windowWidth = width - (margin * 2);
      const windowHeight = height - (margin * 2);
      
      // Draw window background
      ctx.fillStyle = "rgba(20, 20, 30, 0.8)";
      ctx.fillRect(margin, margin, windowWidth, windowHeight);
      ctx.strokeStyle = "rgba(0, 255, 255, 0.7)";
      ctx.lineWidth = 2;
      ctx.strokeRect(margin, margin, windowWidth, windowHeight);
      
      // Draw title
      ctx.font = "bold 24px Arial";
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText("MESSAGE HISTORY", centerX, margin + 20);
      
      // Draw navigation instructions
      ctx.font = "16px Arial";
      ctx.fillStyle = "#AAAAAA";
      ctx.fillText("Use UP/DOWN arrows to scroll, press H to return", centerX, margin + 50);
      
      // Draw divider line
      ctx.beginPath();
      ctx.moveTo(margin + 20, margin + 80);
      ctx.lineTo(margin + windowWidth - 20, margin + 80);
      ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Set up scrollable area
      const contentAreaTop = margin + 100;
      const contentAreaHeight = windowHeight - 120;
      const contentAreaBottom = contentAreaTop + contentAreaHeight;
      
      // Clip to content area
      ctx.save();
      ctx.beginPath();
      ctx.rect(margin + 20, contentAreaTop, windowWidth - 40, contentAreaHeight);
      ctx.clip();
      
      // Display messages
      const lineHeight = 24;
      const visibleMessages = [...dialogueMessages].reverse(); // Show newest messages first
      let y = contentAreaTop - messageHistoryScrollPosition;
      
      ctx.textAlign = "left";
      ctx.font = "16px Arial";
      
      visibleMessages.forEach(message => {
        // Format timestamp
        const timestamp = new Date(message.expiryTime - (defaultDialogueTime * 1000));
        const timeString = timestamp.toTimeString().split(' ')[0];
        
        // Draw timestamp
        ctx.fillStyle = "#888888";
        ctx.fillText(timeString, margin + 40, y);
        
        // Calculate text dimensions and position
        const textMaxWidth = windowWidth - 250;
        
        // Split text into lines for wrapping
        const words = message.text.split(' ');
        let lines = [];
        let currentLine = words.length > 0 ? words[0] : '';
        
        // Create wrapped lines
        for (let i = 1; i < words.length; i++) {
          const testLine = currentLine + ' ' + words[i];
          const metrics = ctx.measureText(testLine);
          if (metrics.width > textMaxWidth) {
            lines.push(currentLine);
            currentLine = words[i];
          } else {
            currentLine = testLine;
          }
        }
        lines.push(currentLine);
        
        // Draw message text
        ctx.fillStyle = message.color;
        lines.forEach((line, index) => {
          ctx.fillText(line, margin + 150, y + (index * lineHeight));
        });
        
        // Move Y position for next message
        y += (lines.length * lineHeight) + 15;
      });
      
      // Restore clipping
      ctx.restore();
      
      // Draw scroll indicators if needed
      if (messageHistoryScrollPosition > 0) {
        // Draw up arrow
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        ctx.moveTo(width - margin - 30, contentAreaTop + 20);
        ctx.lineTo(width - margin - 15, contentAreaTop + 5);
        ctx.lineTo(width - margin - 45, contentAreaTop + 5);
        ctx.closePath();
        ctx.fill();
      }
      
      // Check if we need to show down arrow (if more content exists below)
      const totalContentHeight = visibleMessages.reduce((total, msg) => {
        const lines = Math.ceil(ctx.measureText(msg.text).width / (windowWidth - 150));
        return total + (lines * lineHeight) + 15;
      }, 0);
      
      if (messageHistoryScrollPosition < totalContentHeight - contentAreaHeight && totalContentHeight > contentAreaHeight) {
        // Draw down arrow
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        ctx.moveTo(width - margin - 30, contentAreaBottom - 20);
        ctx.lineTo(width - margin - 15, contentAreaBottom - 5);
        ctx.lineTo(width - margin - 45, contentAreaBottom - 5);
        ctx.closePath();
        ctx.fill();
      }
    }

    // Draws the game over message in the center of the screen
    function drawGameOver() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, width, height);
      
      ctx.font = "bold 48px Arial";
      ctx.fillStyle = gameOverColor;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(gameOverMessage, centerX, centerY);
    }

    // Draws the pause menu in the center of the screen
    // Says "PAUSED" in big centered letters, then below it "Press P to unpause"
    function drawPauseMenu() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, width, height);
      
      ctx.font = "bold 48px Arial";
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("PAUSED", centerX, centerY - 20);
      ctx.font = "24px Arial";
      ctx.fillText("Press P to unpause", centerX, centerY + 20);
      ctx.fillText("Press H for message history", centerX, centerY + 60);
    }
    
    function normalizeAngle(a) {
      // Normalize angle to be between -pi and pi
      return a - Math.PI * 2 * Math.floor((a + Math.PI) / (Math.PI * 2));
    }
      
    // Function to create custom timeouts that respect pause state
    function createTimeout(callback, delay) {
      window.customTimeouts.push({
        callback: callback,
        delay: delay,
        elapsed: 0
      });
    }
    
    function animate(currentTime) {

      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $operationDebugAllowed === "undefined" || $operationDebugAllowed === null || !$operationDebugAllowed) {
        // Cancel the animation frame if the operation is not allowed to run
        return;
      }
    
      // Game over check
      if (gameOver) {
        // If viewing message history, draw that instead of game over menu
        if (isViewingMessageHistory) {
          drawMessageHistory();
        } else {
          // Draw game over message
          drawGameOver();
        }

        // Keep animating, but only up to here
        requestAnimationFrame(animate)
        return;
      }

      // Check if game should end now
      // Check if all player ships are gone
      if (areAllContactsGone("PLAYER")) {
        gameOver = true;
        gameOverMessage = "DEFEAT!";
        gameOverColor = "red";
        // Play defeat sound
        const audio = new Audio("../assets/defeat.mp3");
        audio.play();
      }

      // Check if all hostile contacts are gone
      if (areAllContactsGone("HOSTILE")) {
        gameOver = true;
        $playerWon = true;
        gameOverMessage = "VICTORY!";
        gameOverColor = "green";
        // Play victory sound
        const audio = new Audio("../assets/victory.mp3");
        audio.play();
      }
      
      // Calculate time since last frame
      const deltaTime = ((currentTime - lastFrameTime) / 1000) * deltaTimeMultiplier; // Convert to seconds, then scale by deltaTimeMultiplier
      // Helps with keeping track of unpaused time
      let trueDeltaTimeMillis = currentTime - lastFrameTime;
      lastFrameTime = currentTime;

      // Pause check is placed here to ensure deltaTime will not jump when unpausing
      if (gamePaused) {
        // If viewing message history, draw that instead of pause menu
        if (isViewingMessageHistory) {
          drawMessageHistory();
        } else {
          // Pause menu is drawn in the event listener
        }

        // Keep animating, but only up to here
        requestAnimationFrame(animate)
        return;
      }

      // Keep track of how much time has been spent outside of pause
      unpausedElapsedTimeMillis += trueDeltaTimeMillis;
      
      // Custom timeout handling system
      if (!window.customTimeouts) {
        window.customTimeouts = [];
      }
      
      // Process any active timeouts
      for (let i = window.customTimeouts.length - 1; i >= 0; i--) {
        const timeout = window.customTimeouts[i];
        timeout.elapsed += trueDeltaTimeMillis;
        
        if (timeout.elapsed >= timeout.delay) {
          // Execute the callback and remove from array
          timeout.callback();
          window.customTimeouts.splice(i, 1);
        }
      }
      
      // Cap deltaTime to prevent huge jumps if tab was inactive
      const cappedDeltaTime = Math.min(deltaTime, 0.5);
      
      drawBackground(cappedDeltaTime);
      
      // Calculate thermal scan absolute angle
      const thermalScanAbsoluteAngle = thermalScanAngle + thermalScanCenter;

      // Sort contacts into friendly and hostile arrays
      // Do not include missiles in these arrays
      const friendlyContacts = contacts.filter(contact => contact.contactType === "FRIENDLY" || contact.contactType === "PLAYER" && !contact.isMissile);
      const hostileContacts = contacts.filter(contact => contact.contactType === "HOSTILE" && !contact.isMissile);

      // Keep track of launch chance for both sides
      const hostileLaunchChance = missileLaunchChance;
      const friendlyLaunchChance = missileLaunchChance;

      missileLaunched = false;

      // Randomly make hostile contacts fire missiles at player or friendly contacts
      for (let contact of hostileContacts) {
        // Skip missiles
        if (contact.isMissile) continue;

        if (Math.random() < missileLaunchChance && typeof friendlyContacts !== 'undefined' && friendlyContacts.length > 0) {
          // Randomly select a target from friendly contacts
          const target = friendlyContacts[Math.floor(Math.random() * friendlyContacts.length)];
          if (typeof target !== 'undefined') {
            // Actually fire the missile
            contact.launchMissileAtContact(target, 30, 0.9, 10, Math.random() < chanceOfSpreadAttack);
          }
        }
      }
      
      // Randomly make friendly contacts fire missiles at hostile contacts
      for (let contact of friendlyContacts) {
        // Skip the player contact
        if (contact.contactType === "PLAYER") continue;
        // Skip missiles
        if (contact.isMissile) continue;
        
        if (Math.random() < missileLaunchChance && typeof hostileContacts !== 'undefined' && hostileContacts.length > 0) {
          // Randomly select a target from hostile contacts
          const target = hostileContacts[Math.floor(Math.random() * hostileContacts.length)];
          if (typeof target !== 'undefined') {
            // Actually fire the missile

            // Add dialogue if this is the first missile launch
            if (!friendlyTookAShot) {
              addDialogue("Warspite: Unidentified contacts presumed hostile! Fire at will!", friendlyColor);
              friendlyTookAShot = true;
            }
            contact.launchMissileAtContact(target, 30, 0.9, 10, Math.random() < chanceOfSpreadAttack);
          }
        }
      }

      // If a missile was launched, reset the missileLaunchChance to base value
      if (missileLaunched) {
        missileLaunchChance = baseMissileLaunchChance;
      } else {
        // Otherwise increase the missile launch chance
        missileLaunchChance += missileLaunchIncrease * cappedDeltaTime;
        if (missileLaunchChance > 1.0) missileLaunchChance = 1.0;
      }
      
      // Update and draw contacts
      for (let contact of contacts) {
        contact.updatePosition(cappedDeltaTime);
        contact.checkDetection(angle, thermalScanAbsoluteAngle, thermalScanRadius, cappedDeltaTime);
        contact.draw(cappedDeltaTime);
      }
      
      // Draw the radar line and thermal scan
      drawRadarLine();
      drawThermalScan();
      // Draw the text telling the player in the top left how many missiles are left
      drawCurrentMissiles();
      // Draw the dialogue messages in the top right corner
      drawDialogue();
      
      // Update and draw contact reports
      for (let i = contactReports.length - 1; i >= 0; i--) {
        if (!contactReports[i].update(cappedDeltaTime)) {
          contactReports.splice(i, 1);
        } else {
          contactReports[i].draw();
        }
      }
      
      // Update the radar scan angle (rotate by specified degrees per second)
      angle += (Math.PI * radarSpeed / 180) * cappedDeltaTime;
      if (angle >= Math.PI * 2) angle = 0;

      // Update the thermal scan angle
      if (thermalScanReversed) {
        thermalScanAngle -= (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle <= -thermalScanWidth/2) {
          thermalScanAngle = -thermalScanWidth/2;
          thermalScanReversed = false;
        }
      } else {
        thermalScanAngle += (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle >= thermalScanWidth/2) {
          thermalScanAngle = thermalScanWidth/2;
          thermalScanReversed = true;
        }
      }
      
      requestAnimationFrame(animate);
    }

    // Track mouse position
    let mouseX, mouseY;
    canvas.addEventListener('mousemove', function(event) {
      const rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    });

    // Add click event listener for contact reports
    canvas.addEventListener('click', function(event) {
      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $operationDebugAllowed === "undefined" || $operationDebugAllowed === null || !$operationDebugAllowed) {
        // Cancel the event if the operation is not allowed to be running
        return;
      }
      // If paused, do nothing
      if (gamePaused) return;

      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
    
      // Check if click is on a contact report
      let wasOnContactReport = false;
      for (let i = 0; i < contactReports.length; i++) {
        // Launch a missile if the click is on a contact report and the player ship still has missiles
        // PLayer ship should be the first contact in the contacts array
        if (contactReports[i].contains(mouseX, mouseY) && contacts[0].numMissiles > 0) {
          console.log(`Radar contact at ${contactReports[i].timestamp} reported`);

          // If this is the first contact report clicked, add a dialogue message
          if (isFirstContact) {
            addDialogue(`Engineer: I've got something on scope! I can't pick up any IFF information.`, engineerColor);
            isFirstContact = false;
          }

          wasOnContactReport = true;

          // If this isn't the first contact report clicked and the associated contact is a missile, add a dialogue message for that
          if (contactReports[i].contact.isMissile && !isFirstContact && isFirstMissile) {
            addDialogue(`Engineer: Fast movers! Likely missiles!`, engineerColor);
            // Wait for 3 seconds, then have the captain respond
            createTimeout(() => {
              addDialogue(`Captain: They're pirates! Fire countermissile! General Quarters!`, captainColor, 12);
              // Now mark the player ship as allowed to fire
              allowedToFire = true;
              allowedToFireAtSpot = true;
            }, 1000);
            isFirstMissile = false;
          }
      
          // If not allowed to fire, do nothing
          if (allowedToFire) {
            // Fire at the contact report's associated contact
            // contacts[0] is the player ship, so we will use it to launch the missile
            // launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed)
            contacts[0].launchMissileAtContact(contactReports[i].contact, 30, 0.9, 10, false);
          }

          // Remove the report after clicking
          contactReports.splice(i, 1);
          break;
        }
      }
      // If not on a contact report, check if click is on the radar screen
      if (!wasOnContactReport) {
        // Figure out the fire coordinates based on the mouse position
        const dx = mouseX - centerX;
        const dy = mouseY - centerY;

        // Add dialogue if this is the first time the player has fired from a click
        if (!madeFirstClick) {
          addDialogue("Engineer: Captain, I think we need to fire at this position!", engineerColor);
          madeFirstClick = true;
          createTimeout(() => {
            addDialogue("Captain: Affirmative. I'm networking your console into the fire control system.", captainColor, defaultDialogueTime, captainPortraitFilePath);
            allowedToFireAtSpot = true;
          }, 3000);
          return; // Do nothing until the captain responds
        }

        if (!allowedToFireAtSpot || !allowedToFire) return; // Don't fire if not allowed

        // Try to fire at the given coordinates
        // contacts[0] is the player ship, so we will use it to launch the missile
        // launchMissileAtPoint(targetX, targetY, missileFuelTime, missileArmingTime, missileMovementSpeed)
        contacts[0].launchMissileAtPoint(dx, dy, 30, 0.9, 10);
      }
    });

    // Key event listeners for thermal scan control
    document.addEventListener('keydown', function(event) {
      // Somehow, even when navigating away from the page, the script can keep running
      // To fix this there is now a twine variable that is set to true when this operation should be allowed to run
      // and false when it should not. This is set to false when the player leaves the page, and true when they return.
      // This is set in the twine passage that contains the game, and is set to false when the player leaves the page.
      // This is set to true when the player returns to the page.
      // It's possible for this to be null or undefined, but that shall be treated as false.
      if (typeof $operationDebugAllowed === "undefined" || $operationDebugAllowed === null || !$operationDebugAllowed) {
        // Cancel the event if the operation is not allowed to be running
        return;
      }
      if (event.key === 'a' || event.key === 'A') {
        // Rotate thermal scan left
        // If paused, do nothing
        if (!gamePaused) {
          thermalScanCenter -= 0.1;
          if (thermalScanCenter < 0) thermalScanCenter += Math.PI * 2;
        }
      } else if (event.key === 'd' || event.key === 'D') {
        // Rotate thermal scan right
        // If paused, do nothing
        if (!gamePaused) {
          thermalScanCenter += 0.1;
          if (thermalScanCenter >= Math.PI * 2) thermalScanCenter -= Math.PI * 2;
        }
      } else if (event.key === 'x' || event.key === 'X') {
        // Check if the mouse is over a contact report
        // If paused, do nothing
        if (!gamePaused) {
          for (let i = 0; i < contactReports.length; i++) {
            if (contactReports[i].contains(mouseX, mouseY)) {
              // Dismiss the contact report
              console.log(`Contact report at ${contactReports[i].timestamp} dismissed`);
              contactReports.splice(i, 1);
              break;
            }
          }
        }
      } else if (event.key === 'q' || event.key === 'q') {
        // If not allowed to fire, do nothing
        if (!allowedToFire) return;

        // Check if the mouse is over a contact report
        // If paused, do nothing
        if (!gamePaused) {
          for (let i = 0; i < contactReports.length; i++) {
            if (contactReports[i].contains(mouseX, mouseY)) {
              // Fire a spread at the contact in the contact report
              
              // Fire at the contact report's associated contact
              // contacts[0] is the player ship, so we will use it to launch the missile
              // launchMissileAtContact(targetContact, missileFuelTime, missileArmingTime, missileMovementSpeed, isSpreadAttack)
              contacts[0].launchMissileAtContact(contactReports[i].contact, 30, 0.9, 10, true);

              console.log(`Spread fired at Contact report at ${contactReports[i].timestamp}`);
              contactReports.splice(i, 1);
              break;
            }
          }
        }
      } else if (event.key === 'p' || event.key === 'P') {
        // Toggle pause state if not in game over state
        if (!gameOver) {
          // If viewing message history, just exit that view but remain paused
          if (isViewingMessageHistory) {
            isViewingMessageHistory = false;
            drawPauseMenu();
          } else {
            gamePaused = !gamePaused;
            if (gamePaused) {
              console.log("Game paused");
              // Draw it here to ensure it's only drawn once when paused
              drawPauseMenu();
            } else {
              console.log("Game unpaused");
            }
          }
        }
      } else if (event.key === 'h' || event.key === 'H') {
        // Toggle message history view
        if (isViewingMessageHistory) {
          // Exit message history view but stay paused
          isViewingMessageHistory = false;
          drawPauseMenu();
        } else {
          // If game is not already paused, pause it
          if (!gamePaused) {
            gamePaused = true;
          }
          // Switch to message history view
          isViewingMessageHistory = true;
          // Reset scroll position when first opening
          messageHistoryScrollPosition = 0;
        }
      } else if (event.key === 'ArrowUp') {
        // Scroll message history up
        if (isViewingMessageHistory) {
          messageHistoryScrollPosition = Math.max(0, messageHistoryScrollPosition - 40);
        }
      } else if (event.key === 'ArrowDown') {
        // Scroll message history down
        if (isViewingMessageHistory) {
          messageHistoryScrollPosition += 40;
          // Upper limit will be checked in draw function
        }
      }
    });

    // Create contacts array with initial contacts
    // Parameters: bearing, distance, size, 
    //             movementSpeed, directionChangeFrequency, movementDirection, 
    //             visible, opacity, emittingRadiation, emissionDetectionChance,
    //             radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
    //             iffBroadcasting, iffString, contactColor, contactType,
    //             numMissilesLoaded
    const contacts = [
      // The player's ship. Always visible and at the center of the radar
      // Has 100 missiles loaded
      new Contact(0, 0, 5, 
                  0, 0, 0, 
                  true, 1, true, 0, 
                  true, 0, true, 0,
                  true, "PLAYER SHIP, Heavy Cruiser\nCRS Bounty\nCairn Class", [255, 255, 255],
                  "PLAYER", 100),
      // Real example contacts - speeds now per second
      new Contact(Math.PI/2, radius * 0.15, 5, 
                  0.12, 0.3, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.3,
                  true, 0.6, true, 1,
                  false, "", [255, 0, 0],
                  "HOSTILE"),
      new Contact(3 * Math.PI/2, radius * 0.75, 5, 
                  1.2, 0.3, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 1, true, 1,
                  false, "", [255, 0, 0],
                  "HOSTILE"),
      new Contact(-1 * Math.PI/2, radius * 0.55, 5, 
                  4.5, 0.3, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 1, true, 1,
                  false, "", [255, 0, 0],
                  "HOSTILE"),
      // Real example friendly contacts, broadcasting IFF
      new Contact(0, radius * 0.75, 5, 
                  1.2, 0.3, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.1,
                  true, 0.6, true, 1,
                  true, "Battleship\nHMS Warspite\nQueen Elizabeth Class", [255, 0, 255],
                  "FRIENDLY"),
      // ELINT Ghosts (No thermal, no radar detection)
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      // Radar ghosts (No ELINT, No thermal detection)
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
    ];

    // Fill the canvas with black initially
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, width, height);
    
    // Start the animation with the timestamp
    lastFrameTime = performance.now();

    // Add the initial dialogue message
    addDialogue("Captain: Sensors! What's going on?!",  captainColor, defaultDialogueTime, captainPortraitFilePath);

    requestAnimationFrame(animate);
  })();
</script>
[[Back->Intro 3]]
(set: $playerWonO1 to true)
(set: $playerWonO2 to true)
(set: $playerWonO3 to true)
(set: $playerWonO4 to true)
(set: $playerWonO5 to true)
<!-- TODO remove this -->


:: StoryStylesheet [stylesheet]
img {
  display: block;
  margin-left: auto;
  margin-right: auto;
  width: 800px;
}

.dialogue-container {
  width: 80%;
  margin: 0 auto;
}

.dialogue {
  display: flex;
  align-items: center;
  margin-bottom: 0px;
  position: relative;
}

.portrait {
  width: 80px;
  height: 100px;
  border-radius: 0; /* Changed from 50% to 0 to make rectangular */
  object-fit: cover;
  margin: 0 20px;
}

.dialogue-text {
  flex: 1;
  text-align: center;
  padding: 10px 20px;
  background: rgba(0,0,0,0.1);
  border-radius: 15px;
}

/* Left dialogue has portrait on the left side */
.left-dialogue {
  flex-direction: row;
}

/* Right dialogue has portrait on the right side */
.right-dialogue {
  flex-direction: row-reverse;
}