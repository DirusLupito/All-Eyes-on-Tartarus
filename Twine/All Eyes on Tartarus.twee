:: StoryTitle
All Eyes on Tartarus


:: StoryData
{
  "ifid": "603cb76a-579d-4d57-bff2-50fc09301310",
  "format": "Harlowe",
  "format-version": "3.3.9",
  "start": "Intro 1",
  "zoom": 1
}


:: Intro 1 {"position":"600,200","size":"100,100"}
All Eyes on Tartarus
(set: $playerSeenRadar to false)
<!-- Allow audio button  (unmute all audio) -->
<button id="playAudioButton">Allow Audio</button>
<script>
  // So far we only need to umute:
  // id="submarine-song"
  document.getElementById("playAudioButton").addEventListener("click", function() {
    audioMuted = false;
  }); 
</script>

[[Continue->Intro 2]]


:: Intro 2 {"position":"800,200","size":"100,100"}
The Silent Service
<!-- Take Her Down! (The Submarine Song) -->
<script>
  // If audio is already defined, we should stop it before starting a new one
  if (typeof audio !== 'undefined') {
    audio.pause();
    // And probably remove it from the memory
    delete audio;
  }
  audioSource = "../assets/take-her-down-submariners.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  // audio.muted = audioMuted;
  // If audioMuted is not defined, this will break the script
  // So we need to check and prevent this from happening
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>
[[Continue->Intro 3]]


:: Intro 3 {"position":"1000,200","size":"100,100"}
Construimus, Batuimus
<!-- The Seabees Song -->
<script>
  // Stops the previous audio
  if (typeof audio !== 'undefined') {
    audio.pause();
    delete audio;
  }
  audioSource = "../assets/song-of-the-seabees.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>

(if: $playerSeenRadar is false)[Player hasn't seen Radar]
(if: $playerSeenRadar is true)[Player has seen Radar]

[[Continue->Intro 4]]


:: Intro 4 {"position":"1200,200","size":"100,100"}
Anchors Aweigh
<!-- Anchors Aweigh -->
<script>
  // Stops the previous audio
  if (typeof audio !== 'undefined') {
    audio.pause();
    delete audio;
  }
  audioSource = "../assets/anchors-aweigh.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>

<script>
$playerSeenRadar = true;
</script>

<!-- The sensor game -->
LS: Light Second = 299,792,458 Meters

<!-- Not a game yet, just a circle with a line drawn from the center to the edge 
which continuously rotates around the center, like a radar, and which leaves a fading ghost
of the line behind it. -->
<canvas id="radar" width="800" height="800"></canvas>
<script>
  (function() {
    const canvas = document.getElementById("radar");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 2 - 10;
    
    // Customizable parameters
    const radarSpeed = 0.5; // degrees per frame
    const fadeRate = 0.1;   // fade opacity
    const contactBearing = Math.PI/2; // 90 degrees in radians
    const contactSize = 5; // size of contact blip
    const contactRadius = radius * 0.75; // distance of contact from center
    
    let angle = 0;
    let contactVisible = false;
    let contactOpacity = 0;
  
    // Fill the canvas with black initially
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, width, height);
    
    function drawBackground() {
      // Draw fading overlay
      ctx.fillStyle = `rgba(0, 0, 0, ${fadeRate})`;
      ctx.fillRect(0, 0, width, height);
      
      // Draw radar circle
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.strokeStyle = "#00AA00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw grid lines
      drawGrid();
    }
    
    function drawGrid() {
      // Draw crosshairs
      ctx.beginPath();
      ctx.moveTo(centerX - radius, centerY);
      ctx.lineTo(centerX + radius, centerY);
      ctx.moveTo(centerX, centerY - radius);
      ctx.lineTo(centerX, centerY + radius);
      ctx.strokeStyle = "#004400";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw concentric circles with range readouts
      const rangeLabels = ["0.25ls", "0.5ls", "0.75ls", "1ls"];
      
      for (let i = 1; i <= 4; i++) {
        const circleRadius = radius * i/4;
        // Draw the circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = "#004400";
        ctx.stroke();
        
        // Draw the range readout at the top of each circle
        ctx.fillStyle = "#00FF00";
        ctx.font = "12px monospace";
        ctx.textAlign = "center";
        ctx.fillText(rangeLabels[i-1], centerX, centerY - circleRadius);
      }
    }
    
    function drawRadarLine() {
      // Calculate the endpoint of the rotating line
      const endX = centerX + radius * Math.cos(angle);
      const endY = centerY + radius * Math.sin(angle);
  
      // Draw the rotating line
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw radar sweep (the glow effect)
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0, 
        centerX, centerY, radius
      );
      gradient.addColorStop(0, "rgba(0, 255, 0, 0.2)");
      gradient.addColorStop(1, "rgba(0, 255, 0, 0)");
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, angle - 0.2, angle, false);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
    
    function drawContact() {
      // Check if radar is sweeping over the contact
      const angleDiff = Math.abs(normalizeAngle(angle - contactBearing));
      
      if (angleDiff < 0.1) {
        contactVisible = true;
        contactOpacity = 1.0;
      }
      
      if (contactVisible) {
        // Draw the contact contactRadius units away from the center, in the direction of contactBearing
        const contactX = centerX + contactRadius * Math.cos(contactBearing);
        const contactY = centerY + contactRadius * Math.sin(contactBearing);
        
        ctx.beginPath();
        ctx.arc(contactX, contactY, contactSize, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 0, 0, ${contactOpacity})`;
        ctx.fill();
        
        // Fade out the contact
        contactOpacity -= 0.01;
        if (contactOpacity <= 0) {
          contactVisible = false;
        }
      }
    }
    
    function normalizeAngle(a) {
      // Normalize angle to be between -pi and pi
      return a - Math.PI * 2 * Math.floor((a + Math.PI) / (Math.PI * 2));
    }
    
    function animate() {
      drawBackground();
      drawContact();
      drawRadarLine();
      
      // Update the angle (rotate by specified degrees per frame)
      angle += Math.PI * radarSpeed / 180;
      if (angle >= Math.PI * 2) angle = 0;
      
      requestAnimationFrame(animate);
    }
    
    animate();
  })();
</script>
[[Back->Intro 3]]


:: StoryStylesheet [stylesheet]
img {
  display: block;
  margin-left: auto;
  margin-right: auto;
  width: 800px;
}