:: StoryTitle
All Eyes on Tartarus


:: StoryData
{
  "ifid": "603cb76a-579d-4d57-bff2-50fc09301310",
  "format": "Harlowe",
  "format-version": "3.3.9",
  "start": "Intro 1",
  "zoom": 1
}


:: Intro 1 {"position":"600,200","size":"100,100"}
All Eyes on Tartarus
(set: $playerSeenRadar to false)
<!-- Allow audio button  (unmute all audio) -->
<button id="playAudioButton">Allow Audio</button>
<script>
  // So far we only need to umute:
  // id="submarine-song"
  document.getElementById("playAudioButton").addEventListener("click", function() {
    audioMuted = false;
  }); 
</script>

[[Continue->Intro 2]]


:: Intro 2 {"position":"800,200","size":"100,100"}
The Silent Service
<!-- Take Her Down! (The Submarine Song) -->
<script>
  // If audio is already defined, we should stop it before starting a new one
  if (typeof audio !== 'undefined') {
    audio.pause();
    // And probably remove it from the memory
    delete audio;
  }
  audioSource = "../assets/take-her-down-submariners.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  // audio.muted = audioMuted;
  // If audioMuted is not defined, this will break the script
  // So we need to check and prevent this from happening
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>
[[Continue->Intro 3]]


:: Intro 3 {"position":"1000,200","size":"100,100"}
Construimus, Batuimus
<!-- The Seabees Song -->
<script>
  // Stops the previous audio
  if (typeof audio !== 'undefined') {
    audio.pause();
    delete audio;
  }
  audioSource = "../assets/song-of-the-seabees.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>

(if: $playerSeenRadar is false)[Player hasn't seen Radar]
(if: $playerSeenRadar is true)[Player has seen Radar]

[[Continue->Intro 4]]


:: Intro 4 {"position":"1200,200","size":"100,100"}
Thermal Scan - Use A/D to rotate
LS: Light Second = 299,792,458 Meters
<script>
  // Stops the previous audio
  if (typeof audio !== 'undefined') {
    audio.pause();
    delete audio;
  }
</script>

<!-- The sensor game -->
<canvas id="radar" width="800" height="800"></canvas>
<script>
$playerSeenRadar = true;
  (function() {
    const canvas = document.getElementById("radar");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 2 - 10;
    
    // Track the start time
    const startTime = Date.now();
    
    // Customizable parameters
    const radarSpeed = 0.5; // degrees per frame
    const fadeRate = 0.1;   // fade opacity
    const ELINTHalfAngle = Math.PI/36; // 5 degrees in radians
    
    // Radar line angle
    let angle = 0;
    // Thermal scan angle
    let thermalScanAngle = 0;
    
    // Thermal scan parameters
    const thermalScanWidth = Math.PI/6; // 30 degrees in radians
    const thermalScanRadius = radius * 0.25; // 0.25ls circle
    const thermalScanSpeed = 0.5; // degrees per frame
    let thermalScanCenter = 0; // Center of thermal scan area
    let thermalScanReversed = false; // Direction of thermal scan rotation

    // Contact report parameters
    const contactReports = [];
    const reportLifetime = 600; // number of frames before report disappears

    // Contact Report class
    class ContactReport {
      constructor(x, y, timestamp, contactType, contact) {
        this.x = x;
        this.y = y;
        this.timestamp = timestamp;
        this.contactType = contactType;
        this.contact = contact;
        this.timeCreated = Date.now();
        this.age = 0;
        this.maxAge = reportLifetime;
      }
      
      update() {
        // Increment age, but only if the contact is no longer visible
        if (!this.contact || !this.contact.visible) {
          this.age++;
        }
        return this.age < this.maxAge;
      }
      
      draw() {
        // Calculate opacity based on age
        const opacity = 1 - (this.age / this.maxAge);
        
        // Determine position (ensure it's on screen)
        const boxWidth = 180;
        const boxHeight = 60;
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        // Draw connection line
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(boxX + (boxX > this.x ? 0 : boxWidth), boxY + boxHeight/2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw box
        ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.7})`;
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Draw text
        ctx.font = "10px monospace";
        ctx.fillStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.textAlign = "left";
        ctx.fillText(`DETECTED: ${this.timestamp}`, boxX + 5, boxY + 15);
        ctx.fillText(`POTENTIAL ${this.contactType} CONTACT`, boxX + 5, boxY + 30);
        ctx.fillText("CLICK TO REPORT CONTACT", boxX + 5, boxY + 45);
      }
      
      contains(mouseX, mouseY) {
        // Determine box position
        const boxWidth = 180;
        const boxHeight = 60;
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        return mouseX >= boxX && mouseX <= boxX + boxWidth && 
               mouseY >= boxY && mouseY <= boxY + boxHeight;
      }
    }

    // Contact class definition
    class Contact {
      constructor(bearing, distance, size, movementSpeed, directionChangeFrequency, movementDirection, 
                  visible, opacity, emittingRadiation, emissionDetectionChance, 
                  radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance) {
        // Affects displayed position
        this.bearing = bearing;
        this.distance = distance;
        this.size = size;
        
        // Affects real position for sim (moves independently of the displayed blip)
        this.realBearing = bearing;
        this.realDistance = distance;
        
        // Movement parameters for sim
        this.movementSpeed = movementSpeed;
        this.directionChangeFrequency = directionChangeFrequency;
        this.movementDirection = movementDirection;
        
        // Visibility properties for contact blip
        this.visible = visible;
        this.opacity = opacity;

        // ELINT detection properties
        this.emittingRadiation = emittingRadiation;
        this.emissionDetectionChance = emissionDetectionChance;
        this.radiationDetected = false;
        this.radiationDetectionDuration = 0;
        
        // Radar detection properties
        this.radarDetectable = radarDetectable;
        this.radarDetectionChance = radarDetectionChance;
        this.lastDetectedTime = null;

        // Thermal detection properties
        // NOTE! While the code supports objects hiding from thermal sensors,
        // in practice this should NOT be done unless the object is a SENSOR GHOST (i.e. not a real object)
        this.thermalDetectable = thermalDetectable;
        this.thermalDetectionChance = thermalDetectionChance;
      }
      
      updatePosition() {
        // Randomly change direction occasionally
        if (Math.random() < this.directionChangeFrequency) {
          this.movementDirection += (Math.random() - 0.5) * Math.PI / 2; // Change by up to Â±45 degrees
        }
        
        // Convert polar movement to cartesian
        let dx = Math.cos(this.movementDirection) * this.movementSpeed;
        let dy = Math.sin(this.movementDirection) * this.movementSpeed;
        
        // Convert contact position from polar to cartesian
        let contactX = Math.cos(this.realBearing) * this.realDistance;
        let contactY = Math.sin(this.realBearing) * this.realDistance;
        
        // Update position
        contactX += dx;
        contactY += dy;
        
        // Convert back to polar coordinates
        this.realDistance = Math.sqrt(contactX * contactX + contactY * contactY);
        this.realBearing = Math.atan2(contactY, contactX);
        
        // Keep contact within radar bounds
        if (this.realDistance > radius * 0.95) {
          // If near edge, bounce back
          this.movementDirection = Math.atan2(-contactY, -contactX);
          this.realDistance = radius * 0.95;
        } else if (this.realDistance < radius * 0.1) {
          // If near center, move outward
          this.movementDirection = Math.atan2(contactY, contactX);
          this.realDistance = radius * 0.1;
        }
        
        // Check for radiation detection
        this.checkRadiationDetection();
        
        // Decrease radiation detection duration
        if (this.radiationDetected) {
          this.radiationDetectionDuration--;
          if (this.radiationDetectionDuration <= 0) {
            this.radiationDetected = false;
          }
        }
      }
      
      checkRadiationDetection() {
        if (this.emittingRadiation && Math.random() < this.emissionDetectionChance) {
          // Play a beep
          // ELINTBeep.mp3
          const audio = new Audio("../assets/ELINTBeep.mp3");
          audio.play();

          this.radiationDetected = true;
          this.radiationDetectionDuration = 15; // Show for about .25 second at 60fps
        }
      }
      
      checkDetection(radarAngle, thermalScanAbsoluteAngle, thermalScanRadius) {
        // Check if radar is sweeping over the contact
        const angleDiff = Math.abs(normalizeAngle(radarAngle - this.realBearing));
        let wasNewDetection = false;
        
        if (angleDiff < 0.1 && this.radarDetectable && Math.random() < this.radarDetectionChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          // May want to change this to make it harder since players might learn from this that a pair of contacts is actually
          // just one contact moving around. But for now this stops a massive pile of reports from being generated while the radar
          // is still sweeping over the contact.
          if (wasNewDetection) {
            // Play a ping
            // RadarPing.mp3
            const audio = new Audio("../assets/RadarPing.mp3");
            audio.play();
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const elapsedMs = Date.now() - startTime;
            const minutes = Math.floor(elapsedMs / 60000);
            const seconds = Math.floor((elapsedMs % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "RADAR", this));
          }
        }
        
        // Check if thermal scan is over the contact
        const thermalDiff = Math.abs(normalizeAngle(thermalScanAbsoluteAngle - this.realBearing));
        
        if (thermalDiff < 0.1 && this.realDistance < thermalScanRadius && 
            this.thermalDetectable && Math.random() < this.thermalDetectionChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const elapsedMs = Date.now() - startTime;
            const minutes = Math.floor(elapsedMs / 60000);
            const seconds = Math.floor((elapsedMs % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "THERMAL", this));
          }
        }
      }
      
      draw() {
        if (this.visible) {
          // Draw the contact at the last detected position
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          ctx.beginPath();
          ctx.arc(contactX, contactY, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 0, 0, ${this.opacity})`;
          ctx.fill();
          
          // Fade out the contact
          this.opacity -= 0.01;
          if (this.opacity <= 0) {
            this.visible = false;
          }
        }
        
        // Draw ELINT radiation cone if detected
        if (this.radiationDetected) {
          const startAngle = this.realBearing - ELINTHalfAngle;
          const endAngle = this.realBearing + ELINTHalfAngle;
          
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, startAngle, endAngle);
          ctx.lineTo(centerX, centerY);
          ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
          ctx.fill();
          
          // Draw the ELINT cone boundary lines
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(startAngle), 
            centerY + radius * Math.sin(startAngle)
          );
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(endAngle), 
            centerY + radius * Math.sin(endAngle)
          );
          ctx.strokeStyle = "#FFFF00";
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
    }

    // Create contacts array with initial contacts
    // Parameters: bearing, distance, size, movementSpeed, directionChangeFrequency, movementDirection, 
    //             visible, opacity, emittingRadiation, emissionDetectionChance,
    //             radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance
    const contacts = [
      // Real example contacts
      new Contact(Math.PI/2, radius * 0.15, 5, 0.002, 0.005, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.005,
                  true, 0.01, true, 1),
      new Contact(3 * Math.PI/2, radius * 0.15, 5, 0.02, 0.005, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 1, true, 1),
      // ELINT Ghosts (No thermal, no radar detection)
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5,  2, 0.5, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.001,
                  false, 0, false, 0),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5,  2, 0.5, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.001,
                  false, 0, false, 0),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5,  2, 0.5, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.001,
                  false, 0, false, 0),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5,  2, 0.5, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.001,
                  false, 0, false, 0),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5,  2, 0.5, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.001,
                  false, 0, false, 0),
      // Radar ghosts (No ELINT, No thermal detection)
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5,  2, 0.5, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.001, false, 0),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5,  2, 0.5, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.001, false, 0),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5,  2, 0.5, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.001, false, 0),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5,  2, 0.5, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.001, false, 0),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5,  2, 0.5, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.001, false, 0),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5,  2, 0.5, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.001, false, 0),
    ];
  
    // Fill the canvas with black initially
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, width, height);
    
    // Add click event listener for contact reports
    canvas.addEventListener('click', function(event) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      
      // Check if click is on a contact report
      for (let i = 0; i < contactReports.length; i++) {
        if (contactReports[i].contains(mouseX, mouseY)) {
          console.log(`Radar contact at ${contactReports[i].timestamp} reported`);
          // Remove the report after clicking
          contactReports.splice(i, 1);
          break;
        }
      }
    });
    
    // Key event listeners for thermal scan control
    document.addEventListener('keydown', function(event) {
      if (event.key === 'a' || event.key === 'A') {
        // Rotate thermal scan left
        thermalScanCenter -= 0.1;
        if (thermalScanCenter < 0) thermalScanCenter += Math.PI * 2;
      } else if (event.key === 'd' || event.key === 'D') {
        // Rotate thermal scan right
        thermalScanCenter += 0.1;
        if (thermalScanCenter >= Math.PI * 2) thermalScanCenter -= Math.PI * 2;
      }
    });
    
    function drawBackground() {
      // Draw fading overlay
      ctx.fillStyle = `rgba(0, 0, 0, ${fadeRate})`;
      ctx.fillRect(0, 0, width, height);
      
      // Draw radar circle
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.strokeStyle = "#00AA00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw grid lines
      drawGrid();
    }
    
    function drawGrid() {
      // Draw crosshairs
      ctx.beginPath();
      ctx.moveTo(centerX - radius, centerY);
      ctx.lineTo(centerX + radius, centerY);
      ctx.moveTo(centerX, centerY - radius);
      ctx.lineTo(centerX, centerY + radius);
      ctx.strokeStyle = "#004400";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw concentric circles with range readouts
      const rangeLabels = ["0.25ls", "0.5ls", "0.75ls", "1ls"];
      
      for (let i = 1; i <= 4; i++) {
        const circleRadius = radius * i/4;
        // Draw the circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = "#004400";
        ctx.stroke();
        
        // Draw the range readout at the top of each circle
        ctx.fillStyle = "#00FF00";
        ctx.font = "12px monospace";
        ctx.textAlign = "center";
        ctx.fillText(rangeLabels[i-1], centerX, centerY - circleRadius);
      }
    }
    
    function drawRadarLine() {
      // Calculate the endpoint of the rotating line
      const endX = centerX + radius * Math.cos(angle);
      const endY = centerY + radius * Math.sin(angle);
  
      // Draw the rotating line
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw radar sweep (the glow effect)
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0, 
        centerX, centerY, radius
      );
      gradient.addColorStop(0, "rgba(0, 255, 0, 0.2)");
      gradient.addColorStop(1, "rgba(0, 255, 0, 0)");
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, angle - 0.2, angle, false);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
    
    function drawThermalScan() {
      // Draw the thermal scan zone
      const startAngle = thermalScanCenter - thermalScanWidth/2;
      const endAngle = thermalScanCenter + thermalScanWidth/2;
      
      // Draw the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, thermalScanRadius, startAngle, endAngle);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = "rgba(0, 0, 255, 0.2)";
      ctx.fill();
      
      // Draw the thermal scan boundary lines
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(startAngle), 
                 centerY + thermalScanRadius * Math.sin(startAngle));
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(endAngle), 
                 centerY + thermalScanRadius * Math.sin(endAngle));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw a line sweeping across the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(thermalScanAngle + thermalScanCenter), 
                 centerY + thermalScanRadius * Math.sin(thermalScanAngle + thermalScanCenter));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    function normalizeAngle(a) {
      // Normalize angle to be between -pi and pi
      return a - Math.PI * 2 * Math.floor((a + Math.PI) / (Math.PI * 2));
    }
    
    function animate() {
      drawBackground();
      
      // Calculate thermal scan absolute angle
      const thermalScanAbsoluteAngle = thermalScanAngle + thermalScanCenter;
      
      // Update and draw contacts
      for (let contact of contacts) {
        contact.updatePosition();
        contact.checkDetection(angle, thermalScanAbsoluteAngle, thermalScanRadius);
        contact.draw();
      }
      
      drawRadarLine();
      drawThermalScan();
      
      // Update and draw contact reports
      for (let i = contactReports.length - 1; i >= 0; i--) {
        if (!contactReports[i].update()) {
          contactReports.splice(i, 1);
        } else {
          contactReports[i].draw();
        }
      }
      
      // Update the angle (rotate by specified degrees per frame)
      angle += Math.PI * radarSpeed / 180;
      if (angle >= Math.PI * 2) angle = 0;

      // Update the thermal scan angle
      if (thermalScanReversed) {
        thermalScanAngle -= Math.PI * thermalScanSpeed / 180;
        if (thermalScanAngle <= -thermalScanWidth/2) {
          thermalScanAngle = -thermalScanWidth/2;
          thermalScanReversed = false;
        }
      } else {
        thermalScanAngle += Math.PI * thermalScanSpeed / 180;
        if (thermalScanAngle >= thermalScanWidth/2) {
          thermalScanAngle = thermalScanWidth/2;
          thermalScanReversed = true;
        }
      }
      
      requestAnimationFrame(animate);
    }
    
    animate();
  })();
</script>
[[Back->Intro 3]]


:: StoryStylesheet [stylesheet]
img {
  display: block;
  margin-left: auto;
  margin-right: auto;
  width: 800px;
}