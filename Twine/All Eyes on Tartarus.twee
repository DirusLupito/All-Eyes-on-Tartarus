:: StoryTitle
All Eyes on Tartarus


:: StoryData
{
  "ifid": "603cb76a-579d-4d57-bff2-50fc09301310",
  "format": "Harlowe",
  "format-version": "3.3.9",
  "start": "Intro 1",
  "zoom": 1
}


:: Intro 1 {"position":"600,200","size":"100,100"}
All Eyes on Tartarus
(set: $playerSeenRadar to false)
<!-- Allow audio button  (unmute all audio) -->
<button id="playAudioButton">Allow Audio</button>
<script>
  // So far we only need to umute:
  // id="submarine-song"
  document.getElementById("playAudioButton").addEventListener("click", function() {
    audioMuted = false;
  }); 
</script>

[[Continue->Intro 2]]


:: Intro 2 {"position":"800,200","size":"100,100"}
The Silent Service
<!-- Take Her Down! (The Submarine Song) -->
<script>
  // If audio is already defined, we should stop it before starting a new one
  if (typeof audio !== 'undefined') {
    audio.pause();
    // And probably remove it from the memory
    delete audio;
  }
  audioSource = "../assets/take-her-down-submariners.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  // audio.muted = audioMuted;
  // If audioMuted is not defined, this will break the script
  // So we need to check and prevent this from happening
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>
[[Continue->Intro 3]]


:: Intro 3 {"position":"1000,200","size":"100,100"}
Construimus, Batuimus
<!-- The Seabees Song -->
<script>
  // Stops the previous audio
  if (typeof audio !== 'undefined') {
    audio.pause();
    delete audio;
  }
  audioSource = "../assets/song-of-the-seabees.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>
<!-- Dialogue with alternating character portraits -->
<div class="dialogue-container">
  <!-- Character 1 speaks -->
  <div class="dialogue left-dialogue">
    <img src="../assets/characters/Admiral.png" class="portrait" alt="Character 1">
    <p class="dialogue-text">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam euismod velit nec libero rutrum, non venenatis dolor fringilla. Phasellus id metus at lectus cursus tincidunt.</p>
  </div>
  
  <!-- Character 2 speaks -->
  <div class="dialogue right-dialogue">
    <img src="../assets/characters/Captain.png" class="portrait" alt="Character 2">
    <p class="dialogue-text">Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis.</p>
  </div>
  
  <!-- Character 1 speaks again -->
  <div class="dialogue left-dialogue">
    <img src="../assets/characters/Engineer.png" class="portrait" alt="Character 1">
    <p class="dialogue-text">Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt.</p>
  </div>
  
  <!-- Character 2 speaks again -->
  <div class="dialogue right-dialogue">
    <img src="../assets/characters/Pirate.png" class="portrait" alt="Character 2">
    <p class="dialogue-text">At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium voluptatum deleniti atque corrupti quos dolores et quas molestias excepturi.</p>
  </div>
</div>

<style>
.dialogue-container {
  width: 80%;
  margin: 0 auto;
}

.dialogue {
  display: flex;
  align-items: center;
  margin-bottom: 0px;
  position: relative;
}

.portrait {
  width: 80px;
  height: 100px;
  border-radius: 0; /* Changed from 50% to 0 to make rectangular */
  object-fit: cover;
  margin: 0 20px;
}

.dialogue-text {
  flex: 1;
  text-align: center;
  padding: 10px 20px;
  background: rgba(0,0,0,0.1);
  border-radius: 15px;
}

/* Left dialogue has portrait on the left side */
.left-dialogue {
  flex-direction: row;
}

/* Right dialogue has portrait on the right side */
.right-dialogue {
  flex-direction: row-reverse;
}
</style>

(if: $playerSeenRadar is false)[Player hasn't seen Radar]
(if: $playerSeenRadar is true)[Player has seen Radar]

[[Continue->Intro 4]]


:: Intro 4 {"position":"1200,200","size":"100,100"}
Thermal Scan - Use A/D to rotate
LS: Light Second = 299,792,458 Meters
<script>
  // Stops the previous audio
  if (typeof audio !== 'undefined') {
    audio.pause();
    delete audio;
  }
</script>

<!-- The sensor game -->
<canvas id="radar" width="800" height="800"></canvas>
<script>
$playerSeenRadar = true;
  (function() {
    const canvas = document.getElementById("radar");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 2 - 10;
    
    // Track the start time
    const startTime = Date.now();
    let lastFrameTime = performance.now();
    // Time multiplier
    // 1 = normal speed
    // 2 = double speed
    // 0.5 = half speed
    const deltaTimeMultiplier = 2.4;
    // Detection chance time multiplier
    // Intended to address the fact that PC performance can affect detection chances
    const detectionTimeMultiplier = 1;

    // Game state variables
    let gameOver = false;
    let gameOverMessage = "";
    let gameOverColor = "";

    // Customizable parameters - now in units per second instead of per frame
    const radarSpeed = 30; // degrees per second
    const fadeRate = 6;   // fade opacity per second
    const ELINTHalfAngle = Math.PI/36; // 5 degrees in radians
    
    // Radar line angle
    let angle = 0;
    // Thermal scan angle
    let thermalScanAngle = 0;
    
    // Thermal scan parameters
    const thermalScanWidth = Math.PI/6; // 30 degrees in radians
    const thermalScanRadius = radius * 0.25; // 0.25ls circle
    const thermalScanSpeed = 30; // degrees per second
    let thermalScanCenter = 0; // Center of thermal scan area
    let thermalScanReversed = false; // Direction of thermal scan rotation

    // Missile thermal scan parameters
    const missileScanWidth = Math.PI/6; // 30 degrees in radians
    const missileScanRadius = radius * 0.05; // 0.05ls circle
    const missileScanSpeed = 60; // degrees per second

    // Contact report parameters
    const contactReports = [];
    const reportLifetime = 10; // lifetime in seconds

    // IFF Parameters
    const iffBoxDisplayDistance = 100; // How far away the mouse can be before the IFF box stops displaying
    const acceptedTypes = ["FRIENDLY", "HOSTILE", "NEUTRAL", "GHOST", "PLAYER"]; // Accepted contact types

    // Random missile launch parameters
    const baseMissileLaunchChance = 0.0001;
    missileLaunchChance = baseMissileLaunchChance;
    missileLaunchIncrease = 0.000001;
  
    // Function to create explosion effect
    function createExplosion(x, y) {
      // Play explosion sound (Unused for now)
      // const explosionSound = new Audio("../assets/MissileHit.mp3");
      // explosionSound.play();

      // Visual explosion effect (flash)
      ctx.beginPath();
      ctx.arc(x, y, 30, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255, 200, 50, 0.8)";
      ctx.fill();
    }

    // Function to check if all contacts of a specific type are gone
    function areAllContactsGone(type) {
      return !contacts.some(contact => contact.contactType === type && !contact.destroyed);
    }

    // Contact Report class
    class ContactReport {
      constructor(x, y, timestamp, contactType, contact) {
        this.x = x;
        this.y = y;
        this.timestamp = timestamp;
        this.contactType = contactType;
        this.contact = contact;
        this.timeCreated = Date.now();
        this.age = 0;
        this.maxAge = reportLifetime;
      }
      
      update(deltaTime) {
        // Increment age, but only if the contact is no longer visible or no longer exists
        if (!this.contact || !this.contact.visible || this.contact.destroyed || typeof this.contact === 'undefined') {
          this.age += deltaTime;
        }
        return this.age < this.maxAge;
      }
      
      draw() {
        // Calculate opacity based on age
        const opacity = 1 - (this.age / this.maxAge);
        
        // Determine position (ensure it's on screen)
        const boxWidth = 180;
        const boxHeight = 60;
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        // Draw connection line
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(boxX + (boxX > this.x ? 0 : boxWidth), boxY + boxHeight/2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw box
        ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.7})`;
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Draw text
        ctx.font = "10px monospace";
        ctx.fillStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.textAlign = "left";
        ctx.fillText(`DETECTED: ${this.timestamp}`, boxX + 5, boxY + 15);
        ctx.fillText(`POTENTIAL ${this.contactType} CONTACT`, boxX + 5, boxY + 30);
        ctx.fillText("CLICK TO REPORT CONTACT", boxX + 5, boxY + 45);
      }
      
      contains(mouseX, mouseY) {
        // Determine box position
        const boxWidth = 180;
        const boxHeight = 60;
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        return mouseX >= boxX && mouseX <= boxX + boxWidth && 
               mouseY >= boxY && mouseY <= boxY + boxHeight;
      }
    }

    // Contact class definition
    class Contact {
      constructor(bearing, distance, size, movementSpeed, directionChangeFrequency, movementDirection, 
                  visible, opacity, emittingRadiation, emissionDetectionChance, 
                  radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
                  iffBroadcasting, iffString, contactColor, contactType) {
        // Affects displayed position
        this.bearing = bearing;
        this.distance = distance;
        this.size = size;
        
        // Affects real position for sim (moves independently of the displayed blip)
        this.realBearing = bearing;
        this.realDistance = distance;
        
        // Movement parameters for sim (now per second rather than per frame)
        this.movementSpeed = movementSpeed;
        this.directionChangeFrequency = directionChangeFrequency;
        this.movementDirection = movementDirection;
        this.directionChangeCounter = 0;
        
        // Visibility properties for contact blip
        this.visible = visible;
        this.opacity = opacity;
        this.fadeSpeed = 0.6; // fade per second

        // ELINT detection properties
        this.emittingRadiation = emittingRadiation;
        this.emissionDetectionChance = emissionDetectionChance;
        this.radiationDetected = false;
        this.radiationDetectionDuration = 0;
        
        // Radar detection properties
        this.radarDetectable = radarDetectable;
        this.radarDetectionChance = radarDetectionChance;
        this.lastDetectedTime = null;

        // Thermal detection properties
        this.thermalDetectable = thermalDetectable;
        this.thermalDetectionChance = thermalDetectionChance;

        // IFF (Identification Friend or Foe) properties
        this.iffBroadcasting = iffBroadcasting;
        this.iffString = iffString;
        this.contactColor = contactColor;

        // Currently, there are five types of contacts: "FRIENDLY", "HOSTILE", "NEUTRAL", "GHOST", and "PLAYER"
        // Anything else is treated as "GHOST"
        if (acceptedTypes.includes(contactType)) {
          this.contactType = contactType;
        } else {
          this.contactType = "GHOST";
        }
        // Ghosts must not be thermally detectable
        if (this.contactType === "GHOST") {
          this.thermalDetectable = false;
        }
      }
      
      updatePosition(deltaTime) {
        // Randomly change direction occasionally, now based on elapsed time
        this.directionChangeCounter += deltaTime;
        if (this.directionChangeCounter > (1 / this.directionChangeFrequency)) {
          this.movementDirection += (Math.random() - 0.5) * Math.PI / 2; // Change by up to +/-45 degrees
          this.directionChangeCounter = 0;
        }
        
        // Convert polar movement to cartesian
        let dx = Math.cos(this.movementDirection) * this.movementSpeed * deltaTime;
        let dy = Math.sin(this.movementDirection) * this.movementSpeed * deltaTime;
        
        // Convert contact position from polar to cartesian
        let contactX = Math.cos(this.realBearing) * this.realDistance;
        let contactY = Math.sin(this.realBearing) * this.realDistance;
        
        // Update position
        contactX += dx;
        contactY += dy;
        
        // Convert back to polar coordinates
        this.realDistance = Math.sqrt(contactX * contactX + contactY * contactY);
        this.realBearing = Math.atan2(contactY, contactX);
        
        // Keep contact within radar bounds
        if (this.realDistance > radius * 0.95) {
          // If near edge, bounce back, unless a missile, in which case it should self-destruct
          if (this.isMissile) {
            // Create explosion effect
            createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                           centerY + this.realDistance * Math.sin(this.realBearing));
            
            // Remove from contacts array
            const index = contacts.indexOf(this);
            if (index > -1) {
              contacts.splice(index, 1);
            }
            return;
          }
          this.movementDirection = Math.atan2(-contactY, -contactX);
          this.realDistance = radius * 0.95;
        } else if (this.realDistance < 0) {
          // If somehow at a negative distance, reset to 0
          this.realDistance = 0;
        }
        
        // Check for radiation detection
        this.checkRadiationDetection(deltaTime);
        
        // Decrease radiation detection duration
        if (this.radiationDetected) {
          this.radiationDetectionDuration -= deltaTime;
          if (this.radiationDetectionDuration <= 0) {
            this.radiationDetected = false;
          }
        }
      }
      
      checkRadiationDetection(deltaTime) {
        // Adjust chance based on time
        const timeAdjustedChance = this.emissionDetectionChance * deltaTime * detectionTimeMultiplier;
        
        if (this.emittingRadiation && Math.random() < timeAdjustedChance) {
          // Play a beep
          const audio = new Audio("../assets/ELINTBeep.mp3");
          audio.play();

          this.radiationDetected = true;
          this.radiationDetectionDuration = 0.25; // Show for 0.25 second
        }
      }
      
      checkDetection(radarAngle, thermalScanAbsoluteAngle, thermalScanRadius, deltaTime) {
        // Check if radar is sweeping over the contact
        const angleDiff = Math.abs(normalizeAngle(radarAngle - this.realBearing));
        let wasNewDetection = false;
        
        // Adjust chances based on time
        // If something has a 100% chance of being detected, it should be detected
        const timeAdjustedRadarChance = this.radarDetectionChance >= 1 ? 1 : this.radarDetectionChance * deltaTime * detectionTimeMultiplier;
        //const timeAdjustedThermalChance = this.thermalDetectionChance * deltaTime * detectionTimeMultiplier;
        const timeAdjustedThermalChance = this.thermalDetectionChance > 0 ? 1 : 0; // If something is thermal detectable, it should be detected
        
        if (angleDiff < 0.1 && this.radarDetectable && Math.random() < timeAdjustedRadarChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            // Play a ping
            const audio = new Audio("../assets/RadarPing.mp3");
            audio.play();
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const elapsedMs = Date.now() - startTime;
            const minutes = Math.floor(elapsedMs / 60000);
            const seconds = Math.floor((elapsedMs % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "RADAR", this));
          }
        }
        
        // Check if thermal scan is over the contact
        const thermalDiff = Math.abs(normalizeAngle(thermalScanAbsoluteAngle - this.realBearing));
        
        if (thermalDiff < 0.1 && this.realDistance < thermalScanRadius && 
            this.thermalDetectable && Math.random() < timeAdjustedThermalChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const elapsedMs = Date.now() - startTime;
            const minutes = Math.floor(elapsedMs / 60000);
            const seconds = Math.floor((elapsedMs % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "THERMAL", this));
          }
        }
      }
      
      draw(deltaTime) {
        // If IFF is broadcasting, the contact should always be visible and updating its contact position
        if (this.iffBroadcasting) {
          this.visible = true;
          this.opacity = 1.0;
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
        }

        if (this.visible) {
          // Draw the contact at the last detected position
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          ctx.beginPath();
          ctx.arc(contactX, contactY, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${this.contactColor[0]}, ${this.contactColor[1]}, ${this.contactColor[2]}, ${this.opacity})`;
          ctx.fill();
          
          // Draw IFF bubble if broadcasting and mouse is nearby
          if (this.iffBroadcasting && typeof mouseX !== 'undefined' && typeof mouseY !== 'undefined') {
            // Calculate distance from mouse to contact
            const dx = mouseX - contactX;
            const dy = mouseY - contactY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate opacity based on distance (fully visible when close, fades out as distance increases)
            const iffOpacity = Math.max(0, 1 - (distance / iffBoxDisplayDistance));
            
            // Only draw if opacity > 0
            if (iffOpacity > 0) {
              // Draw IFF bubble
              const bubblePadding = 10;
              const lines = this.iffString.split('\n');
              const lineHeight = 16;
              const bubbleWidth = lines.reduce((max, line) => Math.max(max, ctx.measureText(line).width), 0) + (bubblePadding * 2);
              const bubbleHeight = (lines.length * lineHeight) + (bubblePadding * 2);
              
              // Calculate box position - default is to the right of the contact
              let boxX = contactX + 15;
              let boxY = contactY - 10;
              
              // Adjust if the box would go off the right edge of the canvas
              if (boxX + bubbleWidth > width) {
                boxX = contactX - bubbleWidth - 15; // Move to the left of the contact
              }
              
              // Adjust if the box would go off the top or bottom of the canvas
              if (boxY < 0) {
                boxY = 0; // Align with top of canvas
              } else if (boxY + bubbleHeight > height) {
                boxY = height - bubbleHeight; // Align with bottom of canvas
              }
              
              // Draw bubble background
              ctx.fillStyle = `rgba(0, 0, 0, ${iffOpacity * 0.7})`;
              ctx.fillRect(boxX, boxY, bubbleWidth, bubbleHeight);
              ctx.strokeStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.strokeRect(boxX, boxY, bubbleWidth, bubbleHeight);
              
              // Draw IFF string
              ctx.fillStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.font = "12px monospace";
              ctx.textAlign = "left";
              lines.forEach((line, i) => {
                ctx.fillText(line, boxX + bubblePadding, boxY + 15 + (i * lineHeight));
              });
              
              // Draw IFF status
              // ctx.fillStyle = `rgba(0, 255, 0, ${iffOpacity})`;
              // Frienly contacts have a green IFF broadcast, hostile contacts have a red IFF broadcast
              // Neutral contacts have a yellow IFF broadcast. Ghosts should not have an IFF broadcast but if they do, it should be white
              if (this.contactType === "FRIENDLY" || this.contactType === "PLAYER") {
                ctx.fillStyle = `rgba(0, 255, 0, ${iffOpacity})`;
              } else if (this.contactType === "HOSTILE") {
                ctx.fillStyle = `rgba(255, 0, 0, ${iffOpacity})`;
              } else if (this.contactType === "NEUTRAL") {
                ctx.fillStyle = `rgba(255, 255, 0, ${iffOpacity})`;
              } else {
                ctx.fillStyle = `rgba(255, 255, 255, ${iffOpacity})`;
              }
              ctx.fillText("IFF: BROADCASTING", boxX + bubblePadding, boxY + 15 + (lines.length * lineHeight));
            }
          }
          
          // Fade out the contact - now based on time
          this.opacity -= this.fadeSpeed * deltaTime;
          if (this.opacity <= 0) {
            this.visible = false;
          }
        }
        
        // Draw ELINT radiation cone if detected
        if (this.radiationDetected) {
          const startAngle = this.realBearing - ELINTHalfAngle;
          const endAngle = this.realBearing + ELINTHalfAngle;
          
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, startAngle, endAngle);
          ctx.lineTo(centerX, centerY);
          ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
          ctx.fill();
          
          // Draw the ELINT cone boundary lines
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(startAngle), 
            centerY + radius * Math.sin(startAngle)
          );
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(endAngle), 
            centerY + radius * Math.sin(endAngle)
          );
          ctx.strokeStyle = "#FFFF00";
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
    }
    // Extend Contacts to add heat seeking missiles
    class MissileContact extends Contact {
      constructor(bearing, distance, targetContact, fuelTime, contactType, armingTime) {
        // If the contact type is not one of the accepted types, default to "HOSTILE"
        if (!acceptedTypes.includes(contactType)) {
          contactType = "HOSTILE";
        }
        // Figure out the movement direction based on the target contact and the current bearing and distance
        // We are at (bearing, distance) and the target is at (targetContact.bearing, targetContact.distance), in polar coordinates
        // We want to move towards the target, so we need to calculate the angle between the two points
        // This is done by calculating the angle between the two points in cartesian coordinates and then converting it to polar coordinates
        // Figure out our position in cartesian coordinates
        const missileX = Math.cos(bearing) * distance;
        const missileY = Math.sin(bearing) * distance;
        // Figure out the target position in cartesian coordinates
        const targetX = Math.cos(targetContact.bearing) * targetContact.distance;
        const targetY = Math.sin(targetContact.bearing) * targetContact.distance;
        // Calculate the angle to the target
        const targetAngle = Math.atan2(targetY - missileY, targetX - missileX);

        // If the contact is friendly, create it like so
        if (contactType === "FRIENDLY") {
          // Create a friendly missile
          super(
            bearing, distance, 3, // bearing, starting distance, size
            10, 0, targetAngle, // movementSpeed (fast enough to catch just about anything else), directionChangeFrequency (none as it should go only in one direction), movementDirection (direction of the target)
            true, 1.0, true, 1, // visible, opacity, immense radiation emission "due to really powerful engine" or something like that
            true, 1.0, true, 1.0, // fully radar and thermal detectable
            true, "HEAT SEEKING MISSILE\nACTIVE GUIDANCE\nFRIENDLY FIRE", [255, 0, 255], // IFF broadcasting
            contactType // Contact type
          );
        } else {
          // Create a hostile missile
          super(
            bearing, distance, 3, // bearing, starting distance, size
            20, 0, targetAngle, // movementSpeed (fast enough to catch just about anything else), directionChangeFrequency (none as it should go only in one direction), movementDirection 
            false, 0, true, 1, // visible, opacity, immense radiation emission "due to really powerful engine" or something like that
            true, 1.0, true, 1.0, // fully radar and thermal detectable
            false, "", [255, 0, 0], // IFF broadcasting
            contactType // Contact type
          );
        }
        
        this.isMissile = true;
        this.targetContact = targetContact;
        this.thermalScanRadius = missileScanRadius;
        this.hasTarget = false;
        
        // Add fuel time property (in seconds)
        this.fuelTime = fuelTime; // Keeps track of original fuel time
        this.fuelRemaining = fuelTime;
        
        // Missile scan properties
        this.scanWidth = missileScanWidth; // Use the same width as the main scanner
        this.scanAngle = 0; // Current scan offset angle
        this.scanReversed = false; // Direction of scan
        this.scanCenter = 0; // Scan is centered forward of the missile

        // Arming time - Missile will not trigger collision check/explosion until armed
        this.armingTime = armingTime;
      }
      
      updatePosition(deltaTime) {
        // If not armed, count down arming time
        if (this.armingTime > 0) {
          this.armingTime -= deltaTime;
        }

        // Update fuel remaining
        this.fuelRemaining -= deltaTime;
        
        // Self-destruct if out of fuel
        if (this.fuelRemaining <= 0) {
          // Create explosion effect
          createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                         centerY + this.realDistance * Math.sin(this.realBearing));
          
          // Remove from contacts array
          const index = contacts.indexOf(this);
          if (index > -1) {
            contacts.splice(index, 1);
          }
          return;
        }
        
        // Update scan angle
        if (this.scanReversed) {
          this.scanAngle -= (Math.PI * missileScanSpeed / 180) * deltaTime;
          if (this.scanAngle <= -this.scanWidth/2) {
            this.scanAngle = -this.scanWidth/2;
            this.scanReversed = false;
          }
        } else {
          this.scanAngle += (Math.PI * missileScanSpeed / 180) * deltaTime;
          if (this.scanAngle >= this.scanWidth/2) {
            this.scanAngle = this.scanWidth/2;
            this.scanReversed = true;
          }
        }
        
        // Scan for thermal contacts if no target yet
        if (!this.hasTarget) {
          // Use the missile's movement direction as its orientation.
          const missileOrientation = this.movementDirection;
          const absoluteScanAngle = missileOrientation + this.scanAngle;
          
          // Look for contacts in thermal scan range
          for (let contact of contacts) {
            if (contact === this) continue; // Skip self
            
            // Determine missile and contact positions in cartesian coordinates
            const missileX = centerX + this.realDistance * Math.cos(this.realBearing);
            const missileY = centerY + this.realDistance * Math.sin(this.realBearing);
            const contactX = centerX + contact.realDistance * Math.cos(contact.realBearing);
            const contactY = centerY + contact.realDistance * Math.sin(contact.realBearing);
            
            // Calculate position difference and distance
            const dx = contactX - missileX;
            const dy = contactY - missileY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate angle to contact relative to the missile's orientation
            const angleToContact = Math.atan2(dy, dx);
            const angleDiff = normalizeAngle(angleToContact - missileOrientation);
            
            // Check if contact is within scan arc and radius
            if (distance < this.thermalScanRadius &&
                Math.abs(angleDiff - this.scanAngle) < 0.1 &&
                contact.thermalDetectable) {
              this.targetContact = contact;
              this.hasTarget = true;
              break;
            }
          }
        }
        
        // Update missile direction if it has a target
        if (this.hasTarget && this.targetContact && !this.targetContact.destroyed) {
          // Calculate direction to target
          const targetX = Math.cos(this.targetContact.realBearing) * this.targetContact.realDistance;
          const targetY = Math.sin(this.targetContact.realBearing) * this.targetContact.realDistance;
          const missileX = Math.cos(this.realBearing) * this.realDistance;
          const missileY = Math.sin(this.realBearing) * this.realDistance;
          
          // Set movement direction toward target
          this.movementDirection = Math.atan2(targetY - missileY, targetX - missileX);
        }
        
        // Call parent updatePosition
        super.updatePosition(deltaTime);
        
        // Check for collisions with contacts, but only if it has a target
        if (this.hasTarget) {
          this.checkCollisions();
        }
      }
      
      checkCollisions() {
        // Only check for collisions if armed
        if (this.armingTime > 0) return;

        for (let i = 0; i < contacts.length; i++) {
          const contact = contacts[i];
          if (contact === this) continue; // Skip self and other missiles
          
          // Calculate distance between missile and contact
          const dx = Math.cos(contact.realBearing) * contact.realDistance - Math.cos(this.realBearing) * this.realDistance;
          const dy = Math.sin(contact.realBearing) * contact.realDistance - Math.sin(this.realBearing) * this.realDistance;
          const distance = Math.sqrt(dx*dx + dy*dy);
          
          // If collision detected with a thermal detectable contact, destroy both
          if (distance < (this.size + contact.size) && contact.thermalDetectable) {
            // Mark both as destroyed
            this.destroyed = true;
            contact.destroyed = true;
            
            // Create explosion effect
            createExplosion(centerX + this.realDistance * Math.cos(this.realBearing), 
                           centerY + this.realDistance * Math.sin(this.realBearing));
            
            // Remove both from contacts array
            contacts.splice(contacts.indexOf(this), 1);
            contacts.splice(contacts.indexOf(contact), 1);
            return;
          }
        }
      }
      
      draw(deltaTime) {
        // Draw the thermal scan cone if visible and friendly
        // Friendly contacts are "sending missile telemetry" to the player
        // Doesn't make sense for hostile or neutral contacts to do this
        if (this.visible && this.contactType === "FRIENDLY") {
          this.drawScanCone();
        }
        
        // Call parent draw method
        super.draw(deltaTime);
        
        // Draw fuel indicator if visible and friendly (see earlier comment about telemetry)
        if (this.visible && this.contactType === "FRIENDLY") {
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          // Draw fuel bar
          const barWidth = 20;
          const barHeight = 4;
          const fuelPercentage = this.fuelRemaining / this.fuelTime;
          
          // Draw fuel background
          ctx.fillStyle = "rgba(100, 100, 100, 0.7)";
          ctx.fillRect(contactX - barWidth/2, contactY + 8, barWidth, barHeight);
          
          // Draw remaining fuel - color changes as fuel depletes
          let fuelColor;
          if (fuelPercentage > 0.6) {
            fuelColor = "rgba(0, 255, 0, 0.7)"; // Green
          } else if (fuelPercentage > 0.3) {
            fuelColor = "rgba(255, 255, 0, 0.7)"; // Yellow
          } else {
            fuelColor = "rgba(255, 0, 0, 0.7)"; // Red
          }
          
          ctx.fillStyle = fuelColor;
          ctx.fillRect(contactX - barWidth/2, contactY + 8, barWidth * fuelPercentage, barHeight);
          
          // Update IFF string with fuel information
          const fuelSeconds = Math.round(this.fuelRemaining);
          this.iffString = `HEAT SEEKING MISSILE\nACTIVE GUIDANCE\nFUEL: ${fuelSeconds}s REMAINING`;
        }
      }
      
      drawScanCone() {
        // Calculate position on screen
        const missileX = centerX + this.realDistance * Math.cos(this.realBearing);
        const missileY = centerY + this.realDistance * Math.sin(this.realBearing);
        
        // Calculate orientation of missile (direction of movement)
        const missileOrientation = this.movementDirection;
        
        // Calculate start and end angles for the scan cone
        const absoluteScanAngle = missileOrientation + this.scanAngle;
        const startAngle = missileOrientation + this.scanCenter - this.scanWidth/2;
        const endAngle = missileOrientation + this.scanCenter + this.scanWidth/2;
        
        // Draw the thermal scan area
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.arc(missileX, missileY, this.thermalScanRadius, startAngle, endAngle);
        ctx.lineTo(missileX, missileY);
        ctx.fillStyle = "rgba(0, 0, 255, 0.2)"; // Thermal blue for missile scan
        ctx.fill();
        
        // Draw the thermal scan boundary lines
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(startAngle), 
          missileY + this.thermalScanRadius * Math.sin(startAngle)
        );
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(endAngle), 
          missileY + this.thermalScanRadius * Math.sin(endAngle)
        );
        ctx.strokeStyle = "#0000FF"; // Blue outline
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw the active scan line
        ctx.beginPath();
        ctx.moveTo(missileX, missileY);
        ctx.lineTo(
          missileX + this.thermalScanRadius * Math.cos(absoluteScanAngle), 
          missileY + this.thermalScanRadius * Math.sin(absoluteScanAngle)
        );
        ctx.strokeStyle = "#0000FF"; // Blue
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    // Create contacts array with initial contacts
    // Parameters: bearing, distance, size, 
    //             movementSpeed, directionChangeFrequency, movementDirection, 
    //             visible, opacity, emittingRadiation, emissionDetectionChance,
    //             radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
    //             iffBroadcasting, iffString, contactColor, contactType
    const contacts = [
      // The player's ship. Always visible and at the center of the radar
      new Contact(0, 0, 5, 
                  0, 0, 0, 
                  true, 1, true, 0, 
                  true, 0, true, 0,
                  true, "PLAYER SHIP, Heavy Cruiser\nTNFS Torch\nLantern Class", [255, 255, 255],
                  "PLAYER"),
      // Real example contacts - speeds now per second
      new Contact(Math.PI/2, radius * 0.15, 5, 
                  0.12, 0.3, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.3,
                  true, 0.6, true, 1,
                  false, "", [255, 0, 0],
                  "HOSTILE"),
      new Contact(3 * Math.PI/2, radius * 0.75, 5, 
                  1.2, 0.3, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 1, true, 1,
                  false, "", [255, 0, 0],
                  "HOSTILE"),
      // Real example friendly contacts, broadcasting IFF
      new Contact(0, radius * 0.75, 5, 
                  1.2, 0.3, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.1,
                  true, 0.6, true, 1,
                  true, "Battleship\nHMS Warspite\nQueen Elizabeth Class", [255, 0, 255],
                  "FRIENDLY"),
      // ELINT Ghosts (No thermal, no radar detection)
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      // Radar ghosts (No ELINT, No thermal detection)
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0],
                  "GHOST"),
    ];

    // Fill the canvas with black initially
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, width, height);

    // Track mouse position
    let mouseX, mouseY;
    canvas.addEventListener('mousemove', function(event) {
      const rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    });

    // Add click event listener for contact reports
    canvas.addEventListener('click', function(event) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
    
      // Check if click is on a contact report
      for (let i = 0; i < contactReports.length; i++) {
        if (contactReports[i].contains(mouseX, mouseY)) {
          console.log(`Radar contact at ${contactReports[i].timestamp} reported`);

          // Calculate bearing to the contact report
          const dx = contactReports[i].x - centerX;
          const dy = contactReports[i].y - centerY;
          const bearing = Math.atan2(dy, dx);

          // Create and launch missile
          // MissileContact(bearing, distance, targetContact, fuelTime, contactType, armingTime)
          const missile = new MissileContact(bearing, 0, contactReports[i].contact, 30, "FRIENDLY", 1.0);
          contacts.push(missile);

          // Remove the report after clicking
          contactReports.splice(i, 1);
          break;
        }
      }
    });

    // Key event listeners for thermal scan control
    document.addEventListener('keydown', function(event) {
      if (event.key === 'a' || event.key === 'A') {
        // Rotate thermal scan left
        thermalScanCenter -= 0.1;
        if (thermalScanCenter < 0) thermalScanCenter += Math.PI * 2;
      } else if (event.key === 'd' || event.key === 'D') {
        // Rotate thermal scan right
        thermalScanCenter += 0.1;
        if (thermalScanCenter >= Math.PI * 2) thermalScanCenter -= Math.PI * 2;
      }
    });

    function drawBackground(deltaTime) {
      // Draw fading overlay - fade rate now per second
      ctx.fillStyle = `rgba(0, 0, 0, ${fadeRate * deltaTime})`;
      ctx.fillRect(0, 0, width, height);
      
      // Draw radar circle
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.strokeStyle = "#00AA00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw grid lines
      drawGrid();
    }
    
    function drawGrid() {
      // Draw crosshairs
      ctx.beginPath();
      ctx.moveTo(centerX - radius, centerY);
      ctx.lineTo(centerX + radius, centerY);
      ctx.moveTo(centerX, centerY - radius);
      ctx.lineTo(centerX, centerY + radius);
      ctx.strokeStyle = "#004400";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw concentric circles with range readouts
      const rangeLabels = ["0.25ls", "0.5ls", "0.75ls", "1ls"];
      
      for (let i = 1; i <= 4; i++) {
        const circleRadius = radius * i/4;
        // Draw the circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = "#004400";
        ctx.stroke();
        
        // Draw the range readout at the top of each circle
        ctx.fillStyle = "#00FF00";
        ctx.font = "12px monospace";
        ctx.textAlign = "center";
        ctx.fillText(rangeLabels[i-1], centerX, centerY - circleRadius);
      }
    }
    
    function drawRadarLine() {
      // Calculate the endpoint of the rotating line
      const endX = centerX + radius * Math.cos(angle);
      const endY = centerY + radius * Math.sin(angle);
  
      // Draw the rotating line
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw radar sweep (the glow effect)
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0, 
        centerX, centerY, radius
      );
      gradient.addColorStop(0, "rgba(0, 255, 0, 0.2)");
      gradient.addColorStop(1, "rgba(0, 255, 0, 0)");
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, angle - 0.2, angle, false);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
    
    function drawThermalScan() {
      // Draw the thermal scan zone
      const startAngle = thermalScanCenter - thermalScanWidth/2;
      const endAngle = thermalScanCenter + thermalScanWidth/2;
      
      // Draw the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, thermalScanRadius, startAngle, endAngle);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = "rgba(0, 0, 255, 0.2)";
      ctx.fill();
      
      // Draw the thermal scan boundary lines
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(startAngle), 
                 centerY + thermalScanRadius * Math.sin(startAngle));
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(endAngle), 
                 centerY + thermalScanRadius * Math.sin(endAngle));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw a line sweeping across the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(thermalScanAngle + thermalScanCenter), 
                 centerY + thermalScanRadius * Math.sin(thermalScanAngle + thermalScanCenter));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    function normalizeAngle(a) {
      // Normalize angle to be between -pi and pi
      return a - Math.PI * 2 * Math.floor((a + Math.PI) / (Math.PI * 2));
    }
    
    function animate(currentTime) {
    
      // Game over check
      if (gameOver) {
        // Draw game over message
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, width, height);

        ctx.font = "bold 48px Arial";
        ctx.fillStyle = gameOverColor;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(gameOverMessage, centerX, centerY);

        // Don't animate anymore
        return;
      }

      // Check if game should end now
      // Check if all player ships are gone
      if (areAllContactsGone("PLAYER")) {
        gameOver = true;
        gameOverMessage = "DEFEAT!";
        gameOverColor = "red";
        // Play defeat sound
        const audio = new Audio("../assets/defeat.mp3");
        audio.play();
      }

      // Check if all hostile contacts are gone
      if (areAllContactsGone("HOSTILE")) {
        gameOver = true;
        gameOverMessage = "VICTORY!";
        gameOverColor = "green";
        // Play victory sound
        const audio = new Audio("../assets/victory.mp3");
        audio.play();
      }
      
      // Calculate time since last frame
      const deltaTime = ((currentTime - lastFrameTime) / 1000) * deltaTimeMultiplier; // Convert to seconds, then scale by deltaTimeMultiplier
      lastFrameTime = currentTime;
      
      // Cap deltaTime to prevent huge jumps if tab was inactive
      const cappedDeltaTime = Math.min(deltaTime, 0.5);
      
      drawBackground(cappedDeltaTime);
      
      // Calculate thermal scan absolute angle
      const thermalScanAbsoluteAngle = thermalScanAngle + thermalScanCenter;

      // Sort contacts into friendly and hostile arrays
      // Do not include missiles in these arrays
      const friendlyContacts = contacts.filter(contact => contact.contactType === "FRIENDLY" || contact.contactType === "PLAYER");
      const hostileContacts = contacts.filter(contact => contact.contactType === "HOSTILE" && !contact.isMissile);

      // Keep track of launch chance for both sides
      const hostileLaunchChance = missileLaunchChance;
      const friendlyLaunchChance = missileLaunchChance;

      missileLaunched = false;

      // Randomly make hostile contacts fire missiles at player or friendly contacts
      for (let contact of hostileContacts) {
        // Skip missiles
        if (contact.isMissile) continue;

        if (Math.random() < missileLaunchChance && typeof friendlyContacts !== 'undefined' && friendlyContacts.length > 0) {
          // Randomly select a target from friendly contacts
          const target = friendlyContacts[Math.floor(Math.random() * friendlyContacts.length)];
          if (typeof target !== 'undefined') {
        
            // Calculate position offset
            // Figure out the direction from contact to target
            const contactX = Math.cos(contact.realBearing) * contact.realDistance;
            const contactY = Math.sin(contact.realBearing) * contact.realDistance;
            const targetX = Math.cos(target.realBearing) * target.realDistance;
            const targetY = Math.sin(target.realBearing) * target.realDistance;

            // Direction to target
            const directionAngle = Math.atan2(targetY - contactY, targetX - contactX);

            // Offset distance based on contact size plus a little extra
            const offsetDistance = contact.size * 2;

            // Calculate new starting position with offset
            const offsetX = contactX + Math.cos(directionAngle) * offsetDistance;
            const offsetY = contactY + Math.sin(directionAngle) * offsetDistance;

            // Convert back to polar coordinates
            const missileDistance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
            const missileBearing = Math.atan2(offsetY, offsetX);

            // Create the missile at the offset position
            const missile = new MissileContact(missileBearing, missileDistance, target, 30, "HOSTILE", 0.2);
            contacts.push(missile);
            missileLaunched = true;
          }
        }
      }
      
      // Randomly make friendly contacts fire missiles at hostile contacts
      for (let contact of friendlyContacts) {
        // Skip the player contact
        if (contact.contactType === "PLAYER") continue;
        // Skip missiles
        if (contact.isMissile) continue;
        
        if (Math.random() < missileLaunchChance && typeof hostileContacts !== 'undefined' && hostileContacts.length > 0) {
          // Randomly select a target from hostile contacts
          const target = hostileContacts[Math.floor(Math.random() * hostileContacts.length)];
          if (typeof target !== 'undefined') {
        
            // Calculate position offset
            // Figure out the direction from contact to target
            const contactX = Math.cos(contact.realBearing) * contact.realDistance;
            const contactY = Math.sin(contact.realBearing) * contact.realDistance;
            const targetX = Math.cos(target.realBearing) * target.realDistance;
            const targetY = Math.sin(target.realBearing) * target.realDistance;
            
            // Direction to target
            const directionAngle = Math.atan2(targetY - contactY, targetX - contactX);
            
            // Offset distance based on contact size plus a little extra
            const offsetDistance = contact.size * 2;
            
            // Calculate new starting position with offset
            const offsetX = contactX + Math.cos(directionAngle) * offsetDistance;
            const offsetY = contactY + Math.sin(directionAngle) * offsetDistance;
            
            // Convert back to polar coordinates
            const missileDistance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
            const missileBearing = Math.atan2(offsetY, offsetX);
            
            // Create the missile at the offset position - marked as FRIENDLY type
            const missile = new MissileContact(missileBearing, missileDistance, target, 30, "FRIENDLY", 0.2);
            contacts.push(missile);
            missileLaunched = true;
          }
        }
      }

      // If a missile was launched, reset the missileLaunchChance to base value
      if (missileLaunched) {
        missileLaunchChance = baseMissileLaunchChance;
      } else {
        // Otherwise increase the missile launch chance
        missileLaunchChance += missileLaunchIncrease;
        if (missileLaunchChance > 1.0) missileLaunchChance = 1.0;
      }
          
      
      // Update and draw contacts
      for (let contact of contacts) {
        contact.updatePosition(cappedDeltaTime);
        contact.checkDetection(angle, thermalScanAbsoluteAngle, thermalScanRadius, cappedDeltaTime);
        contact.draw(cappedDeltaTime);
      }
      
      drawRadarLine();
      drawThermalScan();
      
      // Update and draw contact reports
      for (let i = contactReports.length - 1; i >= 0; i--) {
        if (!contactReports[i].update(cappedDeltaTime)) {
          contactReports.splice(i, 1);
        } else {
          contactReports[i].draw();
        }
      }
      
      // Update the angle (rotate by specified degrees per second)
      angle += (Math.PI * radarSpeed / 180) * cappedDeltaTime;
      if (angle >= Math.PI * 2) angle = 0;

      // Update the thermal scan angle
      if (thermalScanReversed) {
        thermalScanAngle -= (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle <= -thermalScanWidth/2) {
          thermalScanAngle = -thermalScanWidth/2;
          thermalScanReversed = false;
        }
      } else {
        thermalScanAngle += (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle >= thermalScanWidth/2) {
          thermalScanAngle = thermalScanWidth/2;
          thermalScanReversed = true;
        }
      }
      
      requestAnimationFrame(animate);
    }
    
    // Start the animation with the timestamp
    lastFrameTime = performance.now();
    requestAnimationFrame(animate);
  })();
</script>
[[Back->Intro 3]]


:: StoryStylesheet [stylesheet]
img {
  display: block;
  margin-left: auto;
  margin-right: auto;
  width: 800px;
}