:: StoryTitle
All Eyes on Tartarus


:: StoryData
{
  "ifid": "603cb76a-579d-4d57-bff2-50fc09301310",
  "format": "Harlowe",
  "format-version": "3.3.9",
  "start": "Intro 1",
  "zoom": 1
}


:: Intro 1 {"position":"600,200","size":"100,100"}
All Eyes on Tartarus
(set: $playerSeenRadar to false)
<!-- Allow audio button  (unmute all audio) -->
<button id="playAudioButton">Allow Audio</button>
<script>
  // So far we only need to umute:
  // id="submarine-song"
  document.getElementById("playAudioButton").addEventListener("click", function() {
    audioMuted = false;
  }); 
</script>

[[Continue->Intro 2]]


:: Intro 2 {"position":"800,200","size":"100,100"}
The Silent Service
<!-- Take Her Down! (The Submarine Song) -->
<script>
  // If audio is already defined, we should stop it before starting a new one
  if (typeof audio !== 'undefined') {
    audio.pause();
    // And probably remove it from the memory
    delete audio;
  }
  audioSource = "../assets/take-her-down-submariners.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  // audio.muted = audioMuted;
  // If audioMuted is not defined, this will break the script
  // So we need to check and prevent this from happening
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>
[[Continue->Intro 3]]


:: Intro 3 {"position":"1000,200","size":"100,100"}
Construimus, Batuimus
<!-- The Seabees Song -->
<script>
  // Stops the previous audio
  if (typeof audio !== 'undefined') {
    audio.pause();
    delete audio;
  }
  audioSource = "../assets/song-of-the-seabees.mp3";
  audio = new Audio(audioSource);
  audio.loop = true;
  if (typeof audioMuted !== 'undefined') {
    audio.muted = audioMuted;
  }
  audio.play();
</script>

(if: $playerSeenRadar is false)[Player hasn't seen Radar]
(if: $playerSeenRadar is true)[Player has seen Radar]

[[Continue->Intro 4]]


:: Intro 4 {"position":"1200,200","size":"100,100"}
Thermal Scan - Use A/D to rotate
LS: Light Second = 299,792,458 Meters
<script>
  // Stops the previous audio
  if (typeof audio !== 'undefined') {
    audio.pause();
    delete audio;
  }
</script>

<!-- The sensor game -->
<canvas id="radar" width="800" height="800"></canvas>
<script>
$playerSeenRadar = true;
  (function() {
    const canvas = document.getElementById("radar");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 2 - 10;
    
    // Track the start time
    const startTime = Date.now();
    let lastFrameTime = performance.now();
    // Time multiplier
    // 1 = normal speed
    // 2 = double speed
    // 0.5 = half speed
    const deltaTimeMultiplier = 2.4;
    // Detection chance time multiplier
    // Intended to address the fact that PC performance can affect detection chances
    const detectionTimeMultiplier = 1;

    // Customizable parameters - now in units per second instead of per frame
    const radarSpeed = 30; // degrees per second
    const fadeRate = 6;   // fade opacity per second
    const ELINTHalfAngle = Math.PI/36; // 5 degrees in radians
    
    // Radar line angle
    let angle = 0;
    // Thermal scan angle
    let thermalScanAngle = 0;
    
    // Thermal scan parameters
    const thermalScanWidth = Math.PI/6; // 30 degrees in radians
    const thermalScanRadius = radius * 0.25; // 0.25ls circle
    const thermalScanSpeed = 30; // degrees per second
    let thermalScanCenter = 0; // Center of thermal scan area
    let thermalScanReversed = false; // Direction of thermal scan rotation

    // Contact report parameters
    const contactReports = [];
    const reportLifetime = 10; // lifetime in seconds

    // IFF Parameters
    const iffBoxDisplayDistance = 100; // How far away the mouse can be before the IFF box stops displaying

    // Contact Report class
    class ContactReport {
      constructor(x, y, timestamp, contactType, contact) {
        this.x = x;
        this.y = y;
        this.timestamp = timestamp;
        this.contactType = contactType;
        this.contact = contact;
        this.timeCreated = Date.now();
        this.age = 0;
        this.maxAge = reportLifetime;
      }
      
      update(deltaTime) {
        // Increment age, but only if the contact is no longer visible
        if (!this.contact || !this.contact.visible) {
          this.age += deltaTime;
        }
        return this.age < this.maxAge;
      }
      
      draw() {
        // Calculate opacity based on age
        const opacity = 1 - (this.age / this.maxAge);
        
        // Determine position (ensure it's on screen)
        const boxWidth = 180;
        const boxHeight = 60;
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        // Draw connection line
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(boxX + (boxX > this.x ? 0 : boxWidth), boxY + boxHeight/2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw box
        ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.7})`;
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Draw text
        ctx.font = "10px monospace";
        ctx.fillStyle = `rgba(0, 255, 255, ${opacity})`;
        ctx.textAlign = "left";
        ctx.fillText(`DETECTED: ${this.timestamp}`, boxX + 5, boxY + 15);
        ctx.fillText(`POTENTIAL ${this.contactType} CONTACT`, boxX + 5, boxY + 30);
        ctx.fillText("CLICK TO REPORT CONTACT", boxX + 5, boxY + 45);
      }
      
      contains(mouseX, mouseY) {
        // Determine box position
        const boxWidth = 180;
        const boxHeight = 60;
        let boxX = this.x + 15;
        let boxY = this.y - boxHeight - 15;
        
        // Adjust if would go off screen
        if (boxX + boxWidth > width) boxX = this.x - boxWidth - 15;
        if (boxY < 0) boxY = this.y + 15;
        
        return mouseX >= boxX && mouseX <= boxX + boxWidth && 
               mouseY >= boxY && mouseY <= boxY + boxHeight;
      }
    }

    // Contact class definition
    class Contact {
      constructor(bearing, distance, size, movementSpeed, directionChangeFrequency, movementDirection, 
                  visible, opacity, emittingRadiation, emissionDetectionChance, 
                  radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
                  iffBroadcasting, iffString, contactColor) {
        // Affects displayed position
        this.bearing = bearing;
        this.distance = distance;
        this.size = size;
        
        // Affects real position for sim (moves independently of the displayed blip)
        this.realBearing = bearing;
        this.realDistance = distance;
        
        // Movement parameters for sim (now per second rather than per frame)
        this.movementSpeed = movementSpeed;
        this.directionChangeFrequency = directionChangeFrequency;
        this.movementDirection = movementDirection;
        this.directionChangeCounter = 0;
        
        // Visibility properties for contact blip
        this.visible = visible;
        this.opacity = opacity;
        this.fadeSpeed = 0.6; // fade per second

        // ELINT detection properties
        this.emittingRadiation = emittingRadiation;
        this.emissionDetectionChance = emissionDetectionChance;
        this.radiationDetected = false;
        this.radiationDetectionDuration = 0;
        
        // Radar detection properties
        this.radarDetectable = radarDetectable;
        this.radarDetectionChance = radarDetectionChance;
        this.lastDetectedTime = null;

        // Thermal detection properties
        this.thermalDetectable = thermalDetectable;
        this.thermalDetectionChance = thermalDetectionChance;

        // IFF (Identification Friend or Foe) properties
        this.iffBroadcasting = iffBroadcasting;
        this.iffString = iffString;
        this.contactColor = contactColor;
      }
      
      updatePosition(deltaTime) {
        // Randomly change direction occasionally, now based on elapsed time
        this.directionChangeCounter += deltaTime;
        if (this.directionChangeCounter > (1 / this.directionChangeFrequency)) {
          this.movementDirection += (Math.random() - 0.5) * Math.PI / 2; // Change by up to +/-45 degrees
          this.directionChangeCounter = 0;
        }
        
        // Convert polar movement to cartesian
        let dx = Math.cos(this.movementDirection) * this.movementSpeed * deltaTime;
        let dy = Math.sin(this.movementDirection) * this.movementSpeed * deltaTime;
        
        // Convert contact position from polar to cartesian
        let contactX = Math.cos(this.realBearing) * this.realDistance;
        let contactY = Math.sin(this.realBearing) * this.realDistance;
        
        // Update position
        contactX += dx;
        contactY += dy;
        
        // Convert back to polar coordinates
        this.realDistance = Math.sqrt(contactX * contactX + contactY * contactY);
        this.realBearing = Math.atan2(contactY, contactX);
        
        // Keep contact within radar bounds
        if (this.realDistance > radius * 0.95) {
          // If near edge, bounce back
          this.movementDirection = Math.atan2(-contactY, -contactX);
          this.realDistance = radius * 0.95;
        } else if (this.realDistance < radius * 0.1) {
          // If near center, move outward
          this.movementDirection = Math.atan2(contactY, contactX);
          this.realDistance = radius * 0.1;
        }
        
        // Check for radiation detection
        this.checkRadiationDetection(deltaTime);
        
        // Decrease radiation detection duration
        if (this.radiationDetected) {
          this.radiationDetectionDuration -= deltaTime;
          if (this.radiationDetectionDuration <= 0) {
            this.radiationDetected = false;
          }
        }
      }
      
      checkRadiationDetection(deltaTime) {
        // Adjust chance based on time
        const timeAdjustedChance = this.emissionDetectionChance * deltaTime * detectionTimeMultiplier;
        
        if (this.emittingRadiation && Math.random() < timeAdjustedChance) {
          // Play a beep
          const audio = new Audio("../assets/ELINTBeep.mp3");
          audio.play();

          this.radiationDetected = true;
          this.radiationDetectionDuration = 0.25; // Show for 0.25 second
        }
      }
      
      checkDetection(radarAngle, thermalScanAbsoluteAngle, thermalScanRadius, deltaTime) {
        // Check if radar is sweeping over the contact
        const angleDiff = Math.abs(normalizeAngle(radarAngle - this.realBearing));
        let wasNewDetection = false;
        
        // Adjust chances based on time
        // If something has a 100% chance of being detected, it should be detected
        const timeAdjustedRadarChance = this.radarDetectionChance >= 1 ? 1 : this.radarDetectionChance * deltaTime * detectionTimeMultiplier;
        //const timeAdjustedThermalChance = this.thermalDetectionChance * deltaTime * detectionTimeMultiplier;
        const timeAdjustedThermalChance = this.thermalDetectionChance > 0 ? 1 : 0; // If something is thermal detectable, it should be detected
        
        if (angleDiff < 0.1 && this.radarDetectable && Math.random() < timeAdjustedRadarChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            // Play a ping
            const audio = new Audio("../assets/RadarPing.mp3");
            audio.play();
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const elapsedMs = Date.now() - startTime;
            const minutes = Math.floor(elapsedMs / 60000);
            const seconds = Math.floor((elapsedMs % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "RADAR", this));
          }
        }
        
        // Check if thermal scan is over the contact
        const thermalDiff = Math.abs(normalizeAngle(thermalScanAbsoluteAngle - this.realBearing));
        
        if (thermalDiff < 0.1 && this.realDistance < thermalScanRadius && 
            this.thermalDetectable && Math.random() < timeAdjustedThermalChance) {
          // Check if this is a new detection
          if (!this.visible) {
            wasNewDetection = true;
          }

          this.visible = true;
          this.opacity = 1.0;
          // Update the displayed contact position to the real position
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
          
          // Create a contact report for new detections
          if (wasNewDetection) {
            const contactX = centerX + this.distance * Math.cos(this.bearing);
            const contactY = centerY + this.distance * Math.sin(this.bearing);
            
            // Format timestamp as minutes:seconds since start
            const elapsedMs = Date.now() - startTime;
            const minutes = Math.floor(elapsedMs / 60000);
            const seconds = Math.floor((elapsedMs % 60000) / 1000);
            const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            this.lastDetectedTime = timestamp;
            contactReports.push(new ContactReport(contactX, contactY, timestamp, "THERMAL", this));
          }
        }
      }
      
      draw(deltaTime) {
        // If IFF is broadcasting, the contact should always be visible and updating its contact position
        if (this.iffBroadcasting) {
          this.visible = true;
          this.opacity = 1.0;
          this.bearing = this.realBearing;
          this.distance = this.realDistance;
        }

        if (this.visible) {
          // Draw the contact at the last detected position
          const contactX = centerX + this.distance * Math.cos(this.bearing);
          const contactY = centerY + this.distance * Math.sin(this.bearing);
          
          ctx.beginPath();
          ctx.arc(contactX, contactY, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${this.contactColor[0]}, ${this.contactColor[1]}, ${this.contactColor[2]}, ${this.opacity})`;
          ctx.fill();
          
          // Draw IFF bubble if broadcasting and mouse is nearby
          if (this.iffBroadcasting && typeof mouseX !== 'undefined' && typeof mouseY !== 'undefined') {
            // Calculate distance from mouse to contact
            const dx = mouseX - contactX;
            const dy = mouseY - contactY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate opacity based on distance (fully visible when close, fades out as distance increases)
            const iffOpacity = Math.max(0, 1 - (distance / iffBoxDisplayDistance));
            
            // Only draw if opacity > 0
            if (iffOpacity > 0) {
              // Draw IFF bubble
              const bubblePadding = 10;
              const lines = this.iffString.split('\n');
              const lineHeight = 16;
              const bubbleWidth = lines.reduce((max, line) => Math.max(max, ctx.measureText(line).width), 0) + (bubblePadding * 2);
              const bubbleHeight = (lines.length * lineHeight) + (bubblePadding * 2);
              
              // Calculate box position - default is to the right of the contact
              let boxX = contactX + 15;
              let boxY = contactY - 10;
              
              // Adjust if the box would go off the right edge of the canvas
              if (boxX + bubbleWidth > width) {
                boxX = contactX - bubbleWidth - 15; // Move to the left of the contact
              }
              
              // Adjust if the box would go off the top or bottom of the canvas
              if (boxY < 0) {
                boxY = 0; // Align with top of canvas
              } else if (boxY + bubbleHeight > height) {
                boxY = height - bubbleHeight; // Align with bottom of canvas
              }
              
              // Draw bubble background
              ctx.fillStyle = `rgba(0, 0, 0, ${iffOpacity * 0.7})`;
              ctx.fillRect(boxX, boxY, bubbleWidth, bubbleHeight);
              ctx.strokeStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.strokeRect(boxX, boxY, bubbleWidth, bubbleHeight);
              
              // Draw IFF string
              ctx.fillStyle = `rgba(0, 255, 255, ${iffOpacity})`;
              ctx.font = "12px monospace";
              ctx.textAlign = "left";
              lines.forEach((line, i) => {
                ctx.fillText(line, boxX + bubblePadding, boxY + 15 + (i * lineHeight));
              });
              
              // Draw IFF status
              ctx.fillStyle = `rgba(0, 255, 0, ${iffOpacity})`;
              ctx.fillText("IFF: BROADCASTING", boxX + bubblePadding, boxY + 15 + (lines.length * lineHeight));
            }
          }
          
          // Fade out the contact - now based on time
          this.opacity -= this.fadeSpeed * deltaTime;
          if (this.opacity <= 0) {
            this.visible = false;
          }
        }
        
        // Draw ELINT radiation cone if detected
        if (this.radiationDetected) {
          const startAngle = this.realBearing - ELINTHalfAngle;
          const endAngle = this.realBearing + ELINTHalfAngle;
          
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, startAngle, endAngle);
          ctx.lineTo(centerX, centerY);
          ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
          ctx.fill();
          
          // Draw the ELINT cone boundary lines
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(startAngle), 
            centerY + radius * Math.sin(startAngle)
          );
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(
            centerX + radius * Math.cos(endAngle), 
            centerY + radius * Math.sin(endAngle)
          );
          ctx.strokeStyle = "#FFFF00";
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
    }

    // Create contacts array with initial contacts
    // Parameters: bearing, distance, size, 
    //             movementSpeed, directionChangeFrequency, movementDirection, 
    //             visible, opacity, emittingRadiation, emissionDetectionChance,
    //             radarDetectable, radarDetectionChance, thermalDetectable, thermalDetectionChance,
    //             iffBroadcasting, iffString
    const contacts = [
      // Real example contacts - speeds now per second
      new Contact(Math.PI/2, radius * 0.15, 5, 
                  0.12, 0.3, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.3,
                  true, 0.6, true, 1,
                  false, "", [255, 0, 0]),
      new Contact(3 * Math.PI/2, radius * 0.15, 5, 
                  1.2, 0.3, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 1, true, 1,
                  false, "", [255, 0, 0]),
      // Real example friendly contacts, broadcasting IFF
      new Contact(0, radius * 0.75, 5, 
                  1.2, 0.3, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.3,
                  true, 0.6, true, 1,
                  true, "Friendly Battleship\nHMS Warspite\nQueen Elizabeth Class", [255, 0, 255]),
      // ELINT Ghosts (No thermal, no radar detection)
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0]),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0]),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0]),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0]),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, true, 0.03,
                  false, 0, false, 0,
                  false, "", [255, 0, 0]),
      // Radar ghosts (No ELINT, No thermal detection)
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0]),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0]),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0]),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0]),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0]),
      new Contact(Math.random() * Math.PI * 2, Math.random() * radius, 5, 
                  120, 30, Math.random() * Math.PI * 2, 
                  false, 0, false, 0, 
                  true, 0.12, false, 0,
                  false, "", [255, 0, 0]),
    ];

    // Fill the canvas with black initially
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, width, height);

    // Track mouse position
    let mouseX, mouseY;
    canvas.addEventListener('mousemove', function(event) {
      const rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    });

    // Add click event listener for contact reports
    canvas.addEventListener('click', function(event) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      
      // Check if click is on a contact report
      for (let i = 0; i < contactReports.length; i++) {
        if (contactReports[i].contains(mouseX, mouseY)) {
          console.log(`Radar contact at ${contactReports[i].timestamp} reported`);
          // Remove the report after clicking
          contactReports.splice(i, 1);
          break;
        }
      }
    });

    // Key event listeners for thermal scan control
    document.addEventListener('keydown', function(event) {
      if (event.key === 'a' || event.key === 'A') {
        // Rotate thermal scan left
        thermalScanCenter -= 0.1;
        if (thermalScanCenter < 0) thermalScanCenter += Math.PI * 2;
      } else if (event.key === 'd' || event.key === 'D') {
        // Rotate thermal scan right
        thermalScanCenter += 0.1;
        if (thermalScanCenter >= Math.PI * 2) thermalScanCenter -= Math.PI * 2;
      }
    });
    
    function drawBackground(deltaTime) {
      // Draw fading overlay - fade rate now per second
      ctx.fillStyle = `rgba(0, 0, 0, ${fadeRate * deltaTime})`;
      ctx.fillRect(0, 0, width, height);
      
      // Draw radar circle
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.strokeStyle = "#00AA00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw grid lines
      drawGrid();
    }
    
    function drawGrid() {
      // Draw crosshairs
      ctx.beginPath();
      ctx.moveTo(centerX - radius, centerY);
      ctx.lineTo(centerX + radius, centerY);
      ctx.moveTo(centerX, centerY - radius);
      ctx.lineTo(centerX, centerY + radius);
      ctx.strokeStyle = "#004400";
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw concentric circles with range readouts
      const rangeLabels = ["0.25ls", "0.5ls", "0.75ls", "1ls"];
      
      for (let i = 1; i <= 4; i++) {
        const circleRadius = radius * i/4;
        // Draw the circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = "#004400";
        ctx.stroke();
        
        // Draw the range readout at the top of each circle
        ctx.fillStyle = "#00FF00";
        ctx.font = "12px monospace";
        ctx.textAlign = "center";
        ctx.fillText(rangeLabels[i-1], centerX, centerY - circleRadius);
      }
    }
    
    function drawRadarLine() {
      // Calculate the endpoint of the rotating line
      const endX = centerX + radius * Math.cos(angle);
      const endY = centerY + radius * Math.sin(angle);
  
      // Draw the rotating line
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw radar sweep (the glow effect)
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0, 
        centerX, centerY, radius
      );
      gradient.addColorStop(0, "rgba(0, 255, 0, 0.2)");
      gradient.addColorStop(1, "rgba(0, 255, 0, 0)");
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, angle - 0.2, angle, false);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
    
    function drawThermalScan() {
      // Draw the thermal scan zone
      const startAngle = thermalScanCenter - thermalScanWidth/2;
      const endAngle = thermalScanCenter + thermalScanWidth/2;
      
      // Draw the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, thermalScanRadius, startAngle, endAngle);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = "rgba(0, 0, 255, 0.2)";
      ctx.fill();
      
      // Draw the thermal scan boundary lines
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(startAngle), 
                 centerY + thermalScanRadius * Math.sin(startAngle));
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(endAngle), 
                 centerY + thermalScanRadius * Math.sin(endAngle));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw a line sweeping across the thermal scan area
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + thermalScanRadius * Math.cos(thermalScanAngle + thermalScanCenter), 
                 centerY + thermalScanRadius * Math.sin(thermalScanAngle + thermalScanCenter));
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    function normalizeAngle(a) {
      // Normalize angle to be between -pi and pi
      return a - Math.PI * 2 * Math.floor((a + Math.PI) / (Math.PI * 2));
    }
    
    function animate(currentTime) {
      // Calculate time since last frame
      const deltaTime = ((currentTime - lastFrameTime) / 1000) * deltaTimeMultiplier; // Convert to seconds, then scale by deltaTimeMultiplier
      lastFrameTime = currentTime;
      
      // Cap deltaTime to prevent huge jumps if tab was inactive
      const cappedDeltaTime = Math.min(deltaTime, 0.5);
      
      drawBackground(cappedDeltaTime);
      
      // Calculate thermal scan absolute angle
      const thermalScanAbsoluteAngle = thermalScanAngle + thermalScanCenter;
      
      // Update and draw contacts
      for (let contact of contacts) {
        contact.updatePosition(cappedDeltaTime);
        contact.checkDetection(angle, thermalScanAbsoluteAngle, thermalScanRadius, cappedDeltaTime);
        contact.draw(cappedDeltaTime);
      }
      
      drawRadarLine();
      drawThermalScan();
      
      // Update and draw contact reports
      for (let i = contactReports.length - 1; i >= 0; i--) {
        if (!contactReports[i].update(cappedDeltaTime)) {
          contactReports.splice(i, 1);
        } else {
          contactReports[i].draw();
        }
      }
      
      // Update the angle (rotate by specified degrees per second)
      angle += (Math.PI * radarSpeed / 180) * cappedDeltaTime;
      if (angle >= Math.PI * 2) angle = 0;

      // Update the thermal scan angle
      if (thermalScanReversed) {
        thermalScanAngle -= (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle <= -thermalScanWidth/2) {
          thermalScanAngle = -thermalScanWidth/2;
          thermalScanReversed = false;
        }
      } else {
        thermalScanAngle += (Math.PI * thermalScanSpeed / 180) * cappedDeltaTime;
        if (thermalScanAngle >= thermalScanWidth/2) {
          thermalScanAngle = thermalScanWidth/2;
          thermalScanReversed = true;
        }
      }
      
      requestAnimationFrame(animate);
    }
    
    // Start the animation with the timestamp
    lastFrameTime = performance.now();
    requestAnimationFrame(animate);
  })();
</script>
[[Back->Intro 3]]


:: StoryStylesheet [stylesheet]
img {
  display: block;
  margin-left: auto;
  margin-right: auto;
  width: 800px;
}